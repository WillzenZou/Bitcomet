<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.illustrate.html"><strong aria-hidden="true">1.</strong> 项目简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1.Design.html"><strong aria-hidden="true">1.1.</strong> 方案设计</a></li><li class="chapter-item expanded "><a href="1.2.Plan.html"><strong aria-hidden="true">1.2.</strong> 开发计划与进展</a></li><li class="chapter-item expanded "><a href="1.3.explain.html"><strong aria-hidden="true">1.3.</strong> 项目分工与目录说明</a></li></ol></li><li class="chapter-item expanded "><a href="2.Bitcomet_Design.html"><strong aria-hidden="true">2.</strong> Bitcomet设计文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1.Bitcomet方案概述.html"><strong aria-hidden="true">2.1.</strong> Bitcomet方案分析</a></li><li class="chapter-item expanded "><a href="2.2.Bitcomet方案设计与主要工作.html"><strong aria-hidden="true">2.2.</strong> Bitcomet方案设计与主要工作</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Bitcomet实现</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1安卓图形架构中的HAL模块.html"><strong aria-hidden="true">3.1.</strong> Bitcomet图形架构HAL模块实现</a></li><li class="chapter-item expanded "><a href="3.2关于Anbox中图形渲染分析与总结.html"><strong aria-hidden="true">3.2.</strong> Bitcomet图形渲染实现</a></li><li class="chapter-item expanded "><a href="3.3Anbox实现分析-容器管理服务.html"><strong aria-hidden="true">3.3.</strong> Anbox分析资料：Anbox容器管理服务</a></li><li class="chapter-item expanded "><a href="3.4.Anbox实现分析-IO模型.html"><strong aria-hidden="true">3.4.</strong> Anbox分析资料：IO 模型</a></li><li class="chapter-item expanded "><a href="3.5.Anbox实现分析-会话管理器与容器管理器的通信.html"><strong aria-hidden="true">3.5.</strong> Anbox分析资料：会话管理器与容器管理器的通信</a></li></ol></li><li class="chapter-item expanded "><a href="4.Bitcomet实验测试.html"><strong aria-hidden="true">4.</strong> Bitcomet实验测试</a></li><li class="chapter-item expanded "><a href="5.run.html"><strong aria-hidden="true">5.</strong> 使用教程</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 项目记录</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.1.record.html"><strong aria-hidden="true">6.1.</strong> 问题记录与总结</a></li><li class="chapter-item expanded "><a href="6.2.experience.html"><strong aria-hidden="true">6.2.</strong> 比赛收获</a></li></ol></li><li class="chapter-item expanded "><a href="7.Bitcomet未来展望与参考文献.html"><strong aria-hidden="true">7.</strong> Bitcomet未来展望与参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="proj156-一种基于linux系统运行android-11的解决方案"><a class="header" href="#proj156-一种基于linux系统运行android-11的解决方案">proj156 一种基于Linux系统运行Android 11的解决方案</a></h1>
<p>高校队伍：广东东软学院 Bitcomet队</p>
<p>项目成员：邹明燊、田梓汎、张阳彬</p>
<p>指导教师：刘翠莲、罗泉</p>
<h2 id="1-项目简介"><a class="header" href="#1-项目简介">1. 项目简介</a></h2>
<h3 id="11-目标描述"><a class="header" href="#11-目标描述">1.1 目标描述</a></h3>
<p>        本项目目标在现有Anbox实现Android 7在Linux平台正常运行的基础上将其进一步完善，实现Android11在Linux（Ubuntu20.04）平台上的运行，还可根据用户需求下载并正常运行第三方软件。Anbox（Android in a box）是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。它将Android应用放进密封的容器中，无需直接访问硬件或数据，所有硬件或数据的访问都是通过与主机上的Anbox守护进程进行的。由于Anbox 直接跑在硬件上，没有软件模拟层，无需虚拟化硬件即可运行 Android，因此可以无缝桥接硬件加速功能。</p>
<p>        本项目主要基于Anbox来参考实现，旨在完成以下四个目标：</p>
<ul>
<li>
<p><strong>目标1：<strong>完成针对Android11的</strong>SDcard的文件系统挂载机制</strong>、<strong>SELinux安全机制、非特权模式下运行处理</strong>对应在Docker容器环境内的处理。</p>
</li>
<li>
<p><strong>目标2：<strong>配置</strong>安卓项目工程</strong>，实现并配置好各个需要的系统模块和AIDL、HIDL、HAL模块，搭建初步调试与测试的Demo1版本，使用adb配合Scrcpy对内部Android远程访问以方便有个初步预期，并且方便本项目有个初步测试的环境。</p>
</li>
<li>
<p><strong>目标3：<strong>完成</strong>Anbox通信部分</strong>实现向Android 11的移植，使Android能与Anbox外部实现跨系统环境通信。</p>
</li>
<li>
<p><strong>目标4：<strong>完成</strong>Anbox其余部分的各个模块移植</strong>，使Android的三个基础部分OpenGL、HWC图形输出、键鼠输入能正常工作。</p>
<p>        目前，我们的赛题目标完成度如下：</p>
<center>表1.1 赛题完成度</center>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">目标编号</th><th style="text-align: center">基本完成情况</th><th>额外说明</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">基本完成（≈85%）</td><td>1. 与SDcard以及SELinux组件相关的Android 11的基本功能、SDcard文件管理、安装第三方软件、闹铃与联系人等基础应用测试均通过。<br>2. 非特权模式仅做了部分处理，未进行测试。</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">基本完成（≈90%）</td><td>1. 搭建好相关容器，进行相关基础测试并通过。<br/>2. 目前网络部分由于在Docker特权模式下运行，可能会有Bug。</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">初步完成（≈80%）</td><td>1. 完成跨系统环境通信，安卓中Anbox的相关模块可以使用QEMU_PIPE（实际容器中是没有QEMU设备，Anbox实际用了Unix Domain Socket代替，但其通信的相关通道仍然叫做QEMU PIPE）进行通信或者使用Anbox实现的RPC调用。<br/>2. Anbox的OpenGL ES的emulation库实现初步测试能通过该通信创建QEMU_PIPE连接，实现RPC调用获取到主机侧支持的OpenGL信息。<br/>3. 由于各个部分的模块暂未完全移植好，还需要全部移植才能测试所有功能。</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">初步测试（≈60%）</td><td>1. 已经把相应的Anbox的各个模块的移植到Android中，其中GPS与Audio模块使用了谷歌给Goldfish的实现。<br/>2.OpenGL ES实现和HWC实现在Android 11下无法测试，由于Android 11的相关变动，导致输出画面调用了Gralloc的PostFB去输出，而在Anbox中是未做这部分RPC调用的，输出画面失败。<br/>3.把相关方案在Android 10上进行测试，测试可以输出画面，但卡在安卓Launcher第一屏画面。</td></tr>
<tr><td style="text-align: center">总计</td><td style="text-align: center">≈80%</td><td>1. 本项目自立项以来经历了三个月的时间进行研究与开发，实现方案的过程中遇到困难重重，主要遇到的阻力在系统庞大、相关实现的资料缺失方面。<br />2. 目前还有部分的工作需要测试和完成。由于Android 11在图形和音频方面变动较大，即使目前进行了相关模块的移植，但是还需要在图形模块、音频模块、输入模块方面进行各类测试和调试工作。<br />3. 项目将放在Github进行公开，把截至目前学习的成果公开，希望后续有更多的参与者参与进来进行开发完善。</td></tr>
</tbody></table>
</div></li>
</ul>
<h3 id="12-比赛题目分析和相关资料调研"><a class="header" href="#12-比赛题目分析和相关资料调研">1.2 比赛题目分析和相关资料调研</a></h3>
<h4 id="121-题目分析"><a class="header" href="#121-题目分析">1.2.1 题目分析</a></h4>
<p>        (1). 题目旨在实现在Linux运行Android11的解决方案，在Linux上基于容器技术隔离一个环境运行Android，其运行机制是直接基于宿主机内核下运行Android，其运行效率非常高效，对系统资源占用和运算资源的损耗都极低。<br />
        (2). 在所有实现方案中，选定了基于Anbox的实现方式。由于现今用户使用的软件硬件环境不统一，Mesa 3D等实现方式对图形处理硬件的支持有限，用户的图形环境不一定是Wayland而是X11偏多。同时考虑到可能未来需要在各类国产主机运行架构不统一（Arm、x86、MIPS、LoongArch等架构），<strong>Anbox对于不同系统不同硬件的兼容性优势使得其是现有方案中最合适的</strong>。<br />
        (3). 在实现过程中，考虑到Anbox的LXC也是比较老的容器架构，同时其集成LXC的操作不利于后续容器核心升级、配置调整、在线镜像更新和镜像快速部署等，所以使用Docker来支撑其Android的运行环境，对比最初的LXC方案来说拥有更高的灵活性和可靠性。<br />
        (4). 项目计划是初期构建调整好Android高版本核心跑起一个基于Docker容器实现的Demo，后续逐步移植剩余Anbox组件到Android11上。</p>
<h4 id="122-资料调研"><a class="header" href="#122-资料调研">1.2.2 资料调研</a></h4>
<h5 id="现有方案"><a class="header" href="#现有方案">现有方案</a></h5>
<p>        (1). Anbox：基于LXC容器运行Android 7，利用QEMU pipe实现Android与Anbox上层Linux软件用户接口进行通信。其通信中输入的数据包括：接收传入的传感器数据，接收用户鼠标点击和触摸事件，接收APP启动和窗口调整数据、Anbox上层软件屏幕缓冲区的可选回传等；通信中输出的数据则包括：传输Android上2D图形画面和OpenGL的渲染指令到Linux环境中渲染、传输音频输出数据。Anbox运行Android的机制的实现方式就是通过将Android内必要的输入输出交给外部Linux环境处理，<strong>其实现接口均通过软件实现，这样对于兼容性容易出现问题的OpenGL加速部分尤为友好</strong>。但是也正因为如此，虽然保证了其兼容性，但是<strong>其支持的OpenGL库选择就非常有限</strong>，目前仅支持OpenGL ESv2，性能和稳定性会较为一般。总结其优点就是对于各类操作系统兼容性好，外部有D-Bus和OpenGL环境基本就能正常运行，缺点是通过QEMU pipe传输到外部渲染的方式，其模拟的库只支持OpenGL ESv2，<strong>稳定性一般，性能也比较逊色</strong>。</p>
<center><img src=images/Anbox.png></center>
<center>图1.1 Anbox实现架构图</center>
<p>        (2). Waydroid: 基于Anbox繁衍而来的实现方案，Anbox除了2018年后面稍微更新了下支持Snap和Anbox Cloud外，实现的方案已经多年未进行更新，核心无较大变化，所支持的最新Android系统仍然是2016年11月24日发布的Android 7.1.1。因此Waydroid应运而生，其前身是基于Anbox的中期版本，基于重建脚本、更新的LXC3、Mesa 3D、最新的Android8-11版本、去掉Anbox代码，后续演化后改名Waydroid。Waydroid更加新颖和完善，其优势在于最新的Android、直接通过Mesa 3D驱动显卡、支持Wayland环境；缺点是<strong>只支持Wayland，Mesa 3D作为开源驱动，只支持部分显卡</strong>。</p>
<center><img src=images/Docker_run_Android_with_Mesa3d.png></center>
<center>图1.2 Docker运行Android+Mesa3D架构图</center>
<p>        (3). 其他方案：xDroid、Kydroid、KMRE等第三方闭源方案：xDroid和Kydroid也是类似Anbox的方式，其核心原理仍然是通过容器技术让Android直接运行在Linux上，以Linux原生程序运行，由于其闭源，能够了解的公开信息不多。KMRE从其论文<sup class="footnote-reference"><a href="#1">1</a></sup>来看是类似Waydroid的Mesa3D加速的方案，其性能损耗低，但其一大特色优点在于其对接了现在国产系统常见的Xorg环境下的桌面环境，同时做好支持触摸、优化各类输入输出、传感器等的实现，对比以上开源项目，KMRE不但只实现了基本需求，而且在人性化交互等方面，易用性更高。</p>
<center>表1.2 方案对比</center>
<div class="table-wrapper"><table><thead><tr><th>现有方案</th><th>优点</th><th>缺点</th></tr></thead><tbody>
<tr><td>Anbox</td><td>对各类环境兼容性好、原生运行速度快</td><td>稳定性一般、其所支持的Android版本比较老旧、且Android内只支持OpenGL ESv2,图形化API老旧</td></tr>
<tr><td>waydroid</td><td>最新Android、支持Wayland、直接驱动显卡</td><td>只支持Wayland图形环境、Mesa 3D开源驱动只支持部分显卡，兼容性一般</td></tr>
<tr><td>其他闭源方案</td><td>闭源或商用的项目在用户交互等方面做到了更优，易用性更高</td><td>闭源，能查到公开的信息不多</td></tr>
</tbody></table>
</div>
<h5 id="项目需求和状况"><a class="header" href="#项目需求和状况">项目需求和状况</a></h5>
<p>        (1). 项目现状：</p>
<p>        由于西方加速技术封锁的态势，我们必须迫切的找到相应的替代方案来给国内用户有选择的权利。虽然国产Linux系统目前在飞速发展，但其应用生态紧缺，甚至一个输入法、Linux版的QQ这种基础性应用都Bug百出，使用体验极其糟糕，导致用户普及度始终不能有明显的上涨，用户也不情愿使用国产Linux作为替代系统。</p>
<p>        因此我们需要一些<strong>中期可替代性方案</strong>，Linux上部署安卓这一个想法应运而生，我们可以利用安卓作为一个暂时的方案来承载现在的业务需求例如办公，视频通话等。安卓在2020年的中国移动操作系统市场份额占比达75.98%，相当于每4个使用智能手机的人中就有3名安卓用户。因其用户整体基数大，所以针对安卓应用开发者非常多，面对安卓延申出来的各种业务层出不穷，整个生态对于国产Linux有很大的优势。</p>
<p>        我们可以直接<strong>借助这个优势</strong>，在Linux上运行安卓系统，完成国产Linux跟安卓生态的整合，进而发展国产Linux，并对其产生助力。而同期也比较少同类型的厂商成功实现在GNU/Linux系统中运行着整个Android系统，市场上有空缺的需求等待填补，我们的项目就是要针对这个市场的空缺，成功实现在Linux系统中运行Android系统而不是单纯的模拟，为我们之后国产Linux和国内安卓的生态整合打下坚实的基础。</p>
<p>        (2). 项目需求：</p>
<p>        单纯的Linux<strong>无法</strong>成功运行安卓系统中的各种应用程序，因为安卓在Linux层面上主要增加了ART虚拟机和其Application Framework框架，以及其他细枝末节的修改和优化。我们的项目需求就是需要通过一个安卓<strong>中间层</strong>在Linux上提供安卓运行环境，使安卓当中的应用程序也可以运行在我们所配置的容器当中。但是却不是以模拟器的方式，而是使用当前Linux内核基于<strong>容器技术隔离</strong>来运行安卓系统，不需要大量的软件模拟，又保证了安全性。</p>
<p>        我们选择了这种方案，对各类硬件资源可以被无缝桥接，让性能的效率损失降到比较低的水准，完全可以满足我们日常需求。该方案补充了当前国产Linux应用生态，可以实现国产Linux操作系统应用生态不足的前提下需要快速扩充用户数量的愿景，让国产Linux操作系统走入平民百姓家。</p>
<h2 id="2-参考资料"><a class="header" href="#2-参考资料">2. 参考资料</a></h2>
<ol>
<li>KMRE: An Efficient and Compatible Runtime to Execute Android Application on Linux System, [Date of Conference: 10-13 December 2021]. 10.1109/ICCC54389.2021.9674681</li>
<li>Anbox(所有项目仓库): https://github.com/anbox</li>
<li>安卓AOSP源码获取来自清华大学开源软件镜像站点</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-方案设计"><a class="header" href="#11-方案设计">1.1 方案设计</a></h2>
<center><img src=images/anbox11.png></center>
<center>图1.3 Linux系统运行Android 11的解决方案架构图</center>
<p>        此项目基于原有Anbox方案进行<strong>更新及改进</strong>。我们<strong>改进</strong>使用基于Docker容器技术提供隔离的、与Linux并行运行的安卓环境，此种改进是对原有LXC容器的<strong>更优替代</strong>。但是该改进需要重新适配与调试，需要大量移植与测试的工作量才能保证维持原有稳定性，并更好地利用更多的新特性开发新的功能。除此之外<strong>更新</strong>新的Android 11替代原有Android 7，此过程需要重新移植原有Anbox的各个组件适配新安卓上的HIDL接口。同时需要修改Android底层，经过大量的移植和测试的工作，让其能正常运行在Docker容器中。此项目利用Anbox部分现成的模块，在Linux下上层APP实现与安卓底层对接输入输出和OpenGL ES的渲染等实现。这些设计目标在于使用Docker<strong>替代</strong>原有Anbox使用的较旧的LXC容器技术，并<strong>更新</strong>其Android 7到Android 11，其中技术革新点如下：<br />
        (1). 使用更新的Android 11替代原有老旧的Android 7。<br />
        (2). Android 11中的HAL层使用了HIDL接口这一新的Treble的架构，更加规范及更高的可移植性。<br />
        (3). 使用生态丰富、快速部署、可移植、更加可控的Docker作为底层容器运行环境替代原有集成LXC这一高耦合、低可移植性的实现方式。<br />
        (4). 活用成熟的Anbox部分对多平台高兼容性的实现方式，以应对目前国产系统多种硬件平台和系统环境的问题。</p>
<p>在以上的设计方案下，我们针对其各个部分进行详细设计，详细方案见“<strong>Bitcomet设计文档</strong>”。</p>
<p>        (1). 底层部分：Docker下的安卓11容器设计：</p>
<center><img src=images/design/Anbox11_in_Docker.png></center>
<center>图1.4 Bitcomet实现底层部分设计框架图</center>
<p>        • <strong>高可移植设计</strong>：使用了Docker便集成了Docker相关的优点，Docker相比原有LXC有可移植性、版本控制、回滚、快速部署等优点。同时原有LXC容器与Anbox进行了高度集成，在目前多平台和可移植性考量下，原有Anbox的系统镜像与各个配置选项都不能方便地进行更改，这将会导致我们适配到国产系统中遇到重重困难。<br />
        • <strong>快速迭代更新</strong>：使用Docker提供底层容器运行环境，利用其快速部署的优点，可以使Android 11更加灵活地运行在目标平台。<br />
        • <strong>高效的数据管理</strong>：利用Docker的版本控制和回滚特性，设计恢复出厂设置并清空用户数据的功能，并为以后Android镜像更新时能够快速部署，及时把新版本推送做准备。<br />
        • <strong>较高系统安全性</strong>：把安卓放在密封的容器当中，其外部访问数据都通过QEMU pipe交给上层Anbox前端应用接管，其应用也只有基本的输入输出功能，安全性较高。<br />
        • <strong>极低的运行损耗</strong>：通过容器直接基于现有系统Linux内核运行，并基于Linux内核特性进行容器隔离，这一方案提高了稳定性并降低了运行损耗。<br />
        (2). 中间层：安卓中运行qemud提供QEMU pipe这一高速管道与上层通信：</p>
<center><img src=images/design/Anbox11_IO_Model.png></center>
<center>图1.5 Bitcomet中间层部分设计原理图</center>
<p>         • <strong>成熟的通信方案</strong>：这一通信方案基于成熟的Anbox的通信这一部分的功能实现，其上层Session Manager提供接口，由安卓和Anbox两端利用相应API把接口打开进行通信。其实现方案最早可以追溯到2013年的谷歌Goldfish的Android模拟器实现并且沿用至今，实现了Android与Linux的之间通信的兼容性与健壮性并存的实现方式。<br />
         • <strong>便捷的交互方式</strong>：本方案在安卓与Linux之间的通信方案设计基于QEMU pipe这一高速通道，直接在Android与Linux之间打通一个灵活的通信渠道。本方案不用考虑需要的具体通信实现，直接在安卓HAL层服务和上层Anbox前端应用中打开相应通道进行安卓与Linux对接的数据通信。</p>
<p>        (3). 上层部分：Anbox通过QEMU pipe与底层通信，接收安卓的渲染信息渲染以及音频在上层APP输出，把上层前端APP的输入和状态传递给安卓。</p>
<center><img src=images/design/Anbox11_in_Linux.png></center>
<center>图1.6 Bitcomet上层部分设计原理图</center>
<p>        • <strong>兼容性高</strong>：主要体现在Linux下对Anbox的兼容性，这一方案的设计把安卓需要与Linux交互和获取的数据都通过QEMU pipe传输给Linux处理，上层Anbox前端不依赖硬件。尤其是渲染也是调用系统现有OpenGL库实现，兼容性相比虚拟机来说更高。<br />
        • <strong>易用性高</strong>：通过上层Anbox应用接管底层安卓的输入输出等部分，相当于把安卓应用直接映射给了Linux应用。这一操作安卓应用非常接近使用Linux应用的方式，极大的提高了其易用性，操作起来也更加简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="12-开发计划与进展"><a class="header" href="#12-开发计划与进展">1.2 开发计划与进展</a></h2>
<h3 id="121-开发计划"><a class="header" href="#121-开发计划">1.2.1 开发计划</a></h3>
<h4 id="1-开发计划表"><a class="header" href="#1-开发计划表">(1) 开发计划表</a></h4>
<center>表1.3 开发计划表</center>
<div class="table-wrapper"><table><thead><tr><th>时间节点</th><th>内容</th></tr></thead><tbody>
<tr><td>5月1日-5月31日</td><td>完成安卓11运行在Docker上的核心Demo</td></tr>
<tr><td>6月1日-6月15日</td><td>移植Anbox各个组件到安卓11，初步先移植Anbox的OpenGL和输入部分</td></tr>
<tr><td>6月16日-6月30日</td><td>完成Anbox的通信组件移植</td></tr>
<tr><td>7月1日-7月31日</td><td>完成剩余Anbox组件移植并测试</td></tr>
<tr><td>8月1日-8月15日</td><td>完成最终项目提交、整理项目、准备答辩内容</td></tr>
</tbody></table>
</div>
<h3 id="122-比赛过程中的重要进展"><a class="header" href="#122-比赛过程中的重要进展">1.2.2 比赛过程中的重要进展</a></h3>
<h4 id="1-比赛进展表"><a class="header" href="#1-比赛进展表">(1) 比赛进展表</a></h4>
<center>表1.4 比赛进展表</center>
<div class="table-wrapper"><table><thead><tr><th>时间节点</th><th>负责人</th><th>完成工作</th><th>里程碑</th></tr></thead><tbody>
<tr><td>3月7日-3月22日</td><td>田梓汎</td><td>Android 11内核在docker上运行的实现</td><td></td></tr>
<tr><td>3月23日-4月5日</td><td>张阳彬</td><td>Android 11组件的改造和规范</td><td></td></tr>
<tr><td>4月6日-5月4日</td><td>邹明燊</td><td>完成Android工程文件编写和ASOP编译</td><td></td></tr>
<tr><td>5月5日-5月14日</td><td>田梓汎、张阳彬</td><td>完成Android基础核心功能测试</td><td></td></tr>
<tr><td>5月15日-5月20日</td><td>邹明燊</td><td>完成Android基础核心功能的运行演示</td><td>核心对Docker适配成功完成于5月20日</td></tr>
<tr><td>5月21日-6月5日</td><td>全体队员</td><td>完成项目文档编写和整理</td><td></td></tr>
<tr><td>6月20日-7月10日</td><td>邹明燊、张阳彬</td><td>完成Anbox中间层的通信组件移植</td><td>通信组件成功完成于7月10日并通过基础测试</td></tr>
<tr><td>7月1日-7月15日</td><td>张阳彬、田梓汎</td><td>完成对Anbox的图形及渲染部分的分析文档</td><td></td></tr>
<tr><td>7月10日-7月25日</td><td>邹明燊</td><td>完成Anbox中上层各组件移植</td><td></td></tr>
<tr><td>7月25日-8月2日</td><td>邹明燊</td><td>完成OpenGL部分渲染的初步RPC调用测试</td><td>渲染组件成功完成于8月2日</td></tr>
<tr><td>8月2月-8月15日</td><td>全体成员</td><td>完成项目文档编写和整理</td><td></td></tr>
</tbody></table>
</div>
<h3 id="123-项目测试"><a class="header" href="#123-项目测试">1.2.3 项目测试</a></h3>
<p>        测试思路主要分为三步：第一步检测Bitcomet能否成功启动容器内的Android系统，主要检测其Android系统开启是否正常，是否成功进入系统界面。如果第一步成功，则基础系统运行测试正常，可以保证Bitcomet内Android系统的基本运作，遂进入第二步测试。第二步测试主要针对Bitcomet容器内的Android系统主要功能是否正常，这一步的检测将包括三个部分分别针对Android系统的三大主要功能进行测试,其中包括有系统信息测试，基础功能测试以及基础应用测试。通过第二部测试的目的是检测Bitcomet内启动成功后Android系统的整体功能完善性。最后是第三步的测试。上两部分的测试主要是检测系统的基本运行以及功能，这一部分测试主要检测在Bitcomet中运行Android的效率，会通过统一变量同时对比Bitcomet与市面上成熟的Android模拟器的性能差距，从而展现Bitcomet方案不可忽视的优势。</p>
<h5 id="测试环境"><a class="header" href="#测试环境">测试环境</a></h5>
<p>        本次测试环境硬件参数将统一为下表状态</p>
<center>表1.5 测试环境</center>
<div class="table-wrapper"><table><thead><tr><th>部件</th><th>参数</th></tr></thead><tbody>
<tr><td>系统</td><td>Ubuntu20.04</td></tr>
<tr><td>CPU</td><td>英特尔 i5-8300H@2.3Ghz</td></tr>
<tr><td>内存</td><td>DDR4 16GB (2400MHz)</td></tr>
<tr><td>硬盘</td><td>主硬盘 128G SSD 从硬盘 2TB HDD</td></tr>
<tr><td>显卡</td><td>英伟达 GTX1050&amp;英特尔UHD Graphics 630</td></tr>
</tbody></table>
</div>
<h4 id="1-基础系统运行测试简介以及结果"><a class="header" href="#1-基础系统运行测试简介以及结果">(1) 基础系统运行测试简介以及结果</a></h4>
<p>        这一步主要通过安装环境→加载内核和挂载文件系统→启动Bitcomet并连接容器内的Android来查看其运行情况。<br />
        在根据测试步骤，下载测试镜像，安装环境并加载启动Bitcomet所需模块后，Bitcomet可成功启动，通过相关命令可以进入Android shell模式，QtScrcpy投屏软件可以连接Bitcomet并显示Android界面。系统成功启动，运行正常。</p>
<h4 id="2-系统功能测试简介以及结果"><a class="header" href="#2-系统功能测试简介以及结果">(2) 系统功能测试简介以及结果</a></h4>
<p>这一步测试分为三个部分进行，以下为各个部分的测试简介：<br />
        ① 系统信息测试，主要测试系统设备名。<br />
        ② 基础功能测试，主要测试各基础主要功能例如默认语言，WIFI等。<br />
        ③ 基础应用测试，主要测试系统默认应用运行情况以及第三方应用运行情况。</p>
<p>        测试结果主要如下：</p>
<center>表1.6 系统功能测试结果</center>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">成功</th><th>失败</th></tr></thead><tbody>
<tr><td style="text-align: left">系统信息和基础功能</td><td>输入(远程)</td></tr>
<tr><td style="text-align: left">通讯录、闹铃、浏览器等基础应用以及第三方应用</td><td>音频</td></tr>
<tr><td style="text-align: left">图形渲染(GPU软件渲染)</td><td>蓝牙WIFI</td></tr>
</tbody></table>
</div>
<h4 id="3-性能对比测试简介以及结果"><a class="header" href="#3-性能对比测试简介以及结果">(3) 性能对比测试简介以及结果</a></h4>
<p>        性能对比测试环节：采用Genymotion模拟器来作为对比对象，同时会进行CPU性能对比测试以及内存开销对比测试。CPU性能测试主要使用Android平台主流的基础测试应用Geekbench以及安兔兔AI。Geekbench主要针对于CPU的浮点运算和整数运算部分给出性能量化指标，而安兔兔AI则主要针对CPU中的AI运算部分给出性能量化指标。内存开销测试我们选择各方案仅运行一个Android系统，查看整体内存占用，测出内存开销。</p>
<p>        CPU测试部分：在Geekbench测试中，Bitcomet成绩为单核4437分，多核14398分，Genymotion模拟器对照组单核4251分，多核12626分。相比于Genymotion模拟器，Bitcomet单核领先约4.3%，多核领先约14%。性能提升相当于当今移动端旗舰级芯片高通骁龙865和高通骁龙888的性能差距(性能对比数据来自www.socpk.com) ，也就是芯片厂商用一年时间更迭优化出的性能。而在安兔兔AI测试中，Genymotion模拟器得分为48231，Bitcomet得分为58840，Bitcomet更是取得了约22%的显著优势。</p>
<p>        内存测试部分：分别测试仅打开Genymotion启动Android系统和仅打开Bitcomet启动Android系统，不运行任何其他应用程序，记录其内存的开销情况，Genymotion模拟器占用整个系统约3.8GiB的内存空间，而Bitcomet占用仅为2.8GiB。占用内存大小仅为Genymotion模拟器的3/4。</p>
<h4 id="4-总结"><a class="header" href="#4-总结">(4) 总结</a></h4>
<p>        在系统运行测试，系统功能测试部分，Bitcomet已成功在Ubuntu20.04下运行。除部分功能未完善外，通讯录，闹铃，浏览器等基础应用及系统基础信息均可正常使用与显示，也可根据需求安装第三方软件。</p>
<p>        通过Bitcomet与Genymotion在CPU性能测试与内存开销测试的情况对比可知，Bitcomet无论是在CPU利用效率还是内存开销上都优于Genymotion。在虚拟化技术成熟的今天，14%性能提升意味着每一百台计算机平台可以少买12台计算机。每百万可以省下12万，又或是在能耗方面做出改进，我们可以限制机器的运行功耗，降至模拟器同样的性能，但是省下更多的电。与此同时，Bitcomet还只是一个“半成品”，其潜力之大可想而知。</p>
<p>        演示视频链接: https://pan.baidu.com/s/1FLokWbiU3WNq_i5bhbj7sA?pwd=ew23 提取码: ew23</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="13-项目总结与目录说明"><a class="header" href="#13-项目总结与目录说明">1.3 项目总结与目录说明</a></h2>
<h3 id="131-分工和协作"><a class="header" href="#131-分工和协作">1.3.1 分工和协作</a></h3>
<center>表1.7 分工与协作</center>
<div class="table-wrapper"><table><thead><tr><th>项目</th><th>负责</th></tr></thead><tbody>
<tr><td>Docker运行Android 11基础核心的实现</td><td>田梓汎和张阳彬</td></tr>
<tr><td>Androidlunch工程和项目管理</td><td>邹明燊</td></tr>
<tr><td>Android基础核心功能测试</td><td>田梓汎</td></tr>
<tr><td>Andox基础组件移植</td><td>邹明燊</td></tr>
<tr><td>图形渲染输入输出测试</td><td>张阳彬</td></tr>
</tbody></table>
</div>
<h3 id="132-提交仓库目录和文件描述"><a class="header" href="#132-提交仓库目录和文件描述">1.3.2 提交仓库目录和文件描述</a></h3>
<center>表1.8 仓库目录与文件描述</center>
<div class="table-wrapper"><table><thead><tr><th>仓库</th><th>说明</th></tr></thead><tbody>
<tr><td>Proj156-bitcomet</td><td>安卓manifests存放位置，项目说明</td></tr>
<tr><td>Proj156_device_bitcomet</td><td>安卓lunch工程，源码device/bitcomet目录</td></tr>
<tr><td>Proj156_frameworks_native</td><td>修改的android/frameworks/native目录</td></tr>
<tr><td>Proj156_frameworks_base</td><td>修改的android/frameworks/base目录</td></tr>
<tr><td>Proj156_system_bpf</td><td>修改的android/system/bpf目录</td></tr>
<tr><td>Proj156_external_selinux</td><td>修改的android/external/selinux目录</td></tr>
<tr><td>Proj156_system_netd</td><td>修改的android/system/netd目录</td></tr>
<tr><td>Proj156_system_libhwbinder</td><td>修改的android/system/libhwbinder目录</td></tr>
<tr><td>Proj156_system_core</td><td>修改的android/system/core目录</td></tr>
<tr><td>Proj156_vendor_bitcomet</td><td>增加的android/vendor/bitcomet目录放一些工程额外加入的包</td></tr>
<tr><td>Proj156_hardware_interfaces</td><td>修改的android/hardware/interfaces目录</td></tr>
<tr><td>Proj156_hardware_libhardware</td><td>修改的android/hardware/libhardware目录</td></tr>
<tr><td>Proj156_system_linkerconfig</td><td>修改的android/system/linkerconfig目录</td></tr>
<tr><td>Proj156_vendor_anbox</td><td>修改的android/vendor/anbox目录</td></tr>
</tbody></table>
</div>
<p>        注：由于安卓项目太多，所有项目需要通过repo工具组织管理起来，不需要单独拉取覆盖。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-bitcomet设计开发文档"><a class="header" href="#2-bitcomet设计开发文档">2. Bitcomet设计开发文档</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>        Bitcomet是一个基于原有Anbox向Android 11移植实现一种基于Linux系统运行Android 11的解决方案，以下均<strong>称呼</strong>为<strong>Bitcomet</strong>。其主要与原有Anbox的<strong>改进点</strong>在于Android所运行的环境由LXC实现变为更加主流的Docker实现，原有在Anbox不再更新的Android 7更新为Android 11。此外，为了让Android 11能在Docker中运行，本项目针对其<strong>SDcard的文件系统挂载机制</strong>、<strong>SELinux安全机制</strong>等进行了相应的移植与优化。为了让Android能在Linux上满足正常使用以及调用GPU进行渲染的需求，本项目<strong>参考并移植</strong>原有Anbox以及Google安卓模拟器中的相关实现，在移植并搭建起Anbox的跨系统环境通信基础上，使相应的<strong>Android各类接口打通到外部Linux</strong>，其中最基础的包括<u>图形渲染、图形输出、键鼠输入</u>这三个部分的接口。</p>
<p>        本项目主要还是基于Anbox来参考实现，旨在完成以下四个目标：</p>
<ul>
<li><strong>目标1</strong>：完成Android11的<strong>SDcard的文件系统挂载机制</strong>、<strong>SELinux安全机制、非特权模式下运行处理</strong>对应在Docker容器环境内的处理。</li>
<li><strong>目标2</strong>：配置安卓项目工程，实现并配置好各个需要的系统模块和AIDL、HIDL、HAL模块，搭建初步调试与测试的Demo1版本，使用adb配合Scrcpy对内部Android远程访问以方便有个初步预期，并且方便本项目有个初步测试的环境。</li>
<li><strong>目标3</strong>：完成Anbox通信部分实现向Android 11的移植，使Android能与Anbox外部实现跨系统环境通信。</li>
<li><strong>目标4</strong>：完成Anbox安卓其余部分的各个模块移植，使Android的三个基础部分OpenGL、HWC图形输出、键鼠输入能正常工作。</li>
</ul>
<p>        目前，我们的赛题完成度如下：</p>
<center>表2.1 赛题完成度</center>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">目标编号</th><th style="text-align: center">基本完成情况</th><th>额外说明</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">基本完成（≈85%）</td><td>1. 与SDcard以及SELinux组件相关的Android 11的基本功能、SDcard文件管理、安装第三方软件、闹铃与联系人等基础应用测试均通过。<br/>2. 非特权模式仅做了部分处理，未进行测试。</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">基本完成（≈90%）</td><td>1. 搭建好相关容器，进行相关基础测试并通过。<br/>2. 目前网络部分由于在Docker特权模式下运行，可能会有Bug。</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">初步完成（≈80%）</td><td>1. 完成跨系统环境通信，安卓中Anbox的相关模块可以使用QEMU_PIPE（实际容器中是没有QEMU设备，而是使用了Unix Domain Socket代替，但其通信的相关通道仍然叫做QEMU PIPE）进行通信或者使用Anbox实现的RPC调用。<br/>2. Anbox的OpenGL ES的emulation库实现初步测试能通过该通信创建QEMU_PIPE连接，实现RPC调用获取到主机侧支持的OpenGL信息。<br/>3. 由于各个部分的模块暂未完全移植好，还需要全部移植才能测试所有功能。</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">初步测试（≈60%）</td><td>1. 已经把相应的Anbox的各个模块的移植到Android中，其中GPS与Audio模块使用了谷歌给Goldfish的实现。<br/>2.OpenGL ES实现和HWC实现在Android 11下无法测试，由于Android 11的相关变动，导致输出画面调用了Gralloc的PostFB去输出，而在Anbox中是未做这部分RPC调用的，输出画面失败。<br/>3.把相关方案在Android 10上进行测试，测试可以输出画面，但卡在安卓Launcher第一屏画面。</td></tr>
<tr><td style="text-align: center">总计</td><td style="text-align: center">≈80%</td><td>1. 本项目自立项以来经历了三个月的时间进行研究与开发，实现方案的过程中遇到困难重重，主要遇到的阻力在系统庞大、相关实现的资料缺失方面。<br />2. 目前还有部分的工作需要测试和完成。由于Android 11在图形和音频方面变动较大，即使目前进行了相关模块的移植，但是还需要在图形模块、音频模块、输入模块方面进行各类测试和调试工作。<br />3. 项目将放在Github进行公开，把截至目前学习的成果公开，希望后续有更多的参与者参与进来进行开发完善。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="21-bitcomet方案设计与分析"><a class="header" href="#21-bitcomet方案设计与分析">2.1 Bitcomet方案设计与分析</a></h2>
<h3 id="211-为什么选择使用容器与anbox"><a class="header" href="#211-为什么选择使用容器与anbox">2.1.1 为什么选择使用容器与Anbox</a></h3>
<p>        本Bitcomet方案旨在于实现在Linux中运行Android 11的解决方案。在这个方案中会遇到一些问题，如<strong>下图2.1</strong>是Android系统框架图、<strong>图2.2 GNU/Linux系统架构图</strong>，这两张图清晰明了地展现了Android与Linux环境的差异：</p>
<p>        Android与Linux除了内核相似外是<strong>完全不一样的系统环境</strong>，尤其体现在系统libc库、应用的运行方式、输入输出设备的管理方式、图像合成方式、OpenGL接口、网络管理组件等方面。这些组件绝大部分将会与Linux<strong>冲突</strong>，导致Linux运行异常或者Android无法直接运行，同时Android的APP也无法在Linux内直接运行。</p>
<center><img src=images/design/ape_fwk_all.png></center>
<center>图2.1 Android 系统架构图（图源自https://source.android.google.cn/devices/architecture?hl=zh-cn）</center>
<center><img src=images/design/Linux架构.png></center>
<center>图2.2 GNU/Linux系统架构图（图源自https://zhuanlan.zhihu.com/p/43029021）</center>
<p>        <strong>旧方案：<strong>在过去面向用户的</strong>常见方案</strong>中，常用虚拟机来实现这个方案。利用<strong>虚拟化</strong>功能运行一个Android虚拟机，虚拟机内虚拟或者模拟了电脑绝大部分的硬件，这样既能解决两者接口不同，又能简单实现Android在其他系统上的运行。但是随之而来也有许多<strong>缺点</strong>：虚拟化需要硬件支持、虚拟化对CPU性能有一小部分损耗、虚拟机本身运行一个全新的系统也需要更多硬件资源、在虚拟机与主机系统间切换也无法很好地利用上常见PC系统的多任务多窗口特性。</p>
<p>        相比起虚拟机的实现方法，容器基于Linux内核的命名空间隔离，也能提供一个<strong>隔离</strong>了Android系统与Linux之间的磁盘、内存等的运行环境。同时容器<strong>不需要虚拟化，不需要跑起整个Linux内核</strong>，相对应的对硬件资源要求较少，这三个方面看起来有优势。但是容器又出现不一样的问题：相比一般Android模拟器使用的虚拟机，容器又缺少输入输出接口、3D加速与显示输出。</p>
<center><img src=images/design/virtualbox_run_android.png></center>
<center>图2.3 虚拟机运行Android x86架构图</center>
<p>        <strong>Bitcomet方案：<strong>使用容器提供Android运行的环境来实现，其</strong>原因</strong>如下：该方案可能会在国产化平台上运行，面向不同的硬件环境下不一定支持虚拟化；对硬件资源需求较少；针对容器缺少的输入输出接口以及3D加速与显示输出，谷歌为解决这些问题在安卓模拟器AVD上设计了一套新的方案。另外Anbox在一部分输入输出及3D加速方面正好是<strong>复用</strong>了谷歌的安卓模拟器的方案，利用了其提供的QEMU_PIPE、emugl、传感器模拟、音频输出等方面提供的实现。</p>
<p>        以上是复用了谷歌的实现，但是前端不一样，安卓模拟器的前端是方便谷歌模拟器实现的，而Anbox是需要利用上PC系统的<strong>多任务多窗口</strong>、方便对接输入输出和控制等的特性。因此Anbox这部分针对谷歌的方案进行了<strong>参考重写</strong>，把Android中各个不同APP的窗口映射到不同的模拟Surface上。但相应的代价是，由于谷歌3D渲染部分是通过把其指令传输出来交给<strong>外部</strong>OpenGL渲染，这样性能利用是真机渲染的70%-90%（数据来自参考文献[1]），有一定的损耗。</p>
<center><img src=images/design/Docker_run_android.png></center>
<center>图2.4 Docker运行Android架构图</center>
<h3 id="212-总结"><a class="header" href="#212-总结">2.1.2 总结</a></h3>
<p>        本项目是这类移植方式中其中一种兼容性较好的方案，其OpenGL ES渲染是通过<strong>传输</strong>给Anbox并由emugl转换后交给Linux<strong>用户空间</strong>的OpenGL库实现，OpenGL的对应版本的API是<strong>统一</strong>的，而Linux平台一般都有GPU驱动+相应库，即使没有也会使用软件OpenGL库，所以这种方案理论上是能<strong>适应</strong>更多GPU平台的。</p>
<p>        总的来说这类移植方式主要都有一类<strong>共通点</strong>，为了把输入输出、显示渲染等<strong>接口打通到对应平台</strong>，而不断衍生的技术都有新的优化与改进，尽量减少通信期间数据的拷贝，降低损耗，提高硬件利用率。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="22-bitcomet方案设计"><a class="header" href="#22-bitcomet方案设计">2.2 Bitcomet方案设计</a></h2>
<p>        本方案是在Ubuntu 20.04(下图GNU/Linux部分)，部署好Docker环境。</p>
<p>        <strong>Bitcomet底层</strong>：其中Android 11的Docker镜像以及Anbox相关组件，均为本方案的实现，经过编译打包并导入Docker的密封环境中。</p>
<p>        <strong>Bitcomet中间层</strong>：在Android 11中，Anbox的后端及相关模块通过桌面下的Anbox前端产生的QEMU pipe进行通信。</p>
<p>        <strong>Bitcomet上层</strong>：Android在容器内缺少图形输出、渲染、音频和键盘设备操作的输入输出功能，其相关功能依赖Anbox的Gralloc、HWC、Audio等相关模块实现。这些模块在QEMU pipe通信的基础上，搭建起对外Linux沟通桥梁，为外部Linux对接内部Android的输入输出、图形输出渲染等功能。外部Anbox针对相关功能实现调用Linux系统库，实现了输入输出渲染等功能。</p>
<p>        如图2.5是针对Bitcomet各个部分的详细设计：</p>
<center><img src=images/design/Anbox11_Flow_Design.png></center>
<center>图2.5 Bitcomet方案详细架构图</center>
<p>        其中各个部分有相关的实现文档，具体见当前项目下<strong>Docs目录</strong>内其他文档。</p>
<h3 id="221-docker下的安卓11容器设计"><a class="header" href="#221-docker下的安卓11容器设计">2.2.1 Docker下的安卓11容器设计</a></h3>
<center><img src=images/design/Anbox11_in_Docker.png></center>
<center>图2.6 Bitcomet实现底层部分设计框架图</center>
<h4 id="1-主要工作"><a class="header" href="#1-主要工作">(1) 主要工作</a></h4>
<p>        在Bitcomet方案底层部分中，使用Docker容器提供Android运行的环境。当然仅仅提供一个环境还不行，Android 11需要依赖Binder、SELinux、SDcardFS、Ashmem等环境的支持。具体的工作如下：</p>
<p>① <strong>内核定制</strong>：Binder与Ashmem需要针对内核定制，目前较新的Linux 5.x已经自带BinderFS和Ashmem模块的支持，旧的内核需要使用Anbox提供的Binder或Ashmem模块。</p>
<p>② <strong>SELinux安全机制处理</strong>：本方案选择了对其相关方法进行屏蔽处理，即使实际测试及Docker文档中都反应了Docker下是可以实现这个支持的，但我们仍然选择了屏蔽，其原因如下：</p>
<p>        第一，Docker外是针对指定配置文件的SELinux安全配置，而Android内的还需要单独配置并需要一部分特权。</p>
<p>        第二，不同平台的Linux内核不一定提供并使用了SELinux安全模块，遇上没有此模块的平台均无法运行。</p>
<p>        第三，使用SELinux后，Docker官方提到可能会对性能有一定的损失。</p>
<p>③ <strong>文件系统挂载处理</strong>：SDcardFS部分是安卓8以后提供的模块，可以让Android接管对SDcardFS下的目录文件的访问权限控制。我们选择了使用FUSE来实现挂载SDcard的虚拟文件系统，FUSE是较旧版本的Android采用的一种方式，其实现主要在用户空间，能提供几乎与SDcardFS相同的功能。但FUSE挂载SDcard的实现也有缺点，其速度比SDcardFS的实现慢，我们仍然选择FUSE方案的原因如下：</p>
<p>        第一， SDcardFS的实现依赖Linux内核实现，不同Linux内核对其支持不一样。</p>
<p>        第二， 由于SDcardFS在内核实现，挂载它也需要一定的特权。</p>
<h4 id="2-bitcomet底层部分特点"><a class="header" href="#2-bitcomet底层部分特点">(2) Bitcomet底层部分特点</a></h4>
<p>Docker下的安卓11容器设计：<br />
• <strong>高可移植设计</strong>：使用了Docker便集成了Docker相关的优点，Docker相比原有LXC有可移植性、版本控制、回滚、快速部署等优点。同时原有LXC容器与Anbox进行了高度集成，在目前多平台和可移植性考量下，原有Anbox的系统镜像与各个配置选项都不能方便地进行更改，这将会导致我们适配到国产系统中遇到重重困难。<br />
• <strong>快速迭代更新</strong>：使用Docker提供底层容器运行环境，利用其快速部署的优点，可以使Android 11更加灵活地运行在目标平台。<br />
• <strong>高效的数据管理</strong>：利用Docker的版本控制和回滚特性，设计恢复出厂设置并清空用户数据的功能，并为以后Android镜像更新时能够快速部署，及时把新版本推送。<br />
• <strong>较高系统安全性</strong>：把安卓放在密封的容器当中，其外部访问数据都通过QEMU pipe交给上层Anbox前端应用接管，其应用也只有基本的输入输出功能，安全性较高。<br />
• <strong>极低的运行损耗</strong>：通过容器直接基于现有系统Linux内核运行，并基于Linux内核特性进行容器隔离，这一方案提高了稳定性并降低了运行损耗。</p>
<h3 id="222-安卓与上层anbox通信设计"><a class="header" href="#222-安卓与上层anbox通信设计">2.2.2 安卓与上层Anbox通信设计</a></h3>
<center><img src=images/design/Anbox11_IO_Model.png></center>
<center>图2.7 Bitcomet中间层部分设计原理图</center>
<h4 id="1-主要工作-1"><a class="header" href="#1-主要工作-1">(1) 主要工作</a></h4>
<p>        在Bitcomet中间层中，我们复用了Anbox这一实现，把其相关实现移植到Android11，并实现其上面的各种功能。我们的主要工作如下：</p>
<p>① <strong>通信实现</strong>：把Anbox基于QEMU pipe和qemud的实现移植到Android11，这两个实现的本质均为通过QEMU pipe实现，但由于容器内没有实质上的QEMU pipe设备，因此Anbox魔改了一下使用Unix Domain Socket实现，这种实现从原理上说与QEMU pipe的区别在于：第一，QEMU pipe设备是通过QEMU的相关模拟实现的，其模拟的设备支持DMA，理论上比Unix Domain Socket这一软件实现更有效率；第二，Anbox这里相关实现的名字还是叫做QEMU pipe，而QEMU pipe本身也有tcp socket相关的实现。</p>
<p>② <strong>设备映射</strong>：在Docker中映射外部Anbox的Session Manager创建的Socket监听到容器内的/dev对应设备，以便容器内的QEMUd或者QEMU pipe相关实现进行调用。</p>
<p>③ <strong>Anbox通信模块移植</strong>：容器内Anbox为这些实现封装成了叫做HOST_CONNECTION的方法，容器外Anbox基于谷歌的ProtoBuf实现一种通信模型，其中包括OpenGL ES、HWC、模拟的Surface、Anbox Proxy等组件的RPC调用，以便内部Anbox通过这些封装的方法直接调用，我们也针对这些方法进行了移植和部分测试。</p>
<h4 id="2-bitcomet中间层部分特点"><a class="header" href="#2-bitcomet中间层部分特点">(2) Bitcomet中间层部分特点</a></h4>
<p>安卓中运行qemud提供QEMU pipe这一高速管道与上层通信：<br />
• <strong>成熟的通信方案</strong>：这一通信方案基于成熟的Anbox的通信这一部分的功能实现，其上层Session Manager提供接口，由安卓和Anbox两端利用相应API把接口打开进行通信。其实现方案最早可以追溯到2013年的谷歌Goldfish的Android模拟器实现并且沿用至今，实现了Android与Linux的之间通信的兼容性与健壮性并存的实现方式。<br />
• <strong>便捷的交互方式</strong>：本方案在安卓与Linux之间的通信方案设计基于QEMU pipe这一高速通道，直接在Android与Linux之间打通一个灵活的通信渠道。本方案不用考虑需要的具体通信实现，直接在安卓HAL层服务和上层Anbox前端应用中打开相应通道进行安卓与Linux对接的数据通信。</p>
<h3 id="223-上层anbox的opengl-es渲染以及输入输出设计"><a class="header" href="#223-上层anbox的opengl-es渲染以及输入输出设计">2.2.3 上层Anbox的OpenGL ES渲染以及输入输出设计</a></h3>
<center><img src=images/design/Anbox11_in_Linux.png></center>
<center>图2.8 Bitcomet上层部分设计原理图</center>
<h4 id="1-主要工作-2"><a class="header" href="#1-主要工作-2">(1) 主要工作</a></h4>
<p>        在Bitcomet的上层中，我们也复用Anbox的实现，把其相关部分移植到Android11和Ubuntu 20.04上。Android中对接外部Linux主要在图形输出、渲染、输入输出部分缺失，这些部分需要靠Anbox在中间通信层的部分实现之上，建立各个部分的连接，打通到外部Linux上。我们的主要工作如下：</p>
<p>① <strong>HAL层模块移植</strong>：这一部分主要工作在Android中HAL层的移植以及测试，我们经过在Android工程中对AIDL与HIDL对应HWC与Gralloc部分的模块进行配置，Gralloc的HAL层复用最新Android 11中对安卓模拟器的AVD实现。我们复用Android 11的这一部分主要原因在于其安卓模拟器的实现与Anbox的实现是一样的，都是软件实现的调用ashmem申请图形缓冲区。</p>
<p>② <strong>图形输出部分移植</strong>：从Android的HAL层中Gralloc与HWC模块开始，图形输出部分的核心模块是HWC模块，它负责被SurfaceFlinger调用进行图层合成输出到显示设备，而这里我们选择在Anbox的实现上进行移植修复。该实现主要测试点在于图形HWC，HWC中的发送图层部分开始，通过Anbox的RPC调用，发送图层到外部Anbox的Surface上，需要测试相关图层测试数据是否能到达外部Anbox上合成输出。</p>
<p>③ <strong>输入输出部分移植</strong>：在输入部分，Anbox的Session Manager注册了多个Event设备以及audio传输设备，我们需要把这些设备在Docher中映射到/dev下，以便在Android中调用。其中音频部分也复用Android11针对模拟器部分的audio HAL实现，原因在于Anbox这些部分的实现也是复用Android模拟器的实现，其原理是把音频PCM数据通过Anbox的RPC调用方法发送到外部Anbox进行解码播放。</p>
<p>④ <strong>OpenGL ES部分移植</strong>：Anbox的OpenGL库主要在Android的 /system/lib64/egl 目录下安装了三个动态库，分别为libEGL_emulation.so、libGLESv1_CM_emulation.so和libGLESv2_emulation.so。Anbox在其中提供虚拟的硬件厂商配置，为Android提供OpenGL ES渲染库。但Anbox实际渲染工作并不是上述三个库文件，这三个库文件作用为采集Android中APP渲染的OpenGL ES指令，并通过高速传输通道qemu-pipe传输将指令传至宿主机Anbox进程中，实际渲染工作由宿主机执行。这部分主要也是移植好Anbox这几个库，检验该三个库与上层Anbox的通信，这部分库也是复用谷歌Android的安卓模拟器AVD实现，主要测试工作在于做相关指令的通信以及实际渲染测试。</p>
<h4 id="2-bitcomet上层部分特点"><a class="header" href="#2-bitcomet上层部分特点">(2) Bitcomet上层部分特点</a></h4>
<p>Anbox通过QEMU pipe与底层通信，接收安卓的渲染信息渲染以及音频在上层APP输出，把上层前端APP的输入和状态传递给安卓：<br />
• <strong>兼容性高</strong>：主要体现在Linux下对Anbox的兼容性，这一方案的设计把安卓需要与Linux交互和获取的数据都通过QEMU pipe传输给Linux处理，上层Anbox前端不依赖硬件。尤其是渲染也是调用系统现有OpenGL库实现，兼容性相比虚拟机来说更高。<br />
• <strong>易用性高</strong>：通过上层Anbox应用接管底层安卓的输入输出等部分，相当于把安卓应用直接映射给了Linux应用。这一操作安卓应用非常接近使用Linux应用的方式，极大的提高了其易用性，操作起来也更加简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="31-安卓图形架构中的anbox的hal模块"><a class="header" href="#31-安卓图形架构中的anbox的hal模块">3.1 安卓图形架构中的Anbox的HAL模块</a></h2>
<p>        在安卓官方文档当中，安卓的系统架构被分为五层架构，其五层架构分别为</p>
<center>表3.1 安卓系统结构</center>
<div class="table-wrapper"><table><thead><tr><th>架构</th><th>主要负责的内容</th></tr></thead><tbody>
<tr><td>应用框架 APP FRAME</td><td>应用框架主要为开发者使用，开发者API提供了很多映射至底层的HAL接口，提供实现驱动程序的相关信息</td></tr>
<tr><td>Binder IPC</td><td>主要负责进程间的通讯，不仅仅是顶层进程之间的交互，更重要的是支持顶层进程和安卓系统服务间甚至是HAL的交互</td></tr>
<tr><td>系统服务</td><td>安卓把各种各样的系统服务包装为各种模块化组件，可以方便后续升级。其中包括有DNS解析模块，媒体模块等。</td></tr>
<tr><td>硬件抽象层HAL</td><td>HAL可以定义一个接口给硬件供应商实现，主要用于实现系统服务和底层驱动程序的通讯和运作。其被封装成一个模块被安卓系统随时调用</td></tr>
<tr><td>Linux内核</td><td>Android使用的linux内核与一般的内核不同，如：必须支持Binder、包含一些特殊功能（内存守护）</td></tr>
</tbody></table>
</div>
<h3 id="311-安卓图形部分架构以及anbox图形模块"><a class="header" href="#311-安卓图形部分架构以及anbox图形模块">3.1.1 安卓图形部分架构以及Anbox图形模块</a></h3>
<p>        其中在Anbox的图形模块中，最主要关心的就是HAL层以及LINUX KERNEL。因为本项目中安卓是运行在容器内的，安卓不能像原生一样顺利地让HAL层直接调用其LINUX KERNEL内的驱动和所需资源，而是要跟容器外部正在运行的LINUX环境对接。在本项目中的这一目标就是努力<strong>让容器内的安卓与容器外本不兼容的LINUX环境对接</strong>，成功把图形化渲染的工作交给LINUX环境当中，实现渲染效率比软件模拟成倍提升的效果。</p>
<p>        在安卓主要的图形模块当中，所有的渲染信息流大致如图3.1所示。</p>
<center><img src=images/hal-display/display流程图.png></center>
<center>图3.1 安卓显示相关实现流程图</center>
<h4 id="1-hal层"><a class="header" href="#1-hal层">(1) HAL层</a></h4>
<p>        在本文档中，主要聚焦于HAL层anbox的实现。在安卓系统中HAL层包括两个组件，HWC(Hardware Composer)与Gralloc。</p>
<h5 id="hwchardware-composer模块"><a class="header" href="#hwchardware-composer模块">HWC(Hardware Composer)模块</a></h5>
<h6 id="①-初步介绍"><a class="header" href="#①-初步介绍">① 初步介绍</a></h6>
<p>        无论开发者使用什么渲染API，一切的内容都将会渲染到<strong>surface</strong>上，surface可以被理解为是一个生产缓冲区，整一个被渲染的surface队列都会被<strong>surfaceflinger</strong>所消耗而准备合成到屏幕上。</p>
<center><img src=images/hal-display/layer合成.png></center>
<center>图3.2 安卓显示流水线</center>
<p>        <strong>合成是一种将缓冲区队列内所有元素有规律有层级的覆盖为一块画面的操作。</strong> 在安卓系统中，surface队列内的元素通常是大小不一且杂乱的，因为来自多个不同源的缓冲区，例如有些是出于顶部的状态栏，有些是出于底部的导航栏，而中间的应用内容也是一层缓冲区，直接送出来的画面完全不是屏幕在显示的画面。怎么解决这个问题？在安卓中选择了效率最高的方式来处理合成问题——将三个缓冲区全部传送到显示硬件，并指示它从不同的缓冲区读取屏幕不同部分的数据。这个操作的承担者就是硬件混合渲染器HAL层。</p>
<p>        合成到屏幕这一步就需要调用我们的HAL层中的HWC了。HWC主要跟屏幕显示组件通讯，获得屏幕相应的参数，计算出最常用的四个不同的部分——状态栏、系统栏、应用以及壁纸/背景所覆盖的画面，再接受<code>surfaceflinger</code>需要合成的队列所拥有的内容，把这些内容分别合成到状态栏、系统栏、应用以及壁纸/背景所覆盖的画面后再与屏幕沟通，最终显示在真正现实的手机屏幕上。</p>
<p>        当然，HWC也会负责虚拟屏幕合成，同时会向硬件设备注册三个回调，以便应对这些事件的发生：屏幕热插拔，刷新和VSync信号。</p>
<p>        在Anbox当中，HWC还有一个比较重要的功能，它可以把单个安卓里面的应用程序映射到桌面环境的单个窗口中，因为在桌面环境下我们不需要再像现实中让HWC把所有内容合成到一块屏幕上。Anbox会通过其<code>hwcomposer</code>实现告诉<code>SurfaceFlinger</code>为每个应用程序获取一个层，并将其与从<code>Android WindowManager</code>收到的额外信息结合起来，将单个层映射到应用程序。</p>
<center><img src=images/hal-display/layer合成.png></center>
<center>图3.3 HWC显示合成概念图1</center>
<center><img src=images/hal-display/layer合成.jpg></center>
<center>图3.4 HWC显示合成概念图2</center>
<h6 id="②-hwc模块重要实现"><a class="header" href="#②-hwc模块重要实现">② HWC模块重要实现</a></h6>
<p><strong>安卓中HWC部分的实现</strong></p>
<p>        首先<code>surfaceflinger</code>创建<code>HWComposer</code>。</p>
<pre><code class="language-c">//节选自main_surfaceflinger.cpp
void SurfaceFlinger::init() {
     // Initialize the H/W composer object.  There may or may not be an
    // actual hardware composer underneath.
    mHwc = new HWComposer(this,
            *static_cast&lt;HWComposer::EventHandler *&gt;(this));//调用构造函数
 }
</code></pre>
<p>        <code>HWComposer</code>构造函数。</p>
<pre><code class="language-c">//节选自DisplayHardware/HWComposer.cpp
HWComposer::HWComposer(const sp&lt;SurfaceFlinger&gt;&amp; flinger)
    : mFlinger(flinger),
      mAdapter(),
      mHwcDevice(),
      mDisplayData(2),
      mFreeDisplaySlots(),
      mHwcDisplaySlots(),
      mCBContext(),
      mEventHandler(nullptr),
      mVSyncCounts(),
      mRemainingHwcVirtualDisplays(0)
{
    for (size_t i=0 ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) {
        mLastHwVSync[i] = 0;
        mVSyncCounts[i] = 0;
    }
    loadHwcModule(); //调用HWC模块
}
</code></pre>
<p>        <code>HWComposer</code>构造函数一般使用<code>loadHwcModule</code>方法加载来<code>HWComposer</code>模块。</p>
<pre><code class="language-c">//节选自DisplayHardware/HWComposer.cpp
void HWComposer::loadHwcModule()
{
	ALOGV(&quot;loadHwcModule&quot;);
    // 其定义在hardware.h中，表示一个硬件模块
    hw_module_t const* module;
    // 加载硬件厂商提供的hwcomposer模块，HWC_HARDWARE_MODULE_ID定义在hwcomposer_defs.h中，表示&quot;hwcomposer&quot;
    if (hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;module) != 0) {
        ALOGE(&quot;%s module not found, aborting&quot;, HWC_HARDWARE_MODULE_ID);
        abort();
    }

    hw_device_t* device = nullptr;
    // 通过硬件厂商提供的open函数打开一个&quot;composer&quot;硬件设备，HWC_HARDWARE_COMPOSER也定义在hwcomposer_defs.h中，表示&quot;composer&quot;
    int error = module-&gt;methods-&gt;open(module, HWC_HARDWARE_COMPOSER, &amp;device); 
    if (error != 0) {
        ALOGE(&quot;Failed to open HWC device (%s), aborting&quot;, strerror(-error));
        abort();
    }

    uint32_t majorVersion = (device-&gt;version &gt;&gt; 24) &amp; 0xF;
    // mHwcDevice是HWC2.h中定义的HWC2::Device，所有与HWC的交互都通过mHwcDevice
    if (majorVersion == 2) { // HWC2，hwc2_device_t是hwcomposer2.h中的结构体
        mHwcDevice = std::make_unique&lt;HWC2::Device&gt;(
                reinterpret_cast&lt;hwc2_device_t*&gt;(device));
    } else { // 设备是基于HWC1，这里用HWC2去适配，Android7.0及以前默认都是HWC1，hwc_composer_device_1_t是hwcomposer.h中的结构体
        mAdapter = std::make_unique&lt;HWC2On1Adapter&gt;(
                reinterpret_cast&lt;hwc_composer_device_1_t*&gt;(device));
        uint8_t minorVersion = mAdapter-&gt;getHwc1MinorVersion();
        if (minorVersion &lt; 1) {
            ALOGE(&quot;Cannot adapt to HWC version %d.%d&quot;,
                    static_cast&lt;int32_t&gt;((minorVersion &gt;&gt; 8) &amp; 0xF),
                    static_cast&lt;int32_t&gt;(minorVersion &amp; 0xF));
            abort();
        }
        mHwcDevice = std::make_unique&lt;HWC2::Device&gt;(
                static_cast&lt;hwc2_device_t*&gt;(mAdapter.get()));
    }
    // 获取硬件支持的最大虚拟屏幕数量，VirtualDisplay主要是用来用于录屏
    mRemainingHwcVirtualDisplays = mHwcDevice-&gt;getMaxVirtualDisplayCount();
}
</code></pre>
<p>        先加载<code>hwcomposer</code>模块得到<code>hw_module_t</code>，再打开<code>composer</code>设备得到<code>hw_device_t</code>。所以一般情况下是先有HAL模块，再有实现此模块的硬件设备。</p>
<pre><code class="language-c">//节选自hardware/libhardware/include/hardware/hardware.h
typedef struct hw_module_t {
//每一个HAL库都会提供的一个方法methods，
	struct hw_module_methods_t* methods;
}hw_module_t;

typedef struct hw_module_methods_t {
//这个 methods的数据结构中只有一个函数指针变量open，用来打开指定的硬件设备。
    int (*open)(const struct hw_module_t* module, const char* id,
            struct hw_device_t** device);
} hw_module_methods_t;
</code></pre>
<p>        在每个HAL层模块实现都要定义一个<code>HAL_MODULE_INFO_SYM</code>数据结构，并且该结构的第一个字段必须是<code>hw_module_t</code>，下面是anbox当中<code>hwcomposer</code>模块的定义。</p>
<pre><code class="language-c">//节选自vendor/anbox/android/hwcomposer/hwcomposer.cpp
hwc_module_t HAL_MODULE_INFO_SYM = {
    .common = {
    .tag = HARDWARE_MODULE_TAG,
    .version_major = 1,
    .version_minor = 0,
    .id = HWC_HARDWARE_MODULE_ID,
    .name = &quot;Hardware Composer Module&quot;,
    .author = &quot;Anbox Developers&quot;,
    .methods = &amp;hwc_module_methods,
    }
};
</code></pre>
<p>        这里Anbox中对应method如下，实现了打开模块的接口。</p>
<pre><code class="language-c">//节选自vendor/anbox/android/hwcomposer/hwcomposer.cpp
//methods数据结构中只有一个函数指针变量open，用来打开指定的硬件设备（Anbox中是软件实现）
static hw_module_methods_t hwc_module_methods = {
    .open = hwc_device_open
};

//Anbox中这里注册了自己实现的HWC设备的各种接口对接函数
static int hwc_device_open(const hw_module_t* module, const char* name, hw_device_t** device) {
    ALOGD(&quot;%s&quot;, __PRETTY_FUNCTION__);

    auto dev = new HwcContext;
    dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; // 标记这是一个硬件设备的模块
    dev-&gt;device.common.version = HWC_DEVICE_API_VERSION_1_1; // HWC版本，Anbox还是用的HWC1
    dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); // 对应上面模块信息结构体定义
    dev-&gt;device.common.close = hwc_device_close; // HWC设备关闭调用的操作
    dev-&gt;device.prepare = hwc_prepare; // 图层的配置，surfaceflinger把要显示的layers放在displays参数里，针对其参数对应Display硬件配置图层的参数类型等。
    dev-&gt;device.set = hwc_set; // hwc_set方法，在SurfaceFlinger要求HWC发送图层数据，该方法进行发送相关图层数据给Anbox在Linux的前端实现。
    dev-&gt;device.eventControl = hwc_event_control; // 使能/禁止vsync，Anbox未实现
    dev-&gt;device.blank = hwc_blank; // 老的hwc(1.3以前)用blank控制display on/off，最新的hwc里用setPowerMode。实现的功能差不多，但setPowerMode的参数更丰富，不像blank就0/1。
    dev-&gt;device.query = hwc_query;
    dev-&gt;device.getDisplayConfigs = hwc_get_display_configs; //获取显示硬件的配置，一般是多显示屏等配置的获取返回，Anbox只有一个主显示器，因此这里只是配置0让HWC进入获取属性的调用。
    dev-&gt;device.getDisplayAttributes = hwc_get_display_attributes;//获取显示硬件的各个属性
    dev-&gt;device.registerProcs = hwc_register_procs;
    dev-&gt;device.dump = nullptr;

    *device = &amp;dev-&gt;device.common;

    return 0;
}
</code></pre>
<p>        可以看出这一阶段已经完成了Anbox的HWC具体实现的模块打开并注册接口，下面将针对hwc_get_display_attributes和hwc_set进行讲解，这两个是Anbox在HWC这一部分显示输出的精髓。</p>
<p><strong>Anbox部分重要实现</strong></p>
<p>        在Anbox的HWC模块中，其中最主要的就是hwc_get_display_attributes和hwc_set的实现，这里把一些重要的部分进行讲解。</p>
<p>        <strong>hwc_get_display_attributes函数部分实现</strong></p>
<pre><code class="language-c">//节选自vendor/anbox/android/hwcomposer/hwcomposer.cpp
static int hwc_get_display_attributes(hwc_composer_device_1* dev,
                                      int disp, uint32_t config,
                                      const uint32_t* attributes,
                                      int32_t* values) {
  if (disp != 0 || config != 0) {
    return -EINVAL;
  }

  //建立与Anbox前端的QEMU_PIPE连接
  DEFINE_AND_VALIDATE_HOST_CONNECTION();

  // 下面各个属性都是通过与Anbox连接获取返回的值
  while (*attributes != HWC_DISPLAY_NO_ATTRIBUTE) {
    //针对各种属性返回对应的值，其中HWC_DISPLAY_NO_ATTRIBUTE是这个attributes数组的结束
    switch (*attributes) {
      //获取屏幕VSYNC垂直同步信号的周期值
      case HWC_DISPLAY_VSYNC_PERIOD:
        *values = rcEnc-&gt;rcGetDisplayVsyncPeriod(rcEnc, disp);
        break;
      //获取屏幕宽高和DPI参数
      case HWC_DISPLAY_WIDTH:
        *values = rcEnc-&gt;rcGetDisplayWidth(rcEnc, disp);
        break;
      case HWC_DISPLAY_HEIGHT:
        *values = rcEnc-&gt;rcGetDisplayHeight(rcEnc, disp);
        break;
      case HWC_DISPLAY_DPI_X:
        *values = 1000 * rcEnc-&gt;rcGetDisplayDpiX(rcEnc, disp);
        break;
      case HWC_DISPLAY_DPI_Y:
        *values = 1000 * rcEnc-&gt;rcGetDisplayDpiY(rcEnc, disp);
        break;
      default:
        ALOGE(&quot;Unknown attribute value 0x%02x&quot;, *attributes);
    }
    ++attributes;
    ++values;
  }
  return 0;
}
</code></pre>
<p>        可以看得出hwc_get_display_attributes是通过Anbox获取屏幕的参数返回给安卓HWC模块，方便给SurfaceFlinger和HWC进行屏幕输出。</p>
<p>        接下来查看其中rcEnc调用的方法的来源：</p>
<pre><code class="language-c">//节选自vendor/anbox/android/hwcomposer/hwcomposer.cpp
//其来自于建立QEMU_PIPE的地方
#define DEFINE_AND_VALIDATE_HOST_CONNECTION() \
	//获取Anbox的QEMU_PIPE连接，这部分不再赘述
    HostConnection *hostCon = HostConnection::get(); \
    if (!hostCon) { \
        ALOGE(&quot;hwcomposer.anbox: Failed to get host connection\n&quot;); \
        return -EIO; \
    } \
    //获取Host端的rcEncoder方法返回的远程调用对象
    renderControl_encoder_context_t *rcEnc = hostCon-&gt;rcEncoder(); \
    if (!rcEnc) { \
        ALOGE(&quot;hwcomposer.anbox: Failed to get renderControl encoder context\n&quot;); \
        return -EIO; \
    }
</code></pre>
<p>        其来自于建立QEMU_PIPE的地方，通过与外部Anbox建立连接，利用Anbox 基于 Protobuf 设计的 RPC 进行通信，实现远程方法调用。<br />
        这里以rcEnc-&gt;rcGetDisplayWidth(rcEnc, disp)为例，远程能调用到Anbox在Host端的GL库函数返回的值：</p>
<pre><code class="language-cpp">//节选自vendor/anbox/src/anbox/graphics/emugl/RenderControl.cpp
int rcGetDisplayWidth(uint32_t display_id) {
  (void)display_id;
  // 调用到实际的GL库的函数，获取实际的垂直分辨率大小
  return static_cast&lt;int&gt;(anbox::graphics::emugl::DisplayInfo::get()-&gt;vertical_resolution());
}
</code></pre>
<p>        最终能正确通信获得rcGetDisplayWidth返回值。</p>
<p>        以上的获取DisplayWidth的实现，其流程从自下向上来看，其流程如下：<br />
        首先，hwc_get_display_attributes中的rcEnc-&gt;rcGetDisplayWidth远程调用获得了Host端Anbox的窗口垂直分辨率的值。<br />
        再者，dev-&gt;device.getDisplayAttributes = hwc_get_display_attributes是该HWC注册的方法，被populateConfigs函数调用该模块获取信息。<br />
        最后被HWC2On1Adapter::populatePrimary()、HWC2On1Adapter::hwc1Hotplug、HWC2On1Adapter::createVirtualDisplay等方法调用，主要用于在显示设备创建、热插拔时获取显示设备信息返回给SurfaceFlinger及HWC。</p>
<p>        <strong>hwc_set函数部分实现</strong></p>
<p>        dev-&gt;device.set是SurfaceFliner要求HWC发送图层数据，在这里Anbox对应注册的函数是hwc_set，其函数实现如下：</p>
<pre><code class="language-c">//节选自vendor/anbox/android/hwcomposer/hwcomposer.cpp
static int hwc_set(hwc_composer_device_1_t* dev, size_t numDisplays,
                   hwc_display_contents_1_t** displays) {
    // HWC上下文
    auto context = reinterpret_cast&lt;HwcContext*&gt;(dev);

    if (displays == NULL || displays[0] == NULL)
        return -EFAULT;
	//通过QEMU_PIPE与Anbox连接，原理同上一步hwc_get_display_attributes中的实现
    DEFINE_AND_VALIDATE_HOST_CONNECTION();

    // 循环处理当前display的所有层
    for (size_t i = 0 ; i &lt; displays[0]-&gt;numHwLayers ; i++) {
        const auto layer = &amp;displays[0]-&gt;hwLayers[i];

        //如果是指针或者需要跳过而不用刷新的层，跳过
        if (layer-&gt;flags &amp; HWC_SKIP_LAYER ||
            layer-&gt;flags &amp; HWC_IS_CURSOR_LAYER)
            continue;

        // Anbox下，HWC注册的compositionType是HWC_FRAMEBUFFER_TARGET
        if(layer-&gt;compositionType == HWC_FRAMEBUFFER_TARGET) {
            // 通过getprop去读取“anbox.layer_name”这一系统配置，获取当前要传输的Layer名称
            std::string layer_name_temp = android::base::GetProperty(&quot;anbox.layer_name&quot;, &quot;&quot;);
            std::string layer_name = layer_name_temp.substr(0, layer_name_temp.find('#'));
            strncpy(layer-&gt;name, layer_name.c_str(), layer_name.size());
        }

        // 根据图层的三组必要参数，发送Layer
        rcEnc-&gt;rcPostLayer(rcEnc,
                           layer-&gt;name,
                           cb-&gt;hostHandle,
                           layer-&gt;planeAlpha / 255,
                           layer-&gt;sourceCrop.left,
                           layer-&gt;sourceCrop.top,
                           layer-&gt;sourceCrop.right,
                           layer-&gt;sourceCrop.bottom,
                           layer-&gt;displayFrame.left,
                           layer-&gt;displayFrame.top,
                           layer-&gt;displayFrame.right,
                           layer-&gt;displayFrame.bottom);
        hostCon-&gt;flush(); //刷新缓冲区
    }
	// 通知Anbox所有发送完毕
    rcEnc-&gt;rcPostAllLayersDone(rcEnc);

    check_sync_fds(numDisplays, displays);

    return 0;
}
</code></pre>
<p>        该函数中，第一个系统配置“anbox.layer_name”是Anbox修改了SurfaceFlinger，在准备输出图层前把图层名称保存成这个配置中，具体实现如下：</p>
<pre><code class="language-cpp">//节选自：frameworks/native/services/surfaceflinger/BufferLayer.cpp
//SurfaceFlinger
void BufferLayer::setPerFrameData(const sp&lt;const DisplayDevice&gt;&amp; displayDevice,
                                  const ui::Transform&amp; transform, const Rect&amp; viewport,
                                  int32_t supportedPerFrameMetadata,
                                  const ui::Dataspace targetDataspace) {
    RETURN_IF_NO_HWC_LAYER(displayDevice);

    // Apply this display's projection's viewport to the visible region
    // before giving it to the HWC HAL.
    //获取可见区域
    Region visible = transform.transform(visibleRegion.intersect(viewport));
	
    // 寻找当前显示器的输出图层
    const auto outputLayer = findOutputLayerForDisplay(displayDevice);
    LOG_FATAL_IF(!outputLayer || !outputLayer-&gt;getState().hwc);
	//获取HWC
    auto&amp; hwcLayer = (*outputLayer-&gt;getState().hwc).hwcLayer;
	//保存当前图层名称到anbox.layer_name系统配置中
    android::base::SetProperty(&quot;anbox.layer_name&quot;, mName.string());
    //设置刚刚获取的可见区域到HWC
    auto error = hwcLayer-&gt;setVisibleRegion(visible);
    if (error != HWC2::Error::None) {
        ALOGE(&quot;[%s] Failed to set visible region: %s (%d)&quot;, mName.string(),
              to_string(error).c_str(), static_cast&lt;int32_t&gt;(error));c
        visible.dump(LOG_TAG);
    }
</code></pre>
<p>        而rcEnc-&gt;rcPostLayer中planeAlpha、sourceCrop、displayFrame就是下图中各个区域，如图3.5所示。</p>
<center><img src=images/hal-display/安卓显示区域间的关系.png></center>
<center>图3.5 安卓显示区域间的关系图</center>
<p>        第一，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。</p>
<p>        第二，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。</p>
<p>        而在外部Linux的Anbox中，上面rcEnc-&gt;rcPostLayer、rcEnc-&gt;rcPostAllLayersDone也是属于Anbox的RPC实现，这里只截取最终在Anbox中调用的地方，不多赘述。</p>
<pre><code class="language-cpp">//节选自vendor/anbox/src/anbox/graphics/emugl/RenderControl.cpp
void rcPostLayer(const char *name, uint32_t color_buffer, float alpha,
                 int32_t sourceCropLeft, int32_t sourceCropTop,
                 int32_t sourceCropRight, int32_t sourceCropBottom,
                 int32_t displayFrameLeft, int32_t displayFrameTop,
                 int32_t displayFrameRight, int32_t displayFrameBottom) {
  //建立渲染结构体
  Renderable r{
      name,
      color_buffer,
      alpha,
      {displayFrameLeft, displayFrameTop, displayFrameRight, displayFrameBottom},
      {sourceCropLeft, sourceCropTop, sourceCropRight, sourceCropBottom}};
  //发送给Anbox的Surface处理
  frame_layers.push_back(r);
}

void rcPostAllLayersDone() {
  if (composer) composer-&gt;submit_layers(frame_layers);
  //提交Layer后刷新缓冲区
  frame_layers.clear();
}

</code></pre>
<h5 id="gralloc模块"><a class="header" href="#gralloc模块">Gralloc模块</a></h5>
<h6 id="①-初步介绍-1"><a class="header" href="#①-初步介绍-1">① 初步介绍</a></h6>
<p>        在android图形架构中，Gralloc属于低级别组件，用于给图形缓冲队列进行缓冲区分配，是一个内存分配器。其通过<code>用法标志</code>执行缓冲区分配。用法标志包括以下属性：</p>
<ul>
<li>从软件 (CPU) 访问内存的频率</li>
<li>从硬件 (GPU) 访问内存的频率</li>
<li>是否将内存用作 OpenGL ES (GLES) 纹理</li>
<li>视频编码器是否会使用内存</li>
</ul>
<p>        例如，如果生产方的缓冲区格式指定 <code>RGBA_8888</code> 像素，并且生产方指明将从软件访问缓冲区，Gralloc将以R-G-B-A的顺序为每个像素创建一个4字节的缓冲区。如果情况相反，生产方指明仅从硬件访问其缓冲区且缓冲区作为 GLES 纹理，那么Gralloc可以做任何GLES驱动想要做的事情，比如BGRA排序、非线性swizzled布局和其他颜色格式。允许硬件使用其首选格式可以提高性能。</p>
<p>        Gralloc 返回的句柄可以通过 Binder 在进程之间进行传递。</p>
<h6 id="②-gralloc模块的重要实现"><a class="header" href="#②-gralloc模块的重要实现">② Gralloc模块的重要实现</a></h6>
<p><strong>Gralloc在安卓中的实现</strong></p>
<p>        Gralloc主要定义了以<code>HAL_MODULE_INFO_SYM</code>为符号的类型为<code>private_module_t</code>的结构体</p>
<pre><code class="language-c">//节选自gralloc.cpp
static struct hw_module_methods_t gralloc_module_methods = {
        .open = gralloc_device_open
};

struct private_module_t HAL_MODULE_INFO_SYM = {
    .base = {
        .common = {
            .tag = HARDWARE_MODULE_TAG,
            .version_major = 1,
            .version_minor = 0,
            .id = GRALLOC_HARDWARE_MODULE_ID,
            .name = &quot;Graphics Memory Allocator Module&quot;,
            .author = &quot;The Android Open Source Project&quot;,
            .methods = &amp;gralloc_module_methods
        },
        .registerBuffer = gralloc_register_buffer,
        .unregisterBuffer = gralloc_unregister_buffer,
        .lock = gralloc_lock,
        .unlock = gralloc_unlock,
    },
    .framebuffer = 0,
    .flags = 0,
    .numBuffers = 0,
    .bufferMask = 0,
    .lock = PTHREAD_MUTEX_INITIALIZER,
    .currentBuffer = 0,
};
</code></pre>
<p>        <code>private_module_t</code>用于描述Gralloc模块下的系统帧缓冲区信息,主要作用是将图形缓冲区渲染到帧缓冲区。</p>
<pre><code class="language-c">//节选于gralloc/gralloc_priv.h
struct private_module_t {
    gralloc_module_t base;
    
    private_handle_t* framebuffer; //指向系统帧缓冲区的句柄
    uint32_t flags; //用来标志系统帧缓冲区是否支持双缓冲
    uint32_t numBuffers;//表示系统帧缓冲区包含有多少个图形缓冲区
    uint32_t bufferMask; //记录系统帧缓冲区中的图形缓冲区的使用情况
    pthread_mutex_t lock; //一个互斥锁，用来保护结构体private_module_t的并行访
    buffer_handle_t currentBuffer; //用来描述当前正在被渲染的图形缓冲区
    int pmem_master;
    void* pmem_master_base;
    
    struct fb_var_screeninfo info; //保存设备显示屏的动态属性信息
    struct fb_fix_screeninfo finfo; //保存设备显示屏的固定属性信息
    float xdpi; //描述设备显示屏在宽度
    float ydpi; //描述设备显示屏在高度
    float fps; //用来描述显示屏的刷新频率
};
</code></pre>
<p>        <code>gralloc_module_t</code>用于描述gralloc模块信息，主要用于分配或者释放图形缓冲区。</p>
<pre><code class="language-c">//节选于hardware/gralloc.h
typedef struct gralloc_module_t {
    struct hw_module_t common;
    int (*registerBuffer)(struct gralloc_module_t const* module,
            buffer_handle_t handle);//映射一块图形缓冲区到一个进程的地址空间去
    int (*unregisterBuffer)(struct gralloc_module_t const* module,
            buffer_handle_t handle);//取消映射一块图形缓冲区到一个进程的地址空间去
    int (*lock)(struct gralloc_module_t const* module,
            buffer_handle_t handle, int usage,
            int l, int t, int w, int h,
            void** vaddr);//锁定一个指定的图形缓冲区
    int (*unlock)(struct gralloc_module_t const* module,
            buffer_handle_t handle);//解锁一个指定的图形缓冲区
    int (*perform)(struct gralloc_module_t const* module,
            int operation, ... );
    int (*lockAsync)(struct gralloc_module_t const* module,
            buffer_handle_t handle, int usage,
            int l, int t, int w, int h,
            void** vaddr, int fenceFd);
    int (*unlockAsync)(struct gralloc_module_t const* module,
            buffer_handle_t handle, int* fenceFd);
    int (*lockAsync_ycbcr)(struct gralloc_module_t const* module
            buffer_handle_t handle, int usage,
            int l, int t, int w, int h,
            struct android_ycbcr *ycbcr, int fenceFd);
    void* reserved_proc[3];
} gralloc_module_t;
</code></pre>
<p>        <code>alloc_device_t</code>用于描述gralloc设备的信息。</p>
<pre><code class="language-c">//节选于hardware/gralloc.h
typedef struct alloc_device_t {
    struct hw_device_t common;
    int (*alloc)(struct alloc_device_t* dev,
            int w, int h, int format, int usage,
            buffer_handle_t* handle, int* stride);//用于分配一块图形缓冲区
    int (*free)(struct alloc_device_t* dev,
            buffer_handle_t handle);//用于释放指定的图形缓冲区
    void (*dump)(struct alloc_device_t *dev, char *buff, int buff_len);
    void* reserved_proc[7];
} alloc_device_t;
</code></pre>
<p>        还有<code>hw_module_t</code>主要用于关联模块和设备，其在hardware.h被定义。<br />
        在<code>gralloc.h</code>中，还定义了<code>GRALLOC_HARDWARE_GPU0</code>设备,其主要是用于分配图形缓冲区，hw_module_t用于描述硬件抽象层Gralloc模块，而hw_device_t则用于描述硬件抽象层Gralloc设备，通过硬件抽象层设备可以找到对应的硬件抽象层模块。</p>
<p>        图形缓冲区的结构则用<code>private_handle_t</code>来描述</p>
<pre><code class="language-c">//节选于gralloc/gralloc_priv.h
struct private_handle_t : public native_handle {
#else
struct private_handle_t {
    struct native_handle nativeHandle;
#endif
    enum {
        PRIV_FLAGS_FRAMEBUFFER = 0x00000001
    };
    // file-descriptors
    int     fd; //指向一个文件描述符，这个文件描述符要么指向帧缓冲区设备，要么指向一块匿名共享内存
    // ints
    int     magic;
    int     flags;//用来描述一个缓冲区的标志，当一个缓冲区的标志值等于PRIV_FLAGS_FRAMEBUFFER的时候，就表示它是在帧缓冲区中分配的。
    int     size;//用来描述一个缓冲区的大小
    int     offset;//用来描述一个缓冲区的偏移地址
    // FIXME: the attributes below should be out-of-line
    uint64_t base __attribute__((aligned(8)));//用来描述一个缓冲区的实际地址
    int     pid;//用来描述一个缓冲区的创建者的PID
</code></pre>
<p>        <code>GRALLOC_HARDWARE_GPU0</code>设备使用结构体<code>alloc_device_t</code>来描述。结构体<code>alloc_device_t</code>有两个成员函数alloc和free，在上文当中[alloc_device_t用于描述gralloc设备的信息]已经提及。</p>
<pre><code class="language-c">//节选于hardware/gralloc.h
static inline int gralloc_open(const struct hw_module_t* module,
        struct alloc_device_t** device) {
    return module-&gt;methods-&gt;open(module,
            GRALLOC_HARDWARE_GPU0, (struct hw_device_t**)device);
}
</code></pre>
<p>        module指向的是一个用来描述Gralloc模块的<code>hw_module_t</code>结构体，它的成员变量methods所指向的一个<code>hw_module_methods_t</code>结构体的成员函数open指向了Gralloc模块中的函数<code>gralloc_device_open</code>。这里传入的设备名为<code>GRALLOC_HARDWARE_GPU0</code>，表示当前打开的是gpu设备。</p>
<p>        下面这个函数主要是用来创建一个<code>gralloc_context_t</code>结构体，并且对它的成员变量device进行初始化。结构体<code>gralloc_context_t</code>的成员变量device的类型为<code>gralloc_device_t</code>，它用来描述一个gralloc设备。前面提到，gralloc设备是用来分配和释放图形缓冲区的，这是通过调用它的成员函数alloc和free来实现的。从这里可以看出，函数<code>gralloc_device_open</code>所打开的gralloc设备的成员函数alloc和free分别被设置为Gralloc模块中的函数<code>gralloc_alloc</code>和<code>gralloc_free</code>。</p>
<p>        Gralloc主要就是通过上面两大函数来进行缓冲区的分配和释放。</p>
<pre><code class="language-c">//节选自gralloc.cpp
int gralloc_device_open(const hw_module_t* module, const char* name,
        hw_device_t** device)
{
    int status = -EINVAL;
    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
        gralloc_context_t *dev;
        dev = (gralloc_context_t*)malloc(sizeof(*dev));
        /* initialize our state here */
        memset(dev, 0, sizeof(*dev));
        /* initialize the procs */
        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; // 这是一个硬件模块标记
        dev-&gt;device.common.version = 0;
        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module);
        dev-&gt;device.common.close = gralloc_close; // gralloc关闭
        dev-&gt;device.alloc   = gralloc_alloc; //分配图形缓冲区
        dev-&gt;device.free    = gralloc_free; // 释放图形缓冲区
        *device = &amp;dev-&gt;device.common;
        status = 0;
    } else {
        status = fb_device_open(module, name, device);
    }
    return status;
}
</code></pre>
<p><strong>Anbox部分重要实现</strong></p>
<p>        上面已经针对Gralloc模块基础进行来介绍，为了了解这一部分的实现原理，这里只关注整个Gralloc的HAL模块中Anbox注册的主要函数gralloc_alloc和gralloc_free进行介绍，而其中用于帧缓冲刷新的fb_post，Anbox并未实现。</p>
<p>        <strong>gralloc_alloc及gralloc_free函数的实现</strong></p>
<p>        首先这里介绍gralloc_alloc以及gralloc_free函数，这里本质就是实现图形缓冲区的申请与释放，由于代码量较多，这里截取主要部分。</p>
<pre><code class="language-cpp">//节选自：vendor/anbox/android/opengl/system/gralloc/gralloc.cpp
//申请图形缓冲区
static int gralloc_alloc(alloc_device_t* dev,
                         int w, int h, int format, int usage,
                         buffer_handle_t* pHandle, int* pStride)
{
    //当前gralloc设备
    gralloc_device_t *grdev = (gralloc_device_t *)dev;
    
    //一些标记，不同标记表面当前Gralloc申请的缓冲区的用途，比如用于camera的缓冲区
    //
    // Note: in screen capture mode, both sw_write and hw_write will be on
    // and this is a valid usage
    //
    bool sw_write = (0 != (usage &amp; GRALLOC_USAGE_SW_WRITE_MASK));
    bool hw_write = (usage &amp; GRALLOC_USAGE_HW_RENDER);
    bool sw_read = (0 != (usage &amp; GRALLOC_USAGE_SW_READ_MASK));
    bool hw_cam_write = usage &amp; GRALLOC_USAGE_HW_CAMERA_WRITE;
    bool hw_cam_read = usage &amp; GRALLOC_USAGE_HW_CAMERA_READ;
    bool hw_vid_enc_read = usage &amp; GRALLOC_USAGE_HW_VIDEO_ENCODER;

    // 缓冲区大小，Anbox的这一模块是采用了ashmem这一共享内存来申请缓冲区
    int ashmem_size = 0;
    int stride = w;

    GLenum glFormat = 0;
    GLenum glType = 0;

    int bpp = 0;
    int align = 1;
    // 针对各种图像格式选择不同的像素位数(bpp)大小、格式(glFormat)等配置信息
    switch (format) {
        case HAL_PIXEL_FORMAT_RGBA_8888:
        case HAL_PIXEL_FORMAT_RGBX_8888:
        case HAL_PIXEL_FORMAT_BGRA_8888:
            bpp = 4;
            glFormat = GL_RGBA;
            glType = GL_UNSIGNED_BYTE;
            break;
        case HAL_PIXEL_FORMAT_RGB_888:
            bpp = 3;
            glFormat = GL_RGB;
            glType = GL_UNSIGNED_BYTE;
            break;
        default:
            ALOGE(&quot;gralloc_alloc: Unknown format %d&quot;, format);
            return -EINVAL;
    }

    //针对不同用途给ashmem_size增加大小
    if (sw_read || sw_write || hw_cam_write || hw_vid_enc_read) {
        // keep space for image on guest memory if SW access is needed
        // or if the camera is doing writing
        if (yuv_format) {
            size_t yStride = (w*bpp + (align - 1)) &amp; ~(align-1);
            size_t uvStride = (yStride / 2 + (align - 1)) &amp; ~(align-1);
            size_t uvHeight = h / 2;
            ashmem_size += yStride * h + 2 * (uvHeight * uvStride);
            stride = yStride / bpp;
        } else {
            size_t bpr = (w*bpp + (align-1)) &amp; ~(align-1);
            ashmem_size += (bpr * h);
            stride = bpr / bpp;
        }
    }
    
    //因为Anbox的实现没有实际图形硬件设备，从ashmem（Android 匿名共享内存，基于 mmap系统调用）申请图形缓冲区
    //
    // Allocate space in ashmem if needed
    //
    int fd = -1;
    if (ashmem_size &gt; 0) {
        // 对齐page size;
        ashmem_size = (ashmem_size + (PAGE_SIZE-1)) &amp; ~(PAGE_SIZE-1);
		// 申请gralloc-buffer区域的共享内存
        fd = ashmem_create_region(&quot;gralloc-buffer&quot;, ashmem_size);
        if (fd &lt; 0) {
            ALOGE(&quot;gralloc_alloc failed to create ashmem region: %s\n&quot;,
                    strerror(errno));
            return -errno;
        }
    }
	// 建立给申请方的回调
    cb_handle_t *cb = new cb_handle_t(fd, ashmem_size, usage, w, h, frameworkFormat, format, glFormat, glType);

    if (ashmem_size &gt; 0) {
        // 申请到了就map这片区域
        //
        // map ashmem region if exist
        //
        void *vaddr;
        int err = map_buffer(cb, &amp;vaddr);
        if (err) {
            close(fd);
            delete cb;
            return err;
        }

        // map成功就更新fd给回调
        cb-&gt;setFd(fd);
    }

    // 这里是如果有一些情况需要回传Anbox在主机侧Surface的数据，比如需要录屏的时候就需要这种情况
    //
    // Allocate ColorBuffer handle on the host (only if h/w access is allowed)
    // Only do this for some h/w usages, not all.
    // Also do this if we need to read from the surface, in this case the
    // rendering will still happen on the host but we also need to be able to
    // read back from the color buffer, which requires that there is a buffer
    //
    if (usage &amp; (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER |
                    GRALLOC_USAGE_HW_2D | GRALLOC_USAGE_HW_COMPOSER |
                    GRALLOC_USAGE_HW_FB | GRALLOC_USAGE_SW_READ_MASK) ) {
        DEFINE_HOST_CONNECTION;
        // 建立QEMU_PIPE连接后获取Anbox端的数据，这里是建立Anbox端的Buffer，否则Anbox那边会丢掉。创建了就会把Handle返回给相关接口以便调用。
        if (hostCon &amp;&amp; rcEnc) {
            cb-&gt;hostHandle = rcEnc-&gt;rcCreateColorBuffer(rcEnc, w, h, glFormat);
            D(&quot;Created host ColorBuffer 0x%x\n&quot;, cb-&gt;hostHandle);
        }

        if (!cb-&gt;hostHandle) {
           // Could not create colorbuffer on host !!!
           close(fd);
           delete cb;
           return -EIO;
        }
    }

    // 申请成功，把相关东西返回给对应接口，把申请的handle插入到已申请的列表（链表）
    //
    // alloc succeeded - insert the allocated handle to the allocated list
    //
    AllocListNode *node = new AllocListNode();
    pthread_mutex_lock(&amp;grdev-&gt;lock); // 互斥锁
    // 临界区
    node-&gt;handle = cb;
    node-&gt;next =  grdev-&gt;allocListHead;
    node-&gt;prev =  NULL; //单向链表
    // 链表头插法
    if (grdev-&gt;allocListHead) {
        grdev-&gt;allocListHead-&gt;prev = node;
    }
    grdev-&gt;allocListHead = node;
    pthread_mutex_unlock(&amp;grdev-&gt;lock); //退出临界区，取消互斥锁

    *pHandle = cb;
    return 0;
}

//释放图形缓冲区
static int gralloc_free(alloc_device_t* dev,
                        buffer_handle_t handle)
{
    const cb_handle_t *cb = (const cb_handle_t *)handle;
    if (!cb_handle_t::validate((cb_handle_t*)cb)) {
        ERR(&quot;gralloc_free: invalid handle&quot;);
        return -EINVAL;
    }

    // 如果该Handle有在外部Anbox上的ColorBuffer，连接QEMU_PIPE并释放它。
    if (cb-&gt;hostHandle != 0) {
        DEFINE_AND_VALIDATE_HOST_CONNECTION;
        D(&quot;Closing host ColorBuffer 0x%x\n&quot;, cb-&gt;hostHandle);
        rcEnc-&gt;rcCloseColorBuffer(rcEnc, cb-&gt;hostHandle);
    }

    // 释放ashmem申请的区域
    //
    // detach and unmap ashmem area if present
    //
    if (cb-&gt;fd &gt; 0) {
        if (cb-&gt;ashmemSize &gt; 0 &amp;&amp; cb-&gt;ashmemBase) {
            munmap((void *)cb-&gt;ashmemBase, cb-&gt;ashmemSize);
        }
        close(cb-&gt;fd);
    }

    // 从已申请的列表（链表实现）移除
    // remove it from the allocated list
    gralloc_device_t *grdev = (gralloc_device_t *)dev;
    pthread_mutex_lock(&amp;grdev-&gt;lock); // 互斥锁
    // 进入临界区
    AllocListNode *n = grdev-&gt;allocListHead;
    // 找到链表中对应这个Handle
    while( n &amp;&amp; n-&gt;handle != cb ) {
        n = n-&gt;next;
    }
    if (n) {
       // buffer found on list - remove it from list
       // 把Handle移出链表
       if (n-&gt;next) {
           n-&gt;next-&gt;prev = n-&gt;prev;
       }
       if (n-&gt;prev) {
           n-&gt;prev-&gt;next = n-&gt;next;
       }
       else {
           grdev-&gt;allocListHead = n-&gt;next;
       }

       delete n;
    }
    pthread_mutex_unlock(&amp;grdev-&gt;lock); //退出临界区，取消互斥锁

    delete cb;

    return 0;
}
</code></pre>
<p>        以上gralloc_alloc实现了图形缓冲区的申请，gralloc_free实现了缓冲区释放，但是在Anbox中，由于没有实际的图形硬件设备，其图形部分均由软件实现，因此其与图形缓冲区的相关实现均也由软件实现。与之相对应的，实际手机硬件中，这里的缓冲区是来自于硬件，例如通过FrameBuffer或者DRM显示设备进行申请等。</p>
<p>        由于Anbox的图形缓冲区是软件实现的，同时在渲染的画面均在Linux这边的Anbox上实现的，这一实现便有了缺点，例如DRM的实现可以通过硬件DMA对图形缓冲器进行处理，而Anbox的软件实现只能靠CPU进行内存拷贝，尤其在录屏的情况下，屏幕数据需要让CPU拷贝到外部进行合成显示，又需要拷贝回来再让编码器进行编码，两趟拷贝浪费了许多CPU与内存的性能。</p>
<h2 id="312-参考资料"><a class="header" href="#312-参考资料">3.1.2 参考资料</a></h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/421532503">自上而下解读Android显示流程（中上） - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/tli600605/article/details/101710446">Android图形系统系统篇之HWC_leontli的博客-CSDN博客_setclienttarget</a></li>
<li><a href="https://blog.csdn.net/coloriy/article/details/106566476">Andorid 硬件显示系统HWC&amp;HWC2架构详解_coloriy的博客-CSDN博客_android display hwc</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="32-anbox图形渲染实现"><a class="header" href="#32-anbox图形渲染实现">3.2 Anbox图形渲染实现</a></h2>
<h3 id="321-anbox图形渲染相关组件"><a class="header" href="#321-anbox图形渲染相关组件">3.2.1 Anbox图形渲染相关组件</a></h3>
<center><img src=images/render/image-20220712144405854.png></center>
<center>图3.6 Anbox基本架构</center>
<p>        如图3.6便是Anbox官方给出的架构图，从图中可以看到，Anbox主要有两个部分：Session Manager和Container Manager(Container Manager部分内容不在本文分析范围内)。其中Session Manager主要做了以下三部分工作：</p>
<h4 id="1-虚拟surfaceflinger"><a class="header" href="#1-虚拟surfaceflinger">(1) 虚拟Surfaceflinger</a></h4>
<p>        Surfaceflinger即Android的图像系统，可以将Android里的不同应用渲染的结构进行图层的合成，使得所有应用的渲染结果最终合成在一个窗口上。</p>
<h4 id="2-虚拟windowmanager"><a class="header" href="#2-虚拟windowmanager">(2) 虚拟Windowmanager</a></h4>
<p>        Windowmanager是指Android的窗口管理器，功能是给Android里的应用提供对应的窗口，即给每个应用提供自己的渲染界面。</p>
<h4 id="3-虚拟activitymanager"><a class="header" href="#3-虚拟activitymanager">(3) 虚拟Activitymanager</a></h4>
<p>        Activitymanager是指管理Android内部的进程管理器，主要功能是管理应用的启动、关闭等进程。</p>
<p>        本文主要从Android端中的OpenGL ES初始化开始分析，到最终的指令经过Anbox端的翻译库进行翻译，最终由宿主机端的OpenGL进行图形渲染。下图为具体实现流程图：</p>
<center><img src=images/render/image-20220712160910545.png></center>
<center>图3.7 OpenGL图形渲染流程图</center>
<h3 id="322-opengl-es"><a class="header" href="#322-opengl-es">3.2.2 OpenGL ES</a></h3>
<p>        Anbox的图形渲染部分实现与OpenGL ES息息相关，其实现了在Android模拟OpenGL相关库，接收相关指令并传输出去。下文将对OpenGL ES相关实现进行分析，在了解OpenGL ES之前，我们需要先了解什么是OpenGL。</p>
<h4 id="1-什么是opengl"><a class="header" href="#1-什么是opengl">(1) 什么是OpenGL</a></h4>
<p>        OpenGL是一套图像编程接口，对于开发者来说，其实就是一套C语言编写的API接口，通过这些接口，开发者可以调用显卡来进行计算机的图形开发。虽然OpenGL是一套API接口，但它并没有具体实现这些接口，接口的实现是由显卡的驱动程序来完成的。显卡驱动也是其他模块和显卡沟通的入口，开发者通过调用OpenGL的图像编程接口发出渲染命令，这些渲染命令被称为DrawCall，显卡驱动会将渲染命令翻译能被GPU理解的指令，然后通知GPU读取数据进行操作。</p>
<h4 id="2-什么是opengl-es"><a class="header" href="#2-什么是opengl-es">(2) 什么是OpenGL ES</a></h4>
<p>        OpenGL ES又是什么呢？它是为了更好地适应嵌入式等硬件较差的设备，推出的OpenGL的剪裁版，基本和OpenGL是一致的。Android从4.0开始默认开启硬件加速，也就是默认使用OpenGL ES来进行图形的生成和渲染工作。</p>
<h4 id="3-如何使用opengl-es"><a class="header" href="#3-如何使用opengl-es">(3) 如何使用OpenGL ES</a></h4>
<p>        了解Android如何使用OpenGL ES前，需要先对EGL有个简单了解，在本文中不涉及对EGL的深入分析。OpenGL虽然是跨平台的，但是在各个平台上也不能直接使用，因为每个平台的窗口都是不一样的，而EGL就是适配Android本地窗口系统和OpenGL ES桥接层。</p>
<p>        OpenGL ES 定义了平台无关的 GL 绘图指令，EGL则定义了控制 displays，contexts 以及 surfaces 的统一的平台接口。</p>
<h5 id="①-初始化与加载"><a class="header" href="#①-初始化与加载">① 初始化与加载</a></h5>
<p>        Android7 加载OpenGL ES和EGL的源码在<a href="https://hub.fastgit.xyz/anbox/platform_frameworks_native/tree/anbox/master/opengl/libs/EGL">/frameworks/native/opengl/libs/EGL/</a>。</p>
<p>        当<code>eglGetDisplay</code>被调用时，OpenGL 的库文件就被加载了，具体过程是：</p>
<h6 id="egl初始化"><a class="header" href="#egl初始化">EGL初始化</a></h6>
<pre><code>EGLDisplay eglGetDisplay(EGLNativeDisplayType display)//获取设备屏幕
</code></pre>
<pre><code>EGLBoolean eglInitialize(EGLDisplay display, // 指定EGL显示连接
                         EGLint *majorVersion, // 指定 EGL实现返回的 主版本号，可能为NULL
                         EGLint *minorVersion); // 返回 EGL实现返回的 次版本号，可能为NUL
</code></pre>
<p>        在EGL初始化过程中调用了OpenGL初始化函数<code>Loader::open</code>：</p>
<pre><code>static EGLBoolean egl_init_drivers_locked() {
    if (sEarlyInitState) {
        // initialized by static ctor. should be set here.
        return EGL_FALSE;
    }

    // get our driver loader
    Loader&amp; loader(Loader::getInstance());

    // dynamically load our EGL implementation
    egl_connection_t* cnx = &amp;gEGLImpl;
    if (cnx-&gt;dso == 0) {
        cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] =
                &amp;gHooks[egl_connection_t::GLESv1_INDEX];
        cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] =
                &amp;gHooks[egl_connection_t::GLESv2_INDEX];
                //调用初始化OpenGL函数
        cnx-&gt;dso = loader.open(cnx);
    }

    return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;
}
</code></pre>
<h6 id="opengl-es初始化"><a class="header" href="#opengl-es初始化">OpenGL ES初始化</a></h6>
<p>        <code>Loader::open(egl_connection_t* cnx)</code> 初始化图形驱动，主要是初始化这些函数表和指针。<code>Loader::open(egl_connection_t* cnx)</code> 的定义如下。</p>
<pre><code>static void* load_wrapper(const char* path) {
    void* so = dlopen(path, RTLD_NOW | RTLD_LOCAL);
    ALOGE_IF(!so, &quot;dlopen(\&quot;%s\&quot;) failed: %s&quot;, path, dlerror());
    return so;
}

#ifndef EGL_WRAPPER_DIR
#if defined(__LP64__)
#define EGL_WRAPPER_DIR &quot;/system/lib64&quot;
#else
#define EGL_WRAPPER_DIR &quot;/system/lib&quot;
#endif
#endif
//设置模拟器属性（是否在模拟器中运行？在模拟中运行时是否有GPU支持？）
static void setEmulatorGlesValue(void) {
    char prop[PROPERTY_VALUE_MAX];
    property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;);
    if (atoi(prop) != 1) return;

property_get(&quot;ro.kernel.qemu.gles&quot;,prop,&quot;0&quot;);
if (atoi(prop) == 1) {
    ALOGD(&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;);
    property_set(&quot;qemu.gles&quot;, &quot;1&quot;);
    return;
}

// for now, checking the following
// directory is good enough for emulator system images
const char* vendor_lib_path =
//NDK编译后的库不同手机上运行，可能加载的是 32 位 的 或者 64 的 库
#if defined(__LP64__)
        &quot;/vendor/lib64/egl&quot;;
#else
        &quot;/vendor/lib/egl&quot;;
#endif
//判断库文件是否存在
const bool has_vendor_lib = (access(vendor_lib_path, R_OK) == 0);
if (has_vendor_lib) {
//存在则表示模拟器被GPU支持，通过客户的OpenGLES 实现
    ALOGD(&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;);
    //设置qemu.gles值为2
    property_set(&quot;qemu.gles&quot;, &quot;2&quot;);
} else {
//模拟器不被GPU所支持，设置qemu.gles值为0
    ALOGD(&quot;Emulator without GPU support detected. &quot;
          &quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;);
    property_set(&quot;qemu.gles&quot;, &quot;0&quot;);
}

}

void* Loader::open(egl_connection_t* cnx)
{
    void* dso;
    driver_t* hnd = 0;
// 设置模拟器属性（是否在模拟器中运行？在模拟中运行时是否有GPU支持？）
setEmulatorGlesValue();
//加载设备特有的图形驱动库，包括 EGL 库，OpenGL ES 1.0 和 2.0 的库。
dso = load_driver(&quot;GLES&quot;, cnx, EGL | GLESv1_CM | GLESv2);
if (dso) {
    hnd = new driver_t(dso);
} else {
    // Always load EGL first
    dso = load_driver(&quot;EGL&quot;, cnx, EGL);
    if (dso) {
        hnd = new driver_t(dso);
        hnd-&gt;set( load_driver(&quot;GLESv1_CM&quot;, cnx, GLESv1_CM), GLESv1_CM );
        hnd-&gt;set( load_driver(&quot;GLESv2&quot;,    cnx, GLESv2),    GLESv2 );
    }
}

LOG_ALWAYS_FATAL_IF(!hnd, &quot;couldn't find an OpenGL ES implementation&quot;);
//加载图形驱动 Wrapper，它们都位于 /system/lib64 或 /system/lib
cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR &quot;/libEGL.so&quot;);
cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv2.so&quot;);
cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR &quot;/libGLESv1_CM.so&quot;);

LOG_ALWAYS_FATAL_IF(!cnx-&gt;libEgl,
        &quot;couldn't load system EGL wrapper libraries&quot;);

LOG_ALWAYS_FATAL_IF(!cnx-&gt;libGles2 || !cnx-&gt;libGles1,
        &quot;couldn't load system OpenGL ES wrapper libraries&quot;);

return (void*)hnd;
}
</code></pre>
<p>        这里的<code>driver_t</code>是Loader类的内部结构体：</p>
<pre><code>struct driver_t {
        explicit driver_t(void* gles);
        ~driver_t();
        status_t set(void* hnd, int32_t api);
        void* dso[3];
};
</code></pre>
<p>        <code>struct driver_t</code> 包含设备生产商提供的设备特有 EGL 和 OpenGL ES 实现库的句柄，如果 EGL 接口和 OpenGL 接口由单独的库实现，它包含一个库的句柄，即这个单独的库，如果 EGL 接口由不同的库实现，它则包含所有这些库的句柄。</p>
<p>        在open函数中还调用了<code>setEmulatorGlesValue</code>函数，这个函数用于检查、设置一些模拟器属性(例如是否在模拟器中运行以及在模拟运行时是否有GPU支持)。</p>
<p>        <code>Loader::load_driver()</code>函数主要完成驱动库加载,以下是相关代码，加载驱动库可细分为三步进行：</p>
<pre><code>/* This function is called to check whether we run inside the emulator,
 * and if this is the case whether GLES GPU emulation is supported.
 *
 * Returned values are:
 *  -1   -&gt; not running inside the emulator
 *   0   -&gt; running inside the emulator, but GPU emulation not supported
 *   1   -&gt; running inside the emulator, GPU emulation is supported
 *          through the &quot;emulation&quot; host-side OpenGL ES implementation.
 *   2   -&gt; running inside the emulator, GPU emulation is supported
 *          through a guest-side vendor driver's OpenGL ES implementation.
 */
static int
checkGlesEmulationStatus(void)
{
    /* We're going to check for the following kernel parameters:
     *
     *    qemu=1                      -&gt; tells us that we run inside the emulator
     *    android.qemu.gles=&lt;number&gt;  -&gt; tells us the GLES GPU emulation status
     *
     * Note that we will return &lt;number&gt; if we find it. This let us support
     * more additionnal emulation modes in the future.
     */
    char  prop[PROPERTY_VALUE_MAX];
    int   result = -1;

    /* First, check for qemu=1 */
    property_get(&quot;ro.kernel.qemu&quot;,prop,&quot;0&quot;);
    if (atoi(prop) != 1)
        return -1;

    /* We are in the emulator, get GPU status value */
    property_get(&quot;qemu.gles&quot;,prop,&quot;0&quot;);
    return atoi(prop);
}
. . . . . . 
void Loader::init_api(void* dso,
        char const * const * api,
        __eglMustCastToProperFunctionPointerType* curr,
        getProcAddressType getProcAddress)
{
    const ssize_t SIZE = 256;
    char scrap[SIZE];
    while (*api) {
        char const * name = *api;
        __eglMustCastToProperFunctionPointerType f =
            (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);
        if (f == NULL) {
            // couldn't find the entry-point, use eglGetProcAddress()
            f = getProcAddress(name);
        }
        if (f == NULL) {
            // Try without the OES postfix
            ssize_t index = ssize_t(strlen(name)) - 3;
            if ((index&gt;0 &amp;&amp; (index&lt;SIZE-1)) &amp;&amp; (!strcmp(name+index, &quot;OES&quot;))) {
                strncpy(scrap, name, index);
                scrap[index] = 0;
                f = (__eglMustCastToProperFunctionPointerType)dlsym(dso, scrap);
                //ALOGD_IF(f, &quot;found &lt;%s&gt; instead&quot;, scrap);
            }
        }
        if (f == NULL) {
            // Try with the OES postfix
            ssize_t index = ssize_t(strlen(name)) - 3;
            if (index&gt;0 &amp;&amp; strcmp(name+index, &quot;OES&quot;)) {
                snprintf(scrap, SIZE, &quot;%sOES&quot;, name);
                f = (__eglMustCastToProperFunctionPointerType)dlsym(dso, scrap);
                //ALOGD_IF(f, &quot;found &lt;%s&gt; instead&quot;, scrap);
            }
        }
        if (f == NULL) {
            //ALOGD(&quot;%s&quot;, name);
            f = (__eglMustCastToProperFunctionPointerType)gl_unimplemented;

            /*
             * GL_EXT_debug_label is special, we always report it as
             * supported, it's handled by GLES_trace. If GLES_trace is not
             * enabled, then these are no-ops.
             */
            if (!strcmp(name, &quot;glInsertEventMarkerEXT&quot;)) {
                f = (__eglMustCastToProperFunctionPointerType)gl_noop;
            } else if (!strcmp(name, &quot;glPushGroupMarkerEXT&quot;)) {
                f = (__eglMustCastToProperFunctionPointerType)gl_noop;
            } else if (!strcmp(name, &quot;glPopGroupMarkerEXT&quot;)) {
                f = (__eglMustCastToProperFunctionPointerType)gl_noop;
            }
        }
        *curr++ = f;
        api++;
    }
}

void *Loader::load_driver(const char* kind,
        egl_connection_t* cnx, uint32_t mask)
{
    class MatchFile {
    public:
        static String8 find(const char* kind) {
            String8 result;
            int emulationStatus = checkGlesEmulationStatus();
            switch (emulationStatus) {
                case 0:
#if defined(__LP64__)
                    result.setTo(&quot;/system/lib64/egl/libGLES_android.so&quot;);
#else
                    result.setTo(&quot;/system/lib/egl/libGLES_android.so&quot;);
#endif
                    return result;
                case 1:
                    // Use host-side OpenGL through the &quot;emulation&quot; library
#if defined(__LP64__)
                    result.appendFormat(&quot;/system/lib64/egl/lib%s_emulation.so&quot;, kind);
#else
                    result.appendFormat(&quot;/system/lib/egl/lib%s_emulation.so&quot;, kind);
#endif
                    return result;
                default:
                    // Not in emulator, or use other guest-side implementation
                    break;
            }

            String8 pattern;
            pattern.appendFormat(&quot;lib%s&quot;, kind);
            const char* const searchPaths[] = {
#if defined(__LP64__)
                    &quot;/vendor/lib64/egl&quot;,
                    &quot;/system/lib64/egl&quot;
#else
                    &quot;/vendor/lib/egl&quot;,
                    &quot;/system/lib/egl&quot;
#endif
            };

            // first, we search for the exact name of the GLES userspace
            // driver in both locations.
            // i.e.:
            //      libGLES.so, or:
            //      libEGL.so, libGLESv1_CM.so, libGLESv2.so

            for (size_t i=0 ; i&lt;NELEM(searchPaths) ; i++) {
                if (find(result, pattern, searchPaths[i], true)) {
                    return result;
                }
            }

            // for compatibility with the old &quot;egl.cfg&quot; naming convention
            // we look for files that match:
            //      libGLES_*.so, or:
            //      libEGL_*.so, libGLESv1_CM_*.so, libGLESv2_*.so

            pattern.append(&quot;_&quot;);
            for (size_t i=0 ; i&lt;NELEM(searchPaths) ; i++) {
                if (find(result, pattern, searchPaths[i], false)) {
                    return result;
                }
            }

            // we didn't find the driver. gah.
            result.clear();
            return result;
        }

    private:
        static bool find(String8&amp; result,
                const String8&amp; pattern, const char* const search, bool exact) {
            if (exact) {
                String8 absolutePath;
                absolutePath.appendFormat(&quot;%s/%s.so&quot;, search, pattern.string());
                if (!access(absolutePath.string(), R_OK)) {
                    result = absolutePath;
                    return true;
                }
                return false;
            }

            DIR* d = opendir(search);
            if (d != NULL) {
                struct dirent cur;
                struct dirent* e;
                while (readdir_r(d, &amp;cur, &amp;e) == 0 &amp;&amp; e) {
                    if (e-&gt;d_type == DT_DIR) {
                        continue;
                    }
                    if (!strcmp(e-&gt;d_name, &quot;libGLES_android.so&quot;)) {
                        // always skip the software renderer
                        continue;
                    }
                    if (strstr(e-&gt;d_name, pattern.string()) == e-&gt;d_name) {
                        if (!strcmp(e-&gt;d_name + strlen(e-&gt;d_name) - 3, &quot;.so&quot;)) {
                            result.clear();
                            result.appendFormat(&quot;%s/%s&quot;, search, e-&gt;d_name);
                            closedir(d);
                            return true;
                        }
                    }
                }
                closedir(d);
            }
            return false;
        }
    };


    String8 absolutePath = MatchFile::find(kind);
    if (absolutePath.isEmpty()) {
        // this happens often, we don't want to log an error
        return 0;
    }
    const char* const driver_absolute_path = absolutePath.string();

    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
    if (dso == 0) {
        const char* err = dlerror();
        ALOGE(&quot;load_driver(%s): %s&quot;, driver_absolute_path, err?err:&quot;unknown&quot;);
        return 0;
    }

    if (mask &amp; EGL) {
        ALOGD(&quot;EGL loaded %s&quot;, driver_absolute_path);
        getProcAddress = (getProcAddressType)dlsym(dso, &quot;eglGetProcAddress&quot;);

        ALOGE_IF(!getProcAddress,
                &quot;can't find eglGetProcAddress() in %s&quot;, driver_absolute_path);

        egl_t* egl = &amp;cnx-&gt;egl;
        __eglMustCastToProperFunctionPointerType* curr =
            (__eglMustCastToProperFunctionPointerType*)egl;
        char const * const * api = egl_names;
        while (*api) {
            char const * name = *api;
            __eglMustCastToProperFunctionPointerType f =
                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);
            if (f == NULL) {
                // couldn't find the entry-point, use eglGetProcAddress()
                f = getProcAddress(name);
                if (f == NULL) {
                    f = (__eglMustCastToProperFunctionPointerType)0;
                }
            }
            *curr++ = f;
            api++;
        }
    }

    if (mask &amp; GLESv1_CM) {
        ALOGD(&quot;GLESv1_CM loaded %s&quot;, driver_absolute_path);
        init_api(dso, gl_names,
            (__eglMustCastToProperFunctionPointerType*)
                &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl,
            getProcAddress);
    }

    if (mask &amp; GLESv2) {
      ALOGD(&quot;GLESv2 loaded %s&quot;, driver_absolute_path);
      init_api(dso, gl_names,
            (__eglMustCastToProperFunctionPointerType*)
                &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl,
            getProcAddress);
    }

    return dso;
}
</code></pre>
<p><strong>第一步，找到驱动库文件的路径:</strong></p>
<pre><code>class MatchFile {
    public:
        static String8 find(const char* kind) {
            String8 result;
            int emulationStatus = checkGlesEmulationStatus();
            switch (emulationStatus) {
                case 0:
#if defined(__LP64__)
                    result.setTo(&quot;/system/lib64/egl/libGLES_android.so&quot;);
#else
                    result.setTo(&quot;/system/lib/egl/libGLES_android.so&quot;);
#endif
                    return result;
                case 1:
                    // Use host-side OpenGL through the &quot;emulation&quot; library
#if defined(__LP64__)
                    result.appendFormat(&quot;/system/lib64/egl/lib%s_emulation.so&quot;, kind);
#else
                    result.appendFormat(&quot;/system/lib/egl/lib%s_emulation.so&quot;, kind);
#endif
                    return result;
                default:
                    // Not in emulator, or use other guest-side implementation
                    break;
            }

            String8 pattern;
            pattern.appendFormat(&quot;lib%s&quot;, kind);
            const char* const searchPaths[] = {
#if defined(__LP64__)
                    &quot;/vendor/lib64/egl&quot;,
                    &quot;/system/lib64/egl&quot;
#else
                    &quot;/vendor/lib/egl&quot;,
                    &quot;/system/lib/egl&quot;
#endif
            };

            // first, we search for the exact name of the GLES userspace
            // driver in both locations.
            // i.e.:
            //      libGLES.so, or:
            //      libEGL.so, libGLESv1_CM.so, libGLESv2.so

            for (size_t i=0 ; i&lt;NELEM(searchPaths) ; i++) {
                if (find(result, pattern, searchPaths[i], true)) {
                    return result;
                }
            }

            // for compatibility with the old &quot;egl.cfg&quot; naming convention
            // we look for files that match:
            //      libGLES_*.so, or:
            //      libEGL_*.so, libGLESv1_CM_*.so, libGLESv2_*.so

            pattern.append(&quot;_&quot;);
            for (size_t i=0 ; i&lt;NELEM(searchPaths) ; i++) {
                if (find(result, pattern, searchPaths[i], false)) {
                    return result;
                }
            }

            // we didn't find the driver. gah.
            result.clear();
            return result;
        }

    private:
        static bool find(String8&amp; result,
                const String8&amp; pattern, const char* const search, bool exact) {
            if (exact) {
                String8 absolutePath;
                absolutePath.appendFormat(&quot;%s/%s.so&quot;, search, pattern.string());
                if (!access(absolutePath.string(), R_OK)) {
                    result = absolutePath;
                    return true;
                }
                return false;
            }

            DIR* d = opendir(search);
            if (d != NULL) {
                struct dirent cur;
                struct dirent* e;
                while (readdir_r(d, &amp;cur, &amp;e) == 0 &amp;&amp; e) {
                    if (e-&gt;d_type == DT_DIR) {
                        continue;
                    }
                    if (!strcmp(e-&gt;d_name, &quot;libGLES_android.so&quot;)) {
                        // always skip the software renderer
                        continue;
                    }
                    if (strstr(e-&gt;d_name, pattern.string()) == e-&gt;d_name) {
                        if (!strcmp(e-&gt;d_name + strlen(e-&gt;d_name) - 3, &quot;.so&quot;)) {
                            result.clear();
                            result.appendFormat(&quot;%s/%s&quot;, search, e-&gt;d_name);
                            closedir(d);
                            return true;
                        }
                    }
                }
                closedir(d);
            }
            return false;
        }
    };


    String8 absolutePath = MatchFile::find(kind);
    if (absolutePath.isEmpty()) {
        // this happens often, we don't want to log an error
        return 0;
    }
</code></pre>
<p>        对于使用模拟器即使用 GLES 软件渲染模拟的情况，EGL 和 OpenGL ES 库对应为 <code>/system/lib64/egl/libGLES_android.so</code> 或 <code>/system/lib/egl/libGLES_android.so</code>。</p>
<p>        如果使用物理设备，那么对于特定图形驱动库文件，EGL 库文件或 OpenGL ES 库文件查找则按照如下的顺序进行加载：<br />
① <code>/vendor/lib64/egl</code> 或 <code>/vendor/lib/egl</code> 目录下文件名符合 <code>lib*.so</code> 模式的库文件，例如 <code>/vendor/lib64/egl/libGLES.so</code>。<br />
② <code>/system/lib64/egl</code> 或 <code>/system/lib/egl</code> 目录下文件名符合 <code>lib*.so</code> 模式的库文件，例如 <code>/system/lib64/egl/libGLES.so</code>。<br />
③ <code>/vendor/lib64/egl</code> 或 <code>/vendor/lib/egl</code> 目录下文件名符合 <code>lib_*.so</code> 模式的库文件，例如针对于 Pixel 设备的 <code>/vendor/lib64/egl/libEGL_adreno.so</code>。<br />
④ <code>/system/lib64/egl</code> 或 <code>/system/lib/egl</code> 目录下文件名符合 <code>lib_*.so</code> 模式的库文件。</p>
<p>        也就是说Android 会优先采用 /vendor/ 下设备供应商提供的图形驱动库。</p>
<p><strong>第二步，通过 <code>dlopen</code>函数加载库文件:</strong></p>
<pre><code>const char* const driver_absolute_path = absolutePath.string();

    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
    if (dso == 0) {
        const char* err = dlerror();
        ALOGE(&quot;load_driver(%s): %s&quot;, driver_absolute_path, err?err:&quot;unknown&quot;);
        return 0;
    }
</code></pre>
<p><strong>第三步，初始化函数表:</strong></p>
<pre><code>if (mask &amp; EGL) {
    ALOGD(&quot;EGL loaded %s&quot;, driver_absolute_path);
    getProcAddress = (getProcAddressType)dlsym(dso, &quot;eglGetProcAddress&quot;);

    ALOGE_IF(!getProcAddress,
            &quot;can't find eglGetProcAddress() in %s&quot;, driver_absolute_path);

    egl_t* egl = &amp;cnx-&gt;egl;
    __eglMustCastToProperFunctionPointerType* curr =
        (__eglMustCastToProperFunctionPointerType*)egl;
    char const * const * api = egl_names;
    while (*api) {
        char const * name = *api;
        __eglMustCastToProperFunctionPointerType f =
            (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);
        if (f == NULL) {
            // couldn't find the entry-point, use eglGetProcAddress()
            f = getProcAddress(name);
            if (f == NULL) {
                f = (__eglMustCastToProperFunctionPointerType)0;
            }
        }
        *curr++ = f;
        api++;
    }
}

if (mask &amp; GLESv1_CM) {
    ALOGD(&quot;GLESv1_CM loaded %s&quot;, driver_absolute_path);
    init_api(dso, gl_names,
        (__eglMustCastToProperFunctionPointerType*)
            &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl,
        getProcAddress);
}

if (mask &amp; GLESv2) {
  ALOGD(&quot;GLESv2 loaded %s&quot;, driver_absolute_path);
  init_api(dso, gl_names,
        (__eglMustCastToProperFunctionPointerType*)
            &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl,
        getProcAddress);
}
return dso;
}
</code></pre>
<p>        初始化函数表主要通过 <code>dlsym</code>函数,根据函数名，一个个找到对应的地址，并赋值给函数指针来完成:</p>
<pre><code>static void* load_wrapper(const char* path) {
    void* so = dlopen(path, RTLD_NOW | RTLD_LOCAL);
    ALOGE_IF(!so, &quot;dlopen(\&quot;%s\&quot;) failed: %s&quot;, path, dlerror());
    return so;
}
</code></pre>
<h5 id="②-android-加载-opengl-es总结"><a class="header" href="#②-android-加载-opengl-es总结">② Android 加载 OpenGL ES总结</a></h5>
<p>        Android加载OpenGL ES流程图如图3.8所示:</p>
<center><img src=images/render/image-20220712165221787.png></center>
<center>图3.8 加载OpenGL ES流程图</center>
<p>        从Android加载OpenGL ES的流程可以看出，只要Anbox在Android的<code>/system/lib64/egl</code>下安装对应的OpenGL ES库，则可以使Android加载Anbox提供的渲染库了。</p>
<p>        Anbox在<code>anbox/android/opengl/system</code>下有几个文件夹，查看<code>egl/Android.mk</code>文件。</p>
<p>        可以看到<code>$(call emugl-begin-shared-library,libEGL_emulation)</code>，这一行的意思是编译为动态库，库名为<code>libEGL_emulation</code>。
Anbox中<code>anbox/android</code>文件夹是放在Android源码中，编译后存在Android镜像中，随着编译完成，Anbox在Android的<code>/system/lib64/egl</code>下就安装了三个动态库，分别为libEGL_emulation.so、libGLESv1_CM_emulation.so和libGLESv2_emulation.so。也就是Anbox作为虚拟的硬件厂商给Android提供的OpenGL ES渲染库。</p>
<p>        但Anbox实际渲染工作并不是上述三个库文件，这三个库文件作用为采集Android中APP渲染的OpenGL ES指令，并通过高速传输通道qemu-pipe传输将指令传至宿主机Anbox进程中，实际渲染工作由宿主机执行。
具体渲染的机制可以参考图3.9。</p>
<center><img src=images/render/image-20220712165237684.png></center>
<center>图3.9 Anbox渲染机制</center>
<p>        其中：<code>swiftshader</code>是谷歌提供的一种纯软件渲染的方式，其代码可在github进行搜索下载。
        而<code>host</code>则是使用宿主机中默认的OpenGL ES库。即如果宿主机中显卡及显卡驱动支持OpenGL ES标准规范，则可以直接使用宿主机中的显卡进行渲染。但目前大部分显卡和驱动都不能直接支持OpenGL ES，因此Anbox会将Android的OpenGL ES 命令翻译成Linux所能支持的OpenGL 命令，再由Linux中的OpenGL进行渲染。
此部分代码在<code>anbox/external/android-emugl和/anbox/src/anbox/graphics</code>中。</p>
<h3 id="323-anbox接收与渲染"><a class="header" href="#323-anbox接收与渲染">3.2.3 Anbox接收与渲染</a></h3>
<p>        到这里，Android的OpenGL ES命令已经准备完成，接下来只要将指令发送给宿主机进行转换和渲染即可。</p>
<p>        首先从Anbox源码入手进行分析，这一部分涉及到了渲染环境的初始化。</p>
<h4 id="1-初始化session-manager入口"><a class="header" href="#1-初始化session-manager入口">(1) 初始化：session manager入口</a></h4>
<p>        <code>session manager</code>的入口函数在<code>anbox/src/anbox/cmds/session_manager.cpp</code>.首先是处理一系列的启动参数，对渲染来说，主要参数是<code>software-rendering</code></p>
<pre><code>flag(cli::make_flag(cli::Name{&quot;software-rendering&quot;},
                      cli::Description{&quot;Use software rendering instead of hardware accelerated GL rendering&quot;}
</code></pre>
<p>        使用软件渲染或硬件渲染:</p>
<pre><code> const auto should_force_software_rendering = utils::get_env_value(&quot;ANBOX_FORCE_SOFTWARE_RENDERING&quot;, &quot;false&quot;);
    auto gl_driver = graphics::GLRendererServer::Config::Driver::Host;
    if (should_force_software_rendering == &quot;true&quot; || use_software_rendering_)
     gl_driver = graphics::GLRendererServer::Config::Driver::Software;

    graphics::GLRendererServer::Config renderer_config {
      gl_driver,
      single_window_
    };
    auto gl_server = std::make_shared&lt;graphics::GLRendererServer&gt;(renderer_config, window_manager);

    platform-&gt;set_window_manager(window_manager);
    platform-&gt;set_renderer(gl_server-&gt;renderer());
    window_manager-&gt;setup();
</code></pre>
<p>        根据启动参数，决定使用软件渲染或硬件渲染，然后生成了一个<code>GLRendererServer</code>的共享指针,<code>GLRendererServer</code>函数信息位于<code>anbox/src/anbox/graphics/gl_renderer_server.cpp</code>中，源码为：</p>
<pre><code>GLRendererServer::GLRendererServer(const Config &amp;config, const std::shared_ptr&lt;wm::Manager&gt; &amp;wm)
    : renderer_(std::make_shared&lt;::Renderer&gt;()) {

  std::shared_ptr&lt;LayerComposer::Strategy&gt; composer_strategy;
  if (config.single_window)
    composer_strategy = std::make_shared&lt;SingleWindowComposerStrategy&gt;(wm);
  else
    composer_strategy = std::make_shared&lt;MultiWindowComposerStrategy&gt;(wm);

  composer_ = std::make_shared&lt;LayerComposer&gt;(renderer_, composer_strategy);

  auto gl_libs = emugl::default_gl_libraries();
  if (config.driver == Config::Driver::Software) {
    auto swiftshader_path = fs::path(utils::get_env_value(&quot;SWIFTSHADER_PATH&quot;));
    const auto snap_path = utils::get_env_value(&quot;SNAP&quot;);
    if (!snap_path.empty())
      swiftshader_path = fs::path(snap_path) / &quot;lib&quot; / &quot;anbox&quot; / &quot;swiftshader&quot;;
    if (!fs::exists(swiftshader_path))
      throw std::runtime_error(&quot;Software rendering is enabled, but SwiftShader library directory is not found.&quot;);

    gl_libs = std::vector&lt;emugl::GLLibrary&gt;{
      {emugl::GLLibrary::Type::EGL, (swiftshader_path / &quot;libEGL.so&quot;).string()},
      {emugl::GLLibrary::Type::GLESv1, (swiftshader_path / &quot;libGLES_CM.so&quot;).string()},
      {emugl::GLLibrary::Type::GLESv2, (swiftshader_path / &quot;libGLESv2.so&quot;).string()},
    };
  }
  emugl_logger_struct log_funcs;
  log_funcs.coarse = logger_write;
  log_funcs.fine = logger_write;

  if (!emugl::initialize(gl_libs, &amp;log_funcs, nullptr))
    BOOST_THROW_EXCEPTION(std::runtime_error(&quot;Failed to initialize OpenGL renderer&quot;));

  renderer_-&gt;initialize(0);

  registerRenderer(renderer_);
  registerLayerComposer(composer_);
}
</code></pre>
<p>        根据源码可知，先根据使用的窗口策略生成对应的图层合成策略智能指针，LayerComposer这个模块里面就是把不同应用的图层合成到同一个画布上，即虚拟一个Android的Surfaceflinger。<br />
然后根据软件渲染还是硬件渲染读取对应的库函数，以软件渲染为例，Anbox先去读取swiftshader的环境变量，如果存在，则将swiftshader库的路径设置为环境变量读取到的路径；然后Anbox读取SNAP的环境变量，也就说，如果Anbox是使用snap打包启动的，则直接去对应的路径下读取swiftshader的库。如果读取到了swiftshader库的路径，则在对应路径下读取libEGL.so、libGLES_CM.so和libGLESv2.so。即OpenGL ES对应的三个库文件。<br />
        接着初始化这三个库文件，进入<code>anbox/src/anbox/graphics/emugl/RenderApi.cpp</code>：</p>
<pre><code>bool initialize(const std::vector&lt;GLLibrary&gt; &amp;libs, emugl_logger_struct *log_funcs, logger_t crash_func) {
  set_emugl_crash_reporter(crash_func);
  if (log_funcs) {
    set_emugl_logger(log_funcs-&gt;coarse);
    set_emugl_cxt_logger(log_funcs-&gt;fine);
  }

  for (const auto &amp;lib : libs) {
    const auto path = lib.path.c_str();
    switch (lib.type) {
    case GLLibrary::Type::EGL:
      if (!init_egl_dispatch(path))
        return false;
      break;
    case GLLibrary::Type::GLESv1:
      if (!gles1_dispatch_init(path, &amp;s_gles1))
        return false;
      break;
    case GLLibrary::Type::GLESv2:
      if (!gles2_dispatch_init(path, &amp;s_gles2))
        return false;
      break;
    default:
      break;
    }
  }
</code></pre>
<p>        打开对应路径，将egl需要用到的函数全部通过<code>findSymbol</code>或<code>eglGetProcAddress</code>的方式得到函数地址，方便后续直接调用。这样即可得到了<code>OpenGL ES</code>所有函数地址。</p>
<p>        回到<code>anbox/src/anbox/graphics/gl_renderer_server.cpp</code>，初始化OpenGL函数后，会去初始化渲染器，来到了<code>anbox/src/anbox/graphics/emugl/Renderer.cpp</code>的<code>initialize</code>函数，其实就是在display :0上初始化OpenGL ES相关的环境。执行完相关函数后<code>gl_renderer_server</code>的初始化就完成了，回到<code>anbox/src/anbox/cmds/session_manager.cpp</code>，下一步<code>window_manager-&gt;setup()</code>创建本地窗口，其实就是Android窗口，所有Android的画面都会显示在这个窗口上。以单窗口为例，来到<code>anbox/src/anbox/wm/single_window_manager.cpp</code></p>
<pre><code>void SingleWindowManager::setup() {
  if (auto p = platform_.lock()) {
    window_ = p-&gt;create_window(0, window_size_, &quot;Anbox - Android in a Box&quot;);
    if (!window_-&gt;attach())
      WARNING(&quot;Failed to attach window to renderer&quot;);
  } else {
    throw std::runtime_error(&quot;Can't create window as we don't have a platform abstraction&quot;);
  }
}
</code></pre>
<p>        先是创建了一个<code>Window</code>的对象，然后调用这个对象的<code>attach</code>函数，来到<code>anbox/src/anbox/wm/window.cpp</code>:</p>
<pre><code>bool Window::attach() {
  if (!renderer_)
    return false;
  attached_ = renderer_-&gt;createNativeWindow(native_handle());
  return attached_;
}
</code></pre>
<p>        可以看到，这里调用的<code>renderer</code>创建本地窗口。来到<code>anbox/src/anbox/graphics/emugl/Renderer.cpp</code></p>
<pre><code>RendererWindow *Renderer::createNativeWindow(
    EGLNativeWindowType native_window) {
  m_lock.lock();

  auto window = new RendererWindow;
  window-&gt;native_window = native_window;
  window-&gt;surface = s_egl.eglCreateWindowSurface(
      m_eglDisplay, m_eglConfig, window-&gt;native_window, nullptr);
  if (window-&gt;surface == EGL_NO_SURFACE) {
    delete window;
    m_lock.unlock();
    return nullptr;
  }

  if (!bindWindow_locked(window)) {
    s_egl.eglDestroySurface(m_eglDisplay, window-&gt;surface);
    delete window;
    m_lock.unlock();
    return nullptr;
  }

  s_gles2.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                  GL_STENCIL_BUFFER_BIT);
  s_egl.eglSwapBuffers(m_eglDisplay, window-&gt;surface);

  unbind_locked();

  m_nativeWindows.insert({native_window, window});

  m_lock.unlock();

  return window;
}
</code></pre>
<h4 id="2-指令传输与渲染"><a class="header" href="#2-指令传输与渲染">(2) 指令传输与渲染</a></h4>
<h5 id="宿主机端"><a class="header" href="#宿主机端">宿主机端</a></h5>
<p>        上文已经提到，Anbox的入口函数在<code>session manage</code>中 。代码位置<code>anbox/src/anbox/cmds/session_manager.cpp</code>:</p>
<pre><code>auto qemu_pipe_connector =
    std::make_shared&lt;network::PublishedSocketConnector&gt;(
        utils::string_format(&quot;%s/qemu_pipe&quot;, socket_path), rt,
        std::make_shared&lt;qemu::PipeConnectionCreator&gt;(gl_server-&gt;renderer(), rt));
</code></pre>
<p>        Anbox建立了一个名字为qemu_pipe的unix socket服务端,并等待Android端连接。<code>PublishedSocketConnector</code>函数在<code>anbox/src/anbox/network/published_socket_connector.cpp</code>中，构造函数直接调用<code>start_accept</code>函数。</p>
<pre><code>void PublishedSocketConnector::start_accept() {
  auto socket = std::make_shared&lt;boost::asio::local::stream_protocol::socket&gt;(runtime_-&gt;service());

  acceptor_.async_accept(*socket,
                         [this, socket](boost::system::error_code const&amp; err) {
                           on_new_connection(socket, err);
                         });
}
</code></pre>
<p>        当有客户端连接时则调用<code>on_new_connection</code>函数:</p>
<pre><code>void 
PublishedSocketConnector::on_new_connection
(std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp; socket, boost::system::error_code const&amp; err) {
  if (!err)
    connection_creator_-&gt;create_connection_for(socket);

  if (err.value() == boost::asio::error::operation_aborted)
    return;
  start_accept();
}
</code></pre>
<p>        这个函数的先是调用<code>connection_creator</code>中的<code>create_connection_for</code>函数，然后继续监听客户端连接。
这个<code>connection_creator</code>就是<code>session manage </code>中传进来的<code>qemu::PipeConnectionCreator</code>。
查看<code>anbox/src/anbox/qemu/pipe_connection_creator.cpp</code>的<code>create_connection_for</code>函数</p>
<pre><code>void PipeConnectionCreator::create_connection_for(
    std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
        &amp;socket) {
  auto const messenger = std::make_shared&lt;network::LocalSocketMessenger&gt;(socket);
  const auto type = identify_client(messenger);
  auto const processor = create_processor(type, messenger);
  if (!processor)
    BOOST_THROW_EXCEPTION(std::runtime_error(&quot;Unhandled client type&quot;));

  auto const &amp;connection = std::make_shared&lt;network::SocketConnection&gt;(
      messenger, messenger, next_id(), connections_, processor);
  connection-&gt;set_name(client_type_to_string(type));
  connections_-&gt;add(connection);
  connection-&gt;read_next_message();
}
</code></pre>
<p>        先是创建了一个<code>LocalSocketMessenger</code>，用来与客户端通信。然后通过函数identify_client判断客户端的类型，对于渲染来说，类型就是<code>pipe:opengles</code>。接着根据客户端类型创建对应的<code>processor</code>，最后再创建对应的<code>connection</code> 。创建完成后读取客户端消息。在创建<code>processor</code>时，会创建处理OpenGL ES指令的线程，在<code>anbox/src/anbox/graphics/opengles_message_processor.cpp</code>:</p>
<pre><code>OpenGlesMessageProcessor::OpenGlesMessageProcessor(
    const std::shared_ptr&lt;Renderer&gt; &amp;renderer,
    const std::shared_ptr&lt;network::SocketMessenger&gt; &amp;messenger)
    : messenger_(messenger),
      stream_(std::make_shared&lt;BufferedIOStream&gt;(messenger_)) {
  // We have to read the client flags first before we can continue
  // processing the actual commands
  unsigned int client_flags = 0;
  auto err = messenger_-&gt;receive_msg(
      boost::asio::buffer(&amp;client_flags, sizeof(unsigned int)));
  if (err) ERROR(&quot;%s&quot;, err.message());

  render_thread_.reset(RenderThread::create(renderer, stream_.get(), std::ref(global_lock)));
  if (!render_thread_-&gt;start())
    BOOST_THROW_EXCEPTION(
        std::runtime_error(&quot;Failed to start renderer thread&quot;));
}
</code></pre>
<p>        这里会创建一个线程render_thread专门来处理<code>OpenGL ES</code>的指令:</p>
<pre><code>intptr_t RenderThread::main() {
  RenderThreadInfo threadInfo;
  ChecksumCalculatorThreadInfo threadChecksumInfo;

  threadInfo.m_glDec.initGL(gles1_dispatch_get_proc_func, NULL);
  threadInfo.m_gl2Dec.initGL(gles2_dispatch_get_proc_func, NULL);
  initRenderControlContext(&amp;threadInfo.m_rcDec);

  ReadBuffer readBuf(STREAM_BUFFER_SIZE);

  while (true) {
    int stat = readBuf.getData(m_stream);
    if (stat &lt;= 0)
      break;

    bool progress;
    do {
      progress = false;

      std::unique_lock&lt;std::mutex&gt; l(m_lock);

      size_t last =
          threadInfo.m_glDec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        progress = true;
        readBuf.consume(last);
      }

      last =
          threadInfo.m_gl2Dec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        progress = true;
        readBuf.consume(last);
      }

      last = threadInfo.m_rcDec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        readBuf.consume(last);
        progress = true;
      }

    } while (progress);

  }

  threadInfo.m_gl2Dec.freeShader();
  threadInfo.m_gl2Dec.freeProgram();

  // Release references to the current thread's context/surfaces if any
  renderer_-&gt;bindContext(0, 0, 0);
  if (threadInfo.currContext || threadInfo.currDrawSurf || threadInfo.currReadSurf)
    ERROR(&quot;RenderThread exiting with current context/surfaces&quot;);

  renderer_-&gt;drainWindowSurface();
  renderer_-&gt;drainRenderContext();

  return 0;
}
</code></pre>
<pre><code>intptr_t RenderThread::main() {
  RenderThreadInfo threadInfo;
  ChecksumCalculatorThreadInfo threadChecksumInfo;

  threadInfo.m_glDec.initGL(gles1_dispatch_get_proc_func, NULL);
  threadInfo.m_gl2Dec.initGL(gles2_dispatch_get_proc_func, NULL);
  initRenderControlContext(&amp;threadInfo.m_rcDec);

  ReadBuffer readBuf(STREAM_BUFFER_SIZE);

  while (true) {
    int stat = readBuf.getData(m_stream);
    if (stat &lt;= 0)
      break;

    bool progress;
    do {
      progress = false;

      std::unique_lock&lt;std::mutex&gt; l(m_lock);

      size_t last =
          threadInfo.m_glDec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        progress = true;
        readBuf.consume(last);
      }

      last =
          threadInfo.m_gl2Dec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        progress = true;
        readBuf.consume(last);
      }

      last = threadInfo.m_rcDec.decode(readBuf.buf(), readBuf.validData(), m_stream);
      if (last &gt; 0) {
        readBuf.consume(last);
        progress = true;
      }

    } while (progress);

  }

  threadInfo.m_gl2Dec.freeShader();
  threadInfo.m_gl2Dec.freeProgram();

  // Release references to the current thread's context/surfaces if any
  renderer_-&gt;bindContext(0, 0, 0);
  if (threadInfo.currContext || threadInfo.currDrawSurf || threadInfo.currReadSurf)
    ERROR(&quot;RenderThread exiting with current context/surfaces&quot;);

  renderer_-&gt;drainWindowSurface();
  renderer_-&gt;drainRenderContext();

  return 0;
}
</code></pre>
<p>        这个线程里，显示初始化三个解码器，分别是<code>GLESv1Decoder</code>、<code>GLESv2Decoder</code>和<code>renderControl_decoder_context_t</code>，然后根据收到的socket客户端的信息，来分别解析这三种指令。
解码的相关的代码在<code>anbox/external/android-emugl/host/libs</code>，此部分内容是Anbox从<code>Android Emulator</code>中复制而来，在此不再进行讨论。</p>
<h5 id="android端"><a class="header" href="#android端">Android端</a></h5>
<p>        Android端采集OpenGL ES相关的指令，并通过三个对应的编码器将指令传输出来，Anbox就可以实现将Android里的所有OpenGL ES指令在宿主机上执行，从而进行相应的渲染。</p>
<p>        那么Android是如何采集OpenGL ES指令并通过编码器传输出来？在<code>anbox/android/opengl/system/egl/Android.mk</code>可以得知这个文件夹下的源文件会编译为库文件<code>libEGL_emulation.so</code>:</p>
<pre><code>$(call emugl-begin-shared-library,libEGL_emulation)
</code></pre>
<p>        在前文已经介绍过了Android加载OpenGL ES的流程，所以只要将<code>libEGL_emulation.so</code>放在<code>/system/lib64/egl</code>下，Android就会自动去加载该库，并将其作为OpenGL ES的默认库文件，这样Android里所有的OpenGL ES调用都会经过该库。也就是说Android里所有的OpenGL ES相关的指令都可以被收集。
那么，指令又是如何传输出来的呢？在前文中提到，通过<code>egl</code>来调用<code>OpenGL</code>时首先要调用<code>eglInitialize</code>函数进行初始化，在<code>anbox/android/opengl/system/egl/egl.cpp</code>的中<code>eglInitialize</code>函数可以看到：</p>
<pre><code>EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
{
    VALIDATE_DISPLAY(dpy,EGL_FALSE);

    if (!s_display.initialize(&amp;s_eglIface)) {
        return EGL_FALSE;
    }
    if (major!=NULL)
        *major = s_display.getVersionMajor();
    if (minor!=NULL)
        *minor = s_display.getVersionMinor();
    return EGL_TRUE;
}
</code></pre>
<p>        这个函数调用了<code>s_display.initialize(&amp;s_eglIface)</code>，我们来到<code>anbox/android/opengl/system/egl/eglDisplay.cpp的initialize</code>函数。这个函数首先加载了<code>libGLESv1_CM_emulation.so</code>和<code>libGLESv2_emulation.so</code>。也就是<code>OpenGL ES 1.0</code>和<code>OpenGL ES2.0</code>的库。然后在调用<code>get</code>函数:</p>
<pre><code>HostConnection *hcon = HostConnection::get();
</code></pre>
<p>        在<code>anbox/android/opengl/system/OpenglSystemCommon/HostConnection.cpp</code>中可以看到：</p>
<pre><code>HostConnection *HostConnection::get()
{
    /* TODO: Make this configurable with a system property */
    const int useQemuPipe = USE_QEMU_PIPE;

    // Get thread info
    EGLThreadInfo *tinfo = getEGLThreadInfo();
    if (!tinfo) {
        return NULL;
    }

    if (tinfo-&gt;hostConn == NULL) {
        HostConnection *con = new HostConnection();
        if (NULL == con) {
            return NULL;
        }

        if (useQemuPipe) {
            QemuPipeStream *stream = new QemuPipeStream(STREAM_BUFFER_SIZE);
            if (!stream) {
                ALOGE(&quot;Failed to create QemuPipeStream for host connection!!!\n&quot;);
                delete con;
                return NULL;
            }
            if (stream-&gt;connect() &lt; 0) {
                ALOGE(&quot;Failed to connect to host (QemuPipeStream)!!!\n&quot;);
                delete stream;
                delete con;
                return NULL;
            }
            con-&gt;m_stream = stream;
        }
        else /* !useQemuPipe */
        {
            TcpStream *stream = new TcpStream(STREAM_BUFFER_SIZE);
            if (!stream) {
                ALOGE(&quot;Failed to create TcpStream for host connection!!!\n&quot;);
                delete con;
                return NULL;
            }

            if (stream-&gt;connect(&quot;10.0.2.2&quot;, STREAM_PORT_NUM) &lt; 0) {
                ALOGE(&quot;Failed to connect to host (TcpStream)!!!\n&quot;);
                delete stream;
                delete con;
                return NULL;
            }
            con-&gt;m_stream = stream;
        }

        // send zero 'clientFlags' to the host.
        unsigned int *pClientFlags =
                (unsigned int *)con-&gt;m_stream-&gt;allocBuffer(sizeof(unsigned int));
        *pClientFlags = 0;
        con-&gt;m_stream-&gt;commitBuffer(sizeof(unsigned int));

  ALOGD(&quot;HostConnection::get() New Host Connection established %p, tid %d\n&quot;, con, gettid());
        tinfo-&gt;hostConn = con;
    }
    return tinfo-&gt;hostConn;
}
</code></pre>
<p>        可知Anbox用的是<code>qemuPipe</code>，先创建<code>QemuPipeStream</code>，再进行<code>stream-&gt;connect()</code>。<br />
        查看<code>anbox/android/opengl/system/OpenglSystemCommon/QemuPipeStream.cpp</code>：</p>
<pre><code>int QemuPipeStream::connect(void)
{
    m_sock = qemu_pipe_open(&quot;opengles&quot;);
    if (!valid()) return -1;
    return 0;
}
</code></pre>
<p>        在connect的时候会以&quot;<code>opengles</code>&quot;为标志连接<code>qemu_pipe</code>，也就与前文所讲到Anbox创建的<code>unix socket</code>中的<code>pipe:opengles</code>对应上了。这样Android端与宿主机端就连接上了，然后只需要通过这个通道将Android里的OpenGL ES指令传输到宿主机端，就可以实现Android内所有APP的渲染了。</p>
<h4 id="3-宿主机渲染器"><a class="header" href="#3-宿主机渲染器">(3) 宿主机渲染器</a></h4>
<p>        上文提到当Anbox获得Android的OpenGL ES指令后，会将该指令转换为协议流发送给理解协议格式的特殊的渲染库或进程，流程如图所示：</p>
<center><img src=images/render/渲染流程图.png></center>
<center>图3.10 渲染流程图</center>
<p>宿主机渲染器库位于 <code>$ANDROID/external/qemu/android/android-emugl/host/libs/libOpenglRender</code> 下，它提供了一个由 <code>$$ANDROID/external/qemu/android/android-emugl/host/libs/libOpenglRender/render_api.h</code> 下（比如用于模拟器）的头文件描述的接口。</p>
<p>        简而言之，渲染库负责以下内容：</p>
<ul>
<li>
<p>提供一个虚拟的离屏视频 Surface 用于在运行时渲染所有的东西。它的维度必须通过在库初始化之后，紧接着调用 <code>initOpenglRender()</code> 来固定。</p>
</li>
<li>
<p>提供一种方式在一个宿主机应用程序的 UI 中显示虚拟的视频 Surface。这通过调用 <code>createOpenGLSubWindow()</code> 完成，它接收 window ID 或父 window 的句柄，一些显示维度和一个旋转角度作为参数。这允许 Surface 在显示时被放缩/旋转，甚至是在视频 surface 的维度没有改变时。</p>
</li>
<li>
<p>提供一种方式监听从客户系统进入的 EGL/GLES 命令。这通过给 <code>initOpenglRender()</code> 提供一个所谓的 “端口号” 完成。</p>
<p>默认情况下，端口号对应一个渲染器将绑定和监听的本地 TCP 端口号。到该端口的每个新连接将对应创建一个新的客户系与统宿主系统间的连接，每个这样的连接对应客户系统中的一个不同的线程。</p>
<p>处于性能原因，监听 Unix sockets（在 Linux 或 OS X 上），或 Win32 命名管道（在 Windows 上）都是可能的。为了做到这一点，必须在库初始化（比如<code>initLibrary()</code>）和构建（比如 <code>initOpenglRender()</code>）之间调用 <code>setStreamType()</code>。</p>
<p>注意在这些模式中，端口号依然被用于区分多个模拟器实例。这些细节通常由模拟器代码处理。</p>
</li>
</ul>
<p>        注意更早的接口版本允许渲染器库的客户端提供它自己的 <code>IOStream</code> 实现。然而，因为许多原因这不是很方便。如果它有意义，这也许可以再次做到，但现在的性能数字是相当好的。</p>
<h3 id="324-opengl-es翻译opengl"><a class="header" href="#324-opengl-es翻译opengl">3.2.4 OpenGL ES—翻译—OpenGL</a></h3>
<p>        当渲染器从协议流解码 EGL/GLES 命令后，会根据指令的类型派发给适当的翻译器库，流程如图3.11所示：</p>
<center><img src=images/render/host_translator.jpg></center>
<center>图3.11 指令翻译流</center>
<p>        事实上，协议流是双向流动的，尽管大多数命令使得数据从客户系统传送到宿主机。但完整流程应该是如图3.12所示：</p>
<center><img src=images/render/翻译流完整流程.jpg></center>
<center>图3.12 翻译流完整流程</center>
<h4 id="1-翻译器库"><a class="header" href="#1-翻译器库">(1) 翻译器库</a></h4>
<p>        Anbox提供了三个宿主端的翻译器库：</p>
<pre><code>   libEGL_translator       -&gt; EGL 1.2 翻译
   libGLES_CM_translator   -&gt; GLES 1.1 翻译
   libGLES_V2_translator   -&gt; GLES 2.0 翻译
</code></pre>
<p>        这些库的源码位于 Android 源码树的下列路径下：</p>
<pre><code>   $ANDROID/external/qemu/android/android-emugl/host/libs/Translator/EGL
   $ANDROID/external/qemu/android/android-emugl/host/libs/Translator/GLES_CM
   $ANDROID/external/qemu/android/android-emugl/host/libs/Translator/GLES_V2
</code></pre>
<p>        翻译器库也使用如下目录中定义的通用的程序：</p>
<pre><code> $ANDROID/external/qemu/android/android-emugl/host/libs/Translator/GLcommon
</code></pre>
<p>        当指令经过翻译程序翻译完成后，Anbox便可调用Linux下的OpenGL库进行图形渲染。</p>
<h3 id="325-参考资料"><a class="header" href="#325-参考资料">3.2.5 参考资料</a></h3>
<ol>
<li>Android函数的调用过程,Android OpenGL库加载和调用过程  链接:(https://blog.csdn.net/weixin_39880895/article/details/117314150)</li>
<li>Android模拟器图形绘原理(二十二)  链接:(https://unbroken.blog.csdn.net/article/details/119487447?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-119487447-blog-107620008.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-119487447-blog-107620008.pc_relevant_aa2&amp;utm_relevant_index=1)</li>
<li>Android 硬件 OpenGL ES 模拟设计概述  链接:(https://blog.csdn.net/tq08g2z/article/details/78004065)</li>
<li>掌握Android图像显示原理(中) 链接:(https://blog.csdn.net/tyuiof/article/details/108675978)</li>
<li>Android EGL 一、初始化配置  链接:(https://blog.csdn.net/kongbaidepao/article/details/108550631)</li>
<li>Android 图形驱动初始化  链接:(https://blog.csdn.net/tq08g2z/article/details/77991008)</li>
<li>Android SurfaceFlinger之OpenGL库加载过程  链接:(https://www.cnblogs.com/ztguang/p/12644892.html)</li>
<li>Anbox源码分析（一） 链接: (https://blog.csdn.net/qq_36383272/article/details/105163579)</li>
<li>Anbox源码分析（二）——Anbox渲染原理  链接:(https://blog.csdn.net/qq_36383272/article/details/105680570)</li>
<li>Anbox源码分析（三）——Anbox渲染原理(源码分析)  链接:(https://blog.csdn.net/qq_36383272/article/details/105957455)</li>
<li>Anbox源码分析（四）——Anbox渲染原理(源码分析)  链接:(https://blog.csdn.net/qq_36383272/article/details/107919857)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="33-anbox-容器管理服务"><a class="header" href="#33-anbox-容器管理服务">3.3 Anbox 容器管理服务</a></h2>
<p>为便于后来者学习，特此收纳本资料：http://hanpfei.github.io/2017/12/01/anbox_container_manager_service/</p>
<h3 id="331-anbox-安装过程分析"><a class="header" href="#331-anbox-安装过程分析">3.3.1 Anbox 安装过程分析</a></h3>
<p>        Anbox 是在像 Ubuntu 这样的普通 GNU/Linux 系统上，基于容器启动完整 Android 系统的方案。</p>
<p>        当前安装过程由多个步骤组成，这些步骤将向主机系统中添加额外的组件，这些组件包括：</p>
<ul>
<li>由于没有发行版内核同时启用 binder 和 ashmem，因此需要它们的源码树之外的内核模块</li>
<li>为 <code>/dev/binder</code> 和 <code>/dev/ashmem</code> 设置正确权限的 udev 规则</li>
<li>upstart 或 systemd 任务，用于作为用户会话的一部分启动 Anbox 会话管理器。</li>
</ul>
<p>        为了使 Anbox 的安装过程尽可能简单，Anbox 官方已经在一个 snap (参考 <a href="https://snapcraft.io/">https://snapcraft.io</a>) 中打包了必须的步骤，称为 “anbox-installer”。这个安装器将执行所有必须的步骤。可以通过运行如下命令，在系统上安装 Anbox 提供对 snaps 的支持：</p>
<pre><code>$ snap install --classic anbox-installer
</code></pre>
<p>        另外，还可以通过如下命令获得安装器脚本：</p>
<pre><code>$ wget https://raw.githubusercontent.com/anbox/anbox-installer/master/installer.sh -O anbox-installer
</code></pre>
<p>        要通过 Anbox 的安装器脚本安装 Anbox 的话，简单地调用即可：</p>
<pre><code>$ anbox-installer
</code></pre>
<p>        这将指导完成安装过程。</p>
<p>        <code>anbox-installer</code> 安装器脚本的实现是这样的：</p>
<pre><code>#!/bin/bash
echo &quot;Anbox (Android in a Box) - Installer&quot;
echo
echo
echo &quot;IMPORTANT: THIS IS ALPHA LEVEL SOFTWARE. EXPECT INSTABILITY AND&quot;
echo &quot;           BUGS !!!!!&quot;
echo
echo &quot;IMPORTANT: ALSO PLEASE BE AWARE THAT WE DON'T PROVIDE FULL&quot;
echo &quot;           CONFINEMENT FOR THE SNAP YET !!!!&quot;
echo
echo
echo &quot;PLEASE NOTE: This script will require root access on your system&quot;
echo &quot;to install all necessary things. It will prompt you to enter your&quot;
echo &quot;password when required.&quot;
echo
echo
if [ &quot;$(id -u)&quot; -eq 0 ] ; then
	echo &quot;ERROR: Don't run the anbox-installer as root or via sudo. Simply&quot;
	echo &quot;       invoke it with your regular user. The script will use sudo&quot;
	echo &quot;       on its own when needed.&quot;
	exit 1
fi
if ! uname -a | grep -q x86_64 ; then
	echo &quot;ERROR: We only have support for x86 64 bit devices today. As&quot;
	echo &quot;       your system has a different architecture we can't&quot;
	echo &quot;       support it yet.&quot;
	exit 1
fi
SUPPORTED_DISTROS=(&quot;Ubuntu&quot; &quot;LinuxMint&quot; &quot;neon&quot; &quot;elementary&quot; &quot;Zorin&quot;)
DISTRIB_ID=&quot;$(lsb_release -i -s)&quot;
function contains() {
	local n=$#
	local value=${!n}
	for ((i=1;i &lt; $#;i++)) {
		if [ &quot;${!i}&quot; == &quot;${value}&quot; ]; then
			echo &quot;y&quot;
			return 0
		fi
	}
	return 1
}
if [ &quot;$(contains &quot;${SUPPORTED_DISTROS[@]}&quot; &quot;$DISTRIB_ID&quot;)&quot; != &quot;y&quot; ]; then
	echo &quot;ERROR: You are running the installer on an unsupported distribution.&quot;
	echo &quot;       At the moment we only support the following distributions:&quot; 
	echo
	printf &quot;%s, &quot; &quot;${SUPPORTED_DISTROS[@]}&quot; | cut -d &quot;,&quot; -f 1-${#SUPPORTED_DISTROS[@]}
	echo
	echo &quot;If your distribution is in the list but you still see this message, open&quot;
	echo &quot;an issue here: https://github.com/anbox/anbox-installer&quot;
	exit 1
fi
echo
echo &quot;What do you want to do?&quot;
echo
echo &quot; 1. Install Anbox&quot;
echo &quot; 2. Uninstall Anbox&quot;
echo
echo &quot;Please enter your choice [1-2]: &quot;
read -r action
echo
echo
[[ -n &quot;$(which snap)&quot; ]] || {
	echo &quot;ERROR: Your system does not support snaps. Please have a look&quot;
	echo &quot;       at https://snapcraft.io/ to find out how you can add&quot;
	echo &quot;       support for snaps on your system.&quot;
	exit 1
}
uninstall() {
	set -x
	sudo snap remove anbox
	if [ -e /etc/apt/sources.list.d/morphis-ubuntu-anbox-support-xenial.list ]; then
		ppa_purged_installed=0
		if ! dpkg --get-selections | grep -q ppa-purge ; then
			sudo apt install -y ppa-purge
			ppa_purged_installed=1
		fi
		sudo apt install -y ppa-purge
		sudo ppa-purge -y ppa:morphis/anbox-support
		if [ &quot;$ppa_purged_installed&quot; -eq 1 ]; then
			sudo apt purge ppa-purge
		fi
	fi
	set +x
}
if [ &quot;$action&quot; == &quot;2&quot; ]; then
	echo &quot;This will now remove the Android in a Box runtime environment&quot;
	echo &quot;from your device. Do you really want this?&quot;
	echo
	echo &quot;Please be aware that this will also remove any user data&quot;
	echo &quot;stored inside the runtime environment.&quot;
	echo
	echo &quot;Please type 'I AGREE' followed by pressing ENTER to continue&quot;
	echo &quot;or type anything else to abort:&quot;
	read -r input
	if [ &quot;$input&quot; != &quot;I AGREE&quot; ]; then
		exit 1
	fi
	echo
	uninstall
	echo
	echo &quot;Successfully removed anbox!&quot;
	echo
	exit 0
fi
if [ &quot;$action&quot; != &quot;1&quot; ]; then
	echo &quot;ERROR: Invalid option selected!&quot;
	exit 1
fi
echo &quot;This is the installer for the anbox runtime environment. It will&quot;
echo &quot;install certain things on your system to ensure all requirements&quot;
echo &quot;are available for anbox to work correctly.&quot;
echo
echo &quot;In summary we will install the following things:&quot;
echo
echo &quot; * Add the anbox-support ppa ppa:morphis/anbox-support to the&quot;
echo &quot;   host system&quot;
echo &quot; * Install the anbox-modules-dkms deb package from the ppa&quot;
echo &quot;   which will add kernel modules for ashmem and binder which are&quot;
echo &quot;   required for the Android container to work.&quot;
echo &quot; * Configure binder and ashmem kernel modules to be loaded&quot;
echo &quot;   automatically on boot.&quot;
echo &quot; * Install the anbox-common package from the ppa which will&quot;
echo &quot;   - Add an upstart job for the current user $USER which will&quot;
echo &quot;     start the anbox runtime on login.&quot;
echo &quot;   - Add a X11 session configuration file to allow the system&quot;
echo &quot;     application launcher (Unity7, Gnome Shell, ..) to find&quot;
echo &quot;     available Android applications.&quot;
echo
echo &quot;Please type 'I AGREE' followed by pressing ENTER to continue&quot;
echo &quot;or type anything else to abort:&quot;
read -r input
if [ &quot;$input&quot; != &quot;I AGREE&quot; ]; then
	exit 1
fi
echo
echo
echo &quot;Starting installation process ...&quot;
echo
cleanup() {
	local err=$?
	trap - EXIT
	echo &quot;ERROR: Installation failed. Removing all parts of Anbox again.&quot;
	uninstall
	exit $err
}
trap cleanup HUP PIPE INT QUIT TERM EXIT
set -ex
sudo add-apt-repository -y 'ppa:morphis/anbox-support'
# Users tend to have APT repositories installed which are not properly
# authenticated and because of that `apt update` will fail. We ignore
# this and proceed with the package installation. If the installation
# of a specific package fails this will indicate our point of abort.
sudo apt update || true
sudo apt install -y anbox-common
# Install kernel drivers only if necessary and let the user use the
# ones build into his kernel otherwise.
if [ -c /dev/binder ] &amp;&amp; [ -c /dev/ashmem ]; then
    echo &quot;Android binder and ashmem seems to be already enabled in kernel.&quot;;
else
    sudo apt install -y linux-headers-generic anbox-modules-dkms
    sudo modprobe binder_linux
    sudo modprobe ashmem_linux
fi
if snap info anbox | grep -q &quot;installed:&quot; ; then
	 sudo snap refresh --edge anbox || true
else
	 sudo snap install --edge --devmode anbox
fi
set +x
echo
echo &quot;Done!&quot;
echo
echo &quot;To ensure all changes made to your system you should now reboot&quot;
echo &quot;your system. If you don't do this no Android applications will&quot;
echo &quot;show up in the system application launcher.&quot;
trap - EXIT
</code></pre>
<p>        <code>anbox-installer</code> 安装器脚本中的 echo 打印输出有点多，同时这个脚本还提供了移除 anbox 的功能。安装 Anbox 的工作主要由如下这几行代码完成：</p>
<pre><code>sudo add-apt-repository -y 'ppa:morphis/anbox-support'
. . . . . .
sudo apt update || true
sudo apt install -y anbox-common
# Install kernel drivers only if necessary and let the user use the
# ones build into his kernel otherwise.
if [ -c /dev/binder ] &amp;&amp; [ -c /dev/ashmem ]; then
    echo &quot;Android binder and ashmem seems to be already enabled in kernel.&quot;;
else
    sudo apt install -y linux-headers-generic anbox-modules-dkms
    sudo modprobe binder_linux
    sudo modprobe ashmem_linux
fi
if snap info anbox | grep -q &quot;installed:&quot; ; then
	 sudo snap refresh --edge anbox || true
else
	 sudo snap install --edge --devmode anbox
fi
set +x
. . . . . .
trap - EXIT
</code></pre>
<p>        这段代码，通过三个步骤完成 Anbox 的安装。</p>
<p>        第一步，安装 <code>anbox-common</code></p>
<pre><code>sudo add-apt-repository -y 'ppa:morphis/anbox-support'
. . . . . .
sudo apt update || true
sudo apt install -y anbox-common
</code></pre>
<p>        <code>anbox-common</code> 包的安装的文件如下：</p>
<pre><code>$ dpkg -L anbox-common
/.
/etc
/etc/X11
/etc/X11/Xsession.d
/etc/X11/Xsession.d/68anbox
/usr
/usr/share
/usr/share/doc
/usr/share/doc/anbox-common
/usr/share/doc/anbox-common/README.Debian
/usr/share/doc/anbox-common/changelog.gz
/usr/share/doc/anbox-common/copyright
/usr/src
</code></pre>
<p>        第二步，安装 binder 和 ashmem 驱动</p>
<pre><code>sudo apt install -y linux-headers-generic anbox-modules-dkms
sudo modprobe binder_linux
sudo modprobe ashmem_linux
</code></pre>
<p>        第三步，通过 snap 的方式安装 Anbox 包</p>
<pre><code>sudo snap install --edge --devmode anbox
</code></pre>
<p>        Anbox 包通过 snap 的方式进行安装。</p>
<h3 id="332-anbox-容器管理服务"><a class="header" href="#332-anbox-容器管理服务">3.3.2 Anbox 容器管理服务</a></h3>
<p>        整体看来，Anbox 的安装过程安装了两个组件，一是 binder 和 ashmem 内核驱动；二是 Anbox，Anbox 又由 anbox-common 和 anbox snap 组成。</p>
<p>通过如下命令可以看到Anbox snap 的信息：</p>
<pre><code>$ snap info anbox
name:      anbox
summary:   Android in a Box
publisher: morphis
description: |
  Runtime for Android applications which runs a full Android system
  in a container using Linux namespaces (user, ipc, net, mount) to
  separate the Android system fully from the host.
snap-id: Nr9K6UJaIOD8wHpDEQl16nabFFt9LLEQ
commands:
  - anbox
  - anbox.collect-bug-info
services:
  anbox.container-manager: simple, enabled, inactive
tracking:                  edge
installed:                 3-7266fe2 (65) 361MB devmode
refreshed:                 2017-11-17 21:37:23 +0800 CST
channels:                                 
  stable:                  –                    
  candidate:               –                    
  beta:                    1-dev     (15) 357MB devmode
  edge:                    3-7266fe2 (65) 361MB devmode
</code></pre>
<p>        Anbox 向主机系统中安装了 2 个命令，<code>anbox</code> 和 <code>anbox.collect-bug-info</code>，以及一个 service，<code>anbox.container-manager</code>，即 Anbox 的容器管理器服务。</p>
<p>        通过 Anbox 安装器安装 Anbox 之后，service 会自动启动。通过如下命令可以查看这个服务的当前状态：</p>
<pre><code>$ sudo systemctl status snap.anbox.container-manager
● snap.anbox.container-manager.service - Service for snap application anbox.container-manager
   Loaded: loaded (/etc/systemd/system/snap.anbox.container-manager.service; enabled; vendor preset: enabled)
   Active: active (running) since 五 2017-12-01 09:55:46 CST; 3min 54s ago
  Process: 25619 ExecStop=/usr/bin/snap run --command=stop anbox.container-manager (code=exited, status=0/SUCCESS)
 Main PID: 30438 (anbox)
    Tasks: 10
   Memory: 1.8M
      CPU: 74ms
   CGroup: /system.slice/snap.anbox.container-manager.service
           ├─30438 /snap/anbox/65/usr/bin/anbox container-manager --data-path=/var/snap/anbox/common/ --android-image=/snap/anbox/
           └─30644 [lxc monitor] /var/snap/anbox/common/containers default
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + [ ! -e /snap/anbox/65/android.img ]
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + start
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + mkdir -p /var/snap/anbox/common/lxc
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + /snap/anbox/65/bin/anbox-bridge.sh start
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + echo Y
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + tee /sys/module/fuse/parameters/userns_mounts
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: Y
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + AA_EXEC=/snap/anbox/65/usr/sbin/aa-exec -p unconfined --
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + [ ! -d /sys/kernel/security/apparmor ]
12月 01 09:55:46 ThundeRobot anbox.container-manager[30438]: + exec /snap/anbox/65/usr/sbin/aa-exec -p unconfined -- /snap/anbox/65

</code></pre>
<p>        当 Anbox 的容器管理服务正常运行时，通过在应用列表中，点击 Anbox 应用，如下图这样：</p>
<p><img src="images/anbox/1315506-a12d2c77565c111e.png" alt="" /></p>
<center>图3.13 Anbox启动 </center>
<p>        可以启动 Anbox 会话。当 Anbox 的容器管理服务起动时，它会监听一个 Unix 域 Socket，<code>/run/anbox-container.socket</code>。（这个地址在 <code>anbox/src/anbox/container/service.cpp</code> 文件的 <code>Service::create()</code> 函数中，从 <code>anbox::SystemConfiguration::container_socket_path()</code> 获得）。</p>
<p>        当启动 Anbox 应用，即会话管理器时，它会通过 Unix 域 Socket 与容器管理服务建立连接。容器管理服务接收到连接，且容器还没有启动时，它会挂载 Android 系统镜像，起动 LXC 容器，并在容器内起动 Android 系统。</p>
<p>        同时会话管理器与主机系统上的 ADB 服务建立连接。如：</p>
<pre><code>$ ps -aux | grep anbox
hanpfei+ 15883  3.3  1.0 3024640 175500 ?      Sl   19:01   0:34 /usr/bin/python3 /usr/bin/remarkable /home/hanpfei0306/data/MyProjects/hanpfei-documents/source/_posts/anbox_container_manager_service.md
root     16732  0.1  0.0 569980 12288 ?        Ssl  19:17   0:00 /snap/anbox/x1/usr/bin/anbox container-manager --data-path=/var/snap/anbox/common/ --android-image=/snap/anbox/x1/android.img --daemon
hanpfei+ 16765  4.5  0.2 335372 44676 ?        Sl   19:17   0:00 /snap/anbox/x1/usr/bin/anbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity
root     16794  0.0  0.0  36776  3692 ?        Ss   19:17   0:00 /snap/anbox/current/libexec/lxc/lxc-monitord /var/snap/anbox/common/containers 14
hanpfei+ 16917  0.0  0.2 1281208 42556 ?       Sl   19:18   0:00 /snap/anbox/x1/usr/bin/anbox session-manager
root     16931  0.0  0.0 576280  8216 ?        Ss   19:18   0:00 [lxc monitor] /var/snap/anbox/common/containers default
100000   16940  0.0  0.0   7920  2540 ?        Ss   19:18   0:00 /system/bin/sh /anbox-init.sh
100000   16999  0.0  0.0  16472  4068 ?        Sl   19:18   0:00 /system/bin/anboxd
hanpfei+ 17087  0.0  0.0  19300   936 pts/2    R+   19:18   0:00 grep --color=auto anbox
$ adb devices
List of devices attached
emulator-5558	device
$ lsof -i | grep adb
adb       30288 hanpfei0306    6u  IPv4 23788668      0t0  TCP localhost:5037 (LISTEN)
adb       30288 hanpfei0306    7u  IPv4 27391368      0t0  TCP localhost:42048-&gt;localhost:5559 (ESTABLISHED)
$ lsof -i | grep 42048
anbox     16917 hanpfei0306   29u  IPv4 27385836      0t0  TCP localhost:5559-&gt;localhost:42048 (ESTABLISHED)
adb       30288 hanpfei0306    7u  IPv4 27391368      0t0  TCP localhost:42048-&gt;localhost:5559 (ESTABLISHED)
</code></pre>
<p>        此时可以通过 <code>adb</code> 命令查看 Anbox 启动的 Android 系统的状况，如下面这样：</p>
<pre><code>$ adb devices
List of devices attached
emulator-5558	device
$ adb logcat
--------- beginning of system
12-01 01:57:25.245    16    16 I vold    : Vold 3.0 (the awakening) firing up
12-01 01:57:25.245    16    16 V vold    : Detected support for: ext4 vfat
12-01 01:57:25.260    16    16 E vold    : Failed to open default fstab /fstab.goldfish: Operation not permitted
12-01 01:57:25.260    16    16 E vold    : Error reading configuration... continuing anyways: Operation not permitted
12-01 01:57:25.264    16    25 D vold    : e4crypt_init_user0
12-01 01:57:25.264    16    25 D vold    : e4crypt_prepare_user_storage for volume null, user 0, serial 0, flags 1
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/system/users/0
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/misc/profiles/cur/0
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/misc/profiles/cur/0/foreign-dex
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/system_de/0
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/misc_de/0
12-01 01:57:25.264    16    25 D vold    : Preparing: /data/user_de/0
</code></pre>
<p>        当 Anbox 起动的 Android 系统内所需的应用程序都启动完毕时，通过 Anbox 应用将可以看到 Android 系统的桌面，可以看到 Android 系统中的应用，如下图：</p>
<p><img src="images/anbox/1315506-dc70cce88058c6a8.png" alt="1315506-dc70cce88058c6a8" /></p>
<center>图3.14 Anbox运行 </center>
<p>        Anbox 项目写了一个名为 <code>org.anbox.appmgr</code> 的 Java 应用程序，用以替代原始 Android 系统中的 Launcher，以展示已安装应用列表。随后就可以像操作普通的桌面 Linux 系统中的应用那样操作 Android 内的应用了。</p>
<p>        此时，查看主机 Linux 系统中与 Anbox 有关的进程，可以看到如下这些：</p>
<pre><code>$ ps -aux | grep anbox
root     30438  0.0  0.0 373372 12144 ?        Ssl  09:55   0:00 /snap/anbox/65/usr/bin/anbox container-manager --data-path=/var/snap/anbox/common/ --android-image=/snap/anbox/65/android.img --daemon
hanpfei+ 30630  0.6  1.7 2770120 280580 ?      Sl   09:57   0:07 /snap/anbox/65/usr/bin/anbox session-manager
root     30644  0.0  0.0 379672  8016 ?        Ss   09:57   0:00 [lxc monitor] /var/snap/anbox/common/containers default
100000   30652  0.0  0.0   7920  6516 ?        Ss   09:57   0:00 /system/bin/sh /anbox-init.sh
100000   30711  0.0  0.0  16728  9240 ?        Sl   09:57   0:00 /system/bin/anboxd
110000   31209  0.0  0.7 1074676 116412 ?      Sl   09:57   0:00 org.anbox.appmgr
</code></pre>
<p>        进程号为 30438 和 30644 的两个进程组成了容器管理器服务。进程号为 30630 的进程为我们启动的 Anbox 应用。进程号为 30652，30711，和 31209 的几个进程，实际为 Anbox 启动的容器中运行的 Android 系统的进程。Anbox 的整体设计可以参考 <a href="https://www.wolfcstech.com/2017/11/28/Anbox/">Anbox</a> 一文。</p>
<h3 id="333-anbox-snap"><a class="header" href="#333-anbox-snap">3.3.3 Anbox snap</a></h3>
<p>        Anbox 应用通过 snap 方式打包，下载 Anbox 的<a href="https://github.com/anbox/anbox.git">源码</a>，并在源码目录下执行 snapcraft，可以生成 anbox 的 .snap 文件：</p>
<pre><code>$ mkdir android-images
$ cp /path/to/android.img android-images/android.img
$ snapcraft
</code></pre>
<p>        生成的 .snap 文件还可以通过如下命令进行安装：</p>
<pre><code>$ snap install --dangerous --devmode anbox_3-7266fe2_amd64.snap

</code></pre>
<p>        通过 Anbox 的 <code>snapcraft.yaml</code> 文件，可以对 Anbox 运行时、命令和服务有更深入的了解。Anbox 的 <code>snapcraft.yaml</code> 文件长这样：</p>
<pre><code>name: anbox
version: 3
version-script: |
  if [ &quot;$SNAPCRAFT_GRADE&quot; = &quot;stable&quot; ]; then
    echo $SNAPCRAFT_PROJECT_VERSION
  else
    echo $SNAPCRAFT_PROJECT_VERSION-$(git rev-parse --short HEAD)
  fi
summary: Android in a Box
description: |
  Runtime for Android applications which runs a full Android system
  in a container using Linux namespaces (user, ipc, net, mount) to
  separate the Android system fully from the host.
confinement: devmode
grade: devel
slots:
  # Depending on in which environment we're running we either need
  # to use the system or session DBus so we also need to have one
  # slot for each.
  dbus-session:
    interface: dbus
    bus: system
    name: org.anbox
  dbus-system:
    interface: dbus
    bus: system
    name: org.anbox
apps:
  anbox:
    command: bin/anbox-wrapper.sh
  container-manager:
    command: bin/container-manager.sh start
    stop-command: bin/container-manager.sh stop
    daemon: simple
  collect-bug-info:
    command: bin/collect-bug-info.sh
parts:
  android-images:
    plugin: dump
    # This needs to be any directory but not the root one as if we use
    # it we get superious permissions errors with the copied .git tree
    source: data
    build-packages:
      - wget
    install: |
      LOCAL_IMAGE=$SNAPCRAFT_PART_INSTALL/../../../android-images/android.img
      if [ -f $LOCAL_IMAGE ]; then
        echo &quot;Using local image $LOCAL_IMAGE&quot;
        cp $LOCAL_IMAGE $SNAPCRAFT_PART_INSTALL/android.img
      else
        IMAGE_PATH=
        IMAGE_NAME=
        ARCH=$(uname -m)
        case &quot;$ARCH&quot; in
          x86_64)
            IMAGE_PATH=&quot;2017/07/13&quot;
            IMAGE_NAME=&quot;android_3_amd64.img&quot;
            ;;
          arm*)
            IMAGE_PATH=&quot;2017/06/12&quot;
            IMAGE_NAME=&quot;android_1_armhf.img&quot;
            ;;
          *)
            echo &quot;ERROR: Unknown architecture $ARCH&quot;
            exit 1
            ;;
        esac
        # FIXME: downloading with a source: field doesn't work as snapcraft
        # expects the downloaded file to be an archive it can extract.
        echo &quot;Downloading image...&quot;
        wget http://build.anbox.io/android-images/$IMAGE_PATH/$IMAGE_NAME
        mv $IMAGE_NAME $SNAPCRAFT_PART_INSTALL/android.img
      fi
    prime:
      - android.img
  anbox-common:
    plugin: dump
    source: scripts
    organize:
      snap-wrapper.sh: bin/anbox-wrapper.sh
      container-manager.sh: bin/container-manager.sh
      anbox-bridge.sh: bin/anbox-bridge.sh
      collect-bug-info.sh: bin/collect-bug-info.sh
    prime:
      - bin/anbox-bridge.sh
      - bin/anbox-wrapper.sh
      - bin/container-manager.sh
      - bin/collect-bug-info.sh
  apparmor:
    plugin: nil
    stage-packages:
      - apparmor
  lxc:
    source: https://github.com/lxc/lxc
    source-type: git
    source-tag: lxc-2.0.7
    build-packages:
      - libapparmor-dev
      - libcap-dev
      - libgnutls28-dev
      - libseccomp-dev
      - pkg-config
    plugin: autotools
    configflags:
      - --disable-selinux
      - --disable-python
      - --disable-lua
      - --disable-tests
      - --disable-examples
      - --disable-doc
      - --disable-api-docs
      - --disable-bash
      - --disable-cgmanager
      - --disable-apparmor
      - --disable-seccomp
      - --enable-capabilities
      - --with-rootfs-path=/var/snap/anbox/common/lxc/
      - --libexecdir=/snap/anbox/current/libexec/
    organize:
      snap/anbox/current/libexec: libexec
    prime:
      - lib/liblxc.so.1
      - lib/liblxc.so.1.2.0
      - libexec/lxc/lxc-monitord
      - bin/lxc-start
      - bin/lxc-stop
      - bin/lxc-info
      - bin/lxc-attach
      - bin/lxc-ls
      - bin/lxc-top
  anbox:
    plugin: cmake
    after:
      - lxc
    source: .
    configflags:
      # FIXME: Anbox currently has some paths with hard coded prefixes. Once
      # that is fixed we can avoid using a prefix here.
      - -DCMAKE_INSTALL_PREFIX:PATH=/usr
      - -DANBOX_VERSION=$SNAPCRAFT_PROJECT_VERSION
    build-packages:
      - build-essential
      - cmake
      - cmake-data
      - cmake-extras
      - debhelper
      - dbus
      - google-mock
      - libboost-dev
      - libboost-filesystem-dev
      - libboost-log-dev
      - libboost-iostreams-dev
      - libboost-program-options-dev
      - libboost-system-dev
      - libboost-test-dev
      - libboost-thread-dev
      - libcap-dev
      - libdbus-1-dev
      - libdbus-cpp-dev
      - libegl1-mesa-dev
      - libgles2-mesa-dev
      - libglib2.0-dev
      - libglm-dev
      - libgtest-dev
      - libprotobuf-dev
      - libproperties-cpp-dev
      - libsdl2-dev
      - libsdl2-image-dev
      - pkg-config
      - protobuf-compiler
    stage-packages:
      - libegl1-mesa
      - libgles2-mesa
      - libgl1-mesa-glx
      - libsdl2-2.0-0
      - libsdl2-gfx-1.0-0
    install: |
      make test
    prime:
      - usr/bin/anbox
      - usr/share/anbox
      - usr/lib/*-linux-*/
</code></pre>
<p>        从 Anbox 的 <code>snapcraft.yaml</code> 文件中可以看到，Anbox snap 安装的几个命令和服务，是一些脚本：</p>
<pre><code>apps:
  anbox:
    command: bin/anbox-wrapper.sh
  container-manager:
    command: bin/container-manager.sh start
    stop-command: bin/container-manager.sh stop
    daemon: simple
  collect-bug-info:
    command: bin/collect-bug-info.sh
</code></pre>
<p>        Anbox snap 主要由这几部分组成：</p>
<ul>
<li>
<p>Android 系统镜像，先找本地的 <code>android-images/android.img</code>，如果找不到，就根据主机系统的 CPU 架构，从远端下载</p>
</li>
<li>
<p>anbox-common，主要是一些脚本，提供 Anbox snap 的命令和服务，由 <code>source:</code> 行可以看到这些脚本都位于源码目录的 <code>scripts</code> 子目录下</p>
</li>
<li>
<p>apparmor，从 Ubuntu 的 APT 源获得</p>
</li>
<li>
<p>lxc，用于做容器管理，从 GitHub 获得源码，并由 tag 为 lxc-2.0.7 的版本编译生成</p>
</li>
<li>
<p>Anbox 二进制可执行程序，通过 cmake 编译生成，如：</p>
<pre><code>$ git clone https://github.com/anbox/anbox.git
$ cd anbox
$ mkdir build
$ cd build
$ cmake ..
$ makexxxxxxxxxx1 1$ git clone https://github.com/anbox/anbox.git2$ cd anbox3$ mkdir build4$ cd build5$ cmake ..6$ make
</code></pre>
</li>
</ul>
<p>        还可以通过如下命令编译带符号的 Debug 版 anbox 二进制可执行程序：</p>
<pre><code>$ mkdir Debug
$ cd Debug
$ cmake -DCMAKE_BUILD_TYPE=Debug ..
$ make
</code></pre>
<p>        或 Release 版：</p>
<pre><code>$ mkdir Release
$ cd Release
$ cmake -DCMAKE_BUILD_TYPE=Release ..
$ make
</code></pre>
<p>        这里来看一下 Anbox snap 的主要命令和服务，也就是几个脚本的实现。<code>container-manager.sh</code> 脚本，用于起动容器管理服务，其内容如下：</p>
<pre><code>#!/bin/sh
set -x
# We need to put the rootfs somewhere where we can modify some
# parts of the content on first boot (namely file permissions).
# Other than that nothing should ever modify the content of the
# rootfs.
DATA_PATH=$SNAP_COMMON/
ROOTFS_PATH=$DATA_PATH/rootfs
ANDROID_IMG=$SNAP/android.img
if [ ! -e $ANDROID_IMG ]; then
	echo &quot;ERROR: android image does not exist&quot;
	exit 1
fi
start() {
	# Make sure our setup path for the container rootfs
	# is present as lxc is statically configured for
	# this path.
	mkdir -p $SNAP_COMMON/lxc
	# We start the bridge here as long as a oneshot service unit is not
	# possible. See snapcraft.yaml for further details.
	$SNAP/bin/anbox-bridge.sh start
	# Ensure FUSE support for user namespaces is enabled
	echo Y | tee /sys/module/fuse/parameters/userns_mounts || echo &quot;WARNING: kernel doesn't support fuse in user namespaces&quot;
	# Only try to use AppArmor when the kernel has support for it
	AA_EXEC=&quot;$SNAP/usr/sbin/aa-exec -p unconfined --&quot;
	if [ ! -d /sys/kernel/security/apparmor ]; then
		echo &quot;WARNING: AppArmor support is not available!&quot;
		AA_EXEC=&quot;&quot;
	fi
	exec $AA_EXEC $SNAP/bin/anbox-wrapper.sh container-manager \
		--data-path=$DATA_PATH \
		--android-image=$ANDROID_IMG \
		--daemon
}
stop() {
	$SNAP/bin/anbox-bridge.sh stop
}
case &quot;$1&quot; in
	start)
		start
		;;
	stop)
		stop
		;;
	*)
		echo &quot;ERROR: Unknown command '$1'&quot;
		exit 1
		;;
esac
</code></pre>
<p>        在这个脚本中，启动容器管理服务时，调用 <code>anbox-bridge.sh start</code> 脚本为 Anbox 创建虚拟网卡，并调用 <code>anbox-wrapper.sh</code> 启动 anbox 二进制可执行程序。脚本的执行依赖几个环境变量的设置。在脚本执行时，环境变量 <code>SNAP</code> 指向 <code>/snap/anbox/current</code>，环境变量 <code>SNAP_COMMON</code> 指向 <code>/var/snap/anbox/common</code>。</p>
<p>        <code>anbox-wrapper.sh</code> 也就是 anbox 源码库中的 <code>scripts/snap-wrapper.sh</code>，其内容如下：</p>
<pre><code>#!/bin/bash
if [ &quot;$SNAP_ARCH&quot; == &quot;amd64&quot; ]; then
	ARCH=&quot;x86_64-linux-gnu&quot;
elif [ &quot;$SNAP_ARCH&quot; == &quot;armhf&quot; ]; then
	ARCH=&quot;arm-linux-gnueabihf&quot;
else
	ARCH=&quot;$SNAP_ARCH-linux-gnu&quot;
fi
export LD_LIBRARY_PATH=$SNAP/usr/lib/$ARCH:$LD_LIBRARY_PATH
# Mesa Libs
export LD_LIBRARY_PATH=$SNAP/usr/lib/$ARCH/mesa:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$SNAP/usr/lib/$ARCH/mesa-egl:$LD_LIBRARY_PATH
# XDG Config
export XDG_CONFIG_DIRS=$SNAP/etc/xdg:$XDG_CONFIG_DIRS
export XDG_CONFIG_DIRS=$SNAP/usr/xdg:$XDG_CONFIG_DIRS
# Note: this doesn't seem to work, QML's LocalStorage either ignores
# or fails to use $SNAP_USER_DATA if defined here
export XDG_DATA_DIRS=$SNAP_USER_DATA:$XDG_DATA_DIRS
export XDG_DATA_DIRS=$SNAP/usr/share:$XDG_DATA_DIRS
# Tell libGL where to find the drivers
export LIBGL_DRIVERS_PATH=$SNAP/usr/lib/$ARCH/dri
# ensure the snappy gl libs win
export LD_LIBRARY_PATH=&quot;$SNAP_LIBRARY_PATH:$LD_LIBRARY_PATH&quot;
# Workaround in snapd for proprietary nVidia drivers mounts the drivers in
# /var/lib/snapd/lib/gl that needs to be in LD_LIBRARY_PATH
# Without that OpenGL using apps do not work with the nVidia drivers.
# Ref.: https://bugs.launchpad.net/snappy/+bug/1588192
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/var/lib/snapd/lib/gl
# We set XDG_DATA_HOME to SNAP_USER_COMMON here as this will be the location we will
# create all our application launchers in. The system application launcher will
# be configured by our installer to look into this directory for available
# launchers.
export XDG_DATA_HOME=&quot;$SNAP_USER_COMMON/app-data&quot;
exec $SNAP/usr/bin/anbox $@
</code></pre>
<p>        在这个脚本中，主要导出了一些环境变量，<code>LD_LIBRARY_PATH</code>，<code>XDG_CONFIG_DIRS</code>，<code>XDG_DATA_DIRS</code>，<code>LIBGL_DRIVERS_PATH</code> 和 <code>XDG_DATA_HOME</code>，以使 anbox 二进制可执行程序在启动之后，可以找到所需的动态链接库等。</p>
<h3 id="334-参考文档"><a class="header" href="#334-参考文档">3.3.4 参考文档：</a></h3>
<ol>
<li>Upstart 链接:(https://zh.wikipedia.org/zh-hans/Upstart)</li>
<li>浅析 Linux 初始化 init 系统，Systemd 链接:(http://blog.csdn.net/younger_china/article/details/52539657)</li>
<li>Debug vs Release in CMAKE 链接:(https://stackoverflow.com/questions/7724569/debug-vs-release-in-cmake)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="34-anbox-实现分析io-模型"><a class="header" href="#34-anbox-实现分析io-模型">3.4 Anbox 实现分析：I/O 模型</a></h2>
<p>为便于后来者学习，特此收纳本资料：http://hanpfei.github.io/2018/01/11/anbox_analysis002_io_model/</p>
<p>        Anbox 运行时主要由两个分开的实例构成，即容器管理器 ContainerManager 和会话管理器 SessionManager，但无论是 ContainerManager 还是 SessionManager，所做的最重要的事情就是处理网络 I/O 事件了。I/O 模型指一个应用处理 I/O 事件的整体框架设计，对于 Anbox 而言主要是处理各种网络 I/O 事务的整体框架设计。ContainerManager 和 SessionManager 基于一个相同的 I/O 模型运行，为了获得对 Anbox 整体行为设计的理解，有必要对其 I/O 模型有个整体的认识。</p>
<h3 id="341-io-模型"><a class="header" href="#341-io-模型">3.4.1 I/O 模型</a></h3>
<p>        Anbox 的 I/O 模型基于 boost.asio 构建。Anbox 中所有的 I/O 事件，在一个线程池中，通过一个 <code>boost::asio::io_service</code> 对象来派发并处理。Anbox 用 <code>anbox::Runtime</code> 类封装一个 <code>boost::asio::io_service</code> 对象，并管理执行任务的线程池。</p>
<p>        <code>anbox::Runtime</code> 类的定义（位于 <code>anbox/src/anbox/runtime.h</code>）如下：</p>
<pre><code>namespace anbox {
// We bundle our &quot;global&quot; runtime dependencies here, specifically
// a dispatcher to decouple multiple in-process providers from one
// another , forcing execution to a well known set of threads.
class Runtime : public DoNotCopyOrMove,
                public std::enable_shared_from_this&lt;Runtime&gt; {
 public:
  // Our default concurrency setup.
  static constexpr const std::uint32_t worker_threads = 8;
  // create returns a Runtime instance with pool_size worker threads
  // executing the underlying service.
  static std::shared_ptr&lt;Runtime&gt; create(
      std::uint32_t pool_size = worker_threads);
  // Tears down the runtime, stopping all worker threads.
  ~Runtime() noexcept(true);
  // start executes the underlying io_service on a thread pool with
  // the size configured at creation time.
  void start();
  // stop cleanly shuts down a Runtime instance.
  void stop();
  // to_dispatcher_functional returns a function for integration
  // with components that expect a dispatcher for operation.
  std::function&lt;void(std::function&lt;void()&gt;)&gt; to_dispatcher_functional();
  // service returns the underlying boost::asio::io_service that is executed
  // by the Runtime.
  boost::asio::io_service&amp; service();
 private:
  // Runtime constructs a new instance, firing up pool_size
  // worker threads.
  Runtime(std::uint32_t pool_size);
  std::uint32_t pool_size_;
  boost::asio::io_service service_;
  boost::asio::io_service::strand strand_;
  boost::asio::io_service::work keep_alive_;
  std::vector&lt;std::thread&gt; workers_;
};
}  // namespace anbox
</code></pre>
<p>        <code>anbox::Runtime</code> 类封装了一个 <code>boost::asio::io_service</code> 对象及多个工作线程 <code>std::thread</code>，它还继承 <code>std::enable_shared_from_this&lt;Runtime&gt;</code> 以获得从 <code>this</code> 指针创建智能指针 <code>std::shared_ptr</code> 的能力，同时继承了 <code>DoNotCopyOrMove</code>，以禁掉类的拷贝和移动操作。</p>
<p>        <code>anbox::Runtime</code> 类的实现（位于 <code>anbox/src/anbox/runtime.cpp</code>）如下：</p>
<pre><code>namespace {
void exception_safe_run(boost::asio::io_service&amp; service) {
  while (true) {
    try {
      service.run();
      // a clean return from run only happens in case of
      // stop() being called (we are keeping the service alive with
      // a service::work instance).
      break;
    } catch (const std::exception&amp; e) {
      ERROR(&quot;%s&quot;, e.what());
    } catch (...) {
      ERROR(&quot;Unknown exception caught while executing boost::asio::io_service&quot;);
    }
  }
}
}
namespace anbox {
std::shared_ptr&lt;Runtime&gt; Runtime::create(std::uint32_t pool_size) {
  return std::shared_ptr&lt;Runtime&gt;(new Runtime(pool_size));
}
Runtime::Runtime(std::uint32_t pool_size)
    : pool_size_{pool_size},
      service_{pool_size_},
      strand_{service_},
      keep_alive_{service_} {}
Runtime::~Runtime() noexcept(true) {
  try {
    stop();
  } catch (...) {
    // Dropping all exceptions to satisfy the nothrow guarantee.
  }
}
void Runtime::start() {
  for (unsigned int i = 0; i &lt; pool_size_; i++)
    workers_.push_back(std::thread{exception_safe_run, std::ref(service_)});
}
void Runtime::stop() {
  service_.stop();
  for (auto&amp; worker : workers_)
    if (worker.joinable())
      worker.join();
  workers_.clear();
}
std::function&lt;void(std::function&lt;void()&gt;)&gt; Runtime::to_dispatcher_functional() {
  // We have to make sure that we stay alive for as long as
  // calling code requires the dispatcher to work.
  auto sp = shared_from_this();
  return [sp](std::function&lt;void()&gt; task) { sp-&gt;strand_.post(task); };
}
boost::asio::io_service&amp; Runtime::service() { return service_; }
}  // namespace anbox
</code></pre>
<p>        <code>anbox::Runtime</code> 类有两大职责，一是 <code>boost::asio::io_service</code> 对象的生命周期管理；二是向 <code>boost::asio::io_service</code> 中提交任务。</p>
<p>        在 <code>anbox::Runtime::start()</code> 函数中创建并启动多个线程，执行一个执行 <code>boost::asio::io_service::run()</code> 函数的函数 <code>exception_safe_run()</code>。在 <code>anbox::Runtime::stop()</code> 函数中停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的析够函数中，还会调用 <code>stop()</code> 函数停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的类型为 <code>boost::asio::io_service::work</code> 的成员变量 <code>keep_alive_</code> 也是用于管理 <code>boost::asio::io_service</code> 对象的生命周期的，该对象在析够时也会停掉 <code>boost::asio::io_service</code> 的执行。</p>
<p>        对于不熟悉 boost 库的朋友来说，<code>boost::asio::io_service</code> 可以理解为一个 I/O 多路复用器，就像许多网络库通过 select/poll/epoll/kqueue 实现的那样，或者可以理解为以 Reactor 模式实现的网络库中的一个事件循环，可以向其中提交 I/O 任务、定时器及其它任务等。<code>boost::asio::io_service::strand</code> 可以理解为 <code>boost::asio::io_service</code> 中的一个特殊的子任务队列，该类保证向其提交的所有任务都不会并发执行，以此消除这些任务之间的同步问题。</p>
<p>        <code>anbox::Runtime::to_dispatcher_functional()</code> 函数返回一个接收一个函数为参数的函数，返回的这个函数可以将它接收的函数作为一个 task，通过 <code>boost::asio::io_service::strand</code> 提交给 <code>boost::asio::io_service</code> 执行。<code>anbox::Runtime::service()</code> 返回 <code>boost::asio::io_service</code> 用于方便一些 boost I/O 组件，直接向该 <code>io_service</code> 中提交任务。</p>
<p>        继承自 <code>std::enable_shared_from_this&lt;Runtime&gt;</code> 的 <code>shared_from_this()</code> 可以从 <code>this</code> 指针创建一个指向当前对象的 <code>std::shared_ptr</code> 智能指针。通过对标准库源码的分析，可以知道 <code>std::enable_shared_from_this</code> 的实现原理大体如下：<code>std::enable_shared_from_this&lt;Runtime&gt;</code> 有一个类型为 <code>std::weak_ptr&lt;Runtime&gt;</code> 的成员，该成员在首次创建指向对象的 <code>std::shared_ptr</code> 智能指针的时候会被初始化。<code>shared_from_this()</code> 函数被调用时，会从类型为 <code>std::weak_ptr&lt;Runtime&gt;</code> 的成员变量创建指向当前对象的 <code>std::shared_ptr</code> 智能指针。</p>
<p>        Anbox 的 I/O 模型可以理解为，底层有 *<strong>一个*</strong> 多路复用器或事件循环 <code>boost::asio::io_service</code>，有一个包含了 8 个线程的线程池基于此 <code>boost::asio::io_service</code> 运行，处理 I/O 事件及其它各种类型的任务。</p>
<p>有了用于执行 I/O 事件处理程序的 <code>boost::asio::io_service</code>，接下来来看一下，Anbox 都会向其中提交哪些任务。</p>
<p>        Anbox 需要处理如下这样一些网络 I/O 过程：</p>
<ul>
<li>监听 Unix 域 Socket 接受连接。Anbox 的 SessionManager 通过 Unix 域 Socket 与 ContainerManager 进行通信，同时也通过 Unix 域 Socket 与 ContainerManager 启动的 Android 容器内的应用程序通信。首先 ContainerManager 监听在特定位置的 Unix 域 Socket 上。随后 SessionManager 监听几个位置上的 Unix 域 Socket，然后请求 ContainerManager 启动 Android 容器，并将这几个 Unix 域 Socket 映射到容器内的 <code>/dev/</code> 目录下。Android 容器启动后，一些进程，如 surfaceflinger、cameraservice 等连接这些 Unix 域 Socket，并通过这些 Unix 域 Socket 与 SessionManager 通信，进而操作宿主机的硬件设备。</li>
<li>监听 TCP Socket 接受连接。Anbox 的 SessionManager 作为容器中运行的 Android 与 ADB 进行通信的桥梁，它在与容器中运行的 Android 通过 Unix 域 Socket 通信的同时，也需要与宿主机上的 ADB 通信。SessionManager 通过 TCP 与宿主机上的 ADB 守护进程通信。如同模拟器等 Android 设备一样，SessionManager 遵从 ADB 的通信协议，在发起与 ADB 之间的 TCP 连接的同时，也需要监听一个 TCP 端口，等待 ADB 守护进程发起的连接，以完成整个 ADB 协议。</li>
<li>处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket。监听的 Unix 域 Socket 接受新连接之后，需要将新创建的 Unix 域 Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>处理从监听的 TCP Scoket 接受的 TCP Socket。监听的 TCP Socket 接受新连接之后，需要将新创建的 TCP Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>发起一个到 TCP 服务器的连接。如前面提到的，Anbox 的 SessionManager 通过 TCP 连接与 ADB 守护进程通信，它会先发起一个到 ADB 守护进程的 TCP 连接。</li>
<li>发起一个到 Unix 域 Socket 服务的连接。Anbox 的 SessionManager 与 ContainerManager 之间通过 Unix 域 Socket 通信，SessionManager 会发起到 ContainerManager 监听的 Unix 域 Socket 服务的连接。</li>
</ul>
<h3 id="342-监听-unix-域-socket-接受连接"><a class="header" href="#342-监听-unix-域-socket-接受连接">3.4.2 监听 Unix 域 Socket 接受连接</a></h3>
<p>        在 boost.asio 中，监听 Socket 并接受新连接，通过 acceptor 完成，对于具体的 Unix 域 Socket 而言，是通过 <code>boost::asio::local::stream_protocol::acceptor</code>。<code>boost::asio::local::stream_protocol::acceptor</code> 类对象在创建时，需要为构造函数传入 <code>boost::asio::io_service</code> 及 Unix 域 Socket 的路径，通过 acceptor 的 <code>async_accept()</code> 函数，可以将 Unix 域 Socket 及处理新连接到来时的回调函数提交给底层的 I/O 多路复用器，异步地启动对 Unix 域 Socket 的监听。</p>
<p>        在 Anbox 中，通过 <code>anbox::network::PublishedSocketConnector</code> 封装 <code>boost::asio::local::stream_protocol::acceptor</code>，并为它定义处理新连接到来时的回调函数。<code>anbox::network::PublishedSocketConnector</code> 类的定义（位于 <code>anbox/src/anbox/network/published_socket_connector.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class PublishedSocketConnector : public DoNotCopyOrMove, public Connector {
 public:
  explicit PublishedSocketConnector(
      const std::string&amp; socket_file, const std::shared_ptr&lt;Runtime&gt;&amp; rt,
      const std::shared_ptr&lt;ConnectionCreator&lt;
          boost::asio::local::stream_protocol&gt;&gt;&amp; connection_creator);
  ~PublishedSocketConnector() noexcept;
  std::string socket_file() const { return socket_file_; }
 private:
  void start_accept();
  void on_new_connection(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp; socket,
      boost::system::error_code const&amp; err);
  const std::string socket_file_;
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;&gt;
      connection_creator_;
  boost::asio::local::stream_protocol::acceptor acceptor_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::PublishedSocketConnector</code> 保存了 Unix 域 Socket 文件的路径，指向 <code>anbox::Runtime</code> 对象的智能指针，一个指向 <code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 对象的智能指针，及 一个 <code>boost::asio::local::stream_protocol::acceptor</code>。指向 <code>anbox::Runtime</code> 对象的智能指针主要用于从 <code>anbox::Runtime</code> 对象获得其管理的 <code>boost::asio::io_service</code> 的引用。<code>boost::asio::local::stream_protocol::acceptor</code> 的作用如前所述，<code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 的作用后面再来讨论。</p>
<p>        <code>anbox::network::PublishedSocketConnector</code> 类的实现（位于 <code>anbox/src/anbox/network/published_socket_connector.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
PublishedSocketConnector::PublishedSocketConnector(
    const std::string&amp; socket_file, const std::shared_ptr&lt;Runtime&gt;&amp; rt,
    const std::shared_ptr&lt;ConnectionCreator&lt;
        boost::asio::local::stream_protocol&gt;&gt;&amp; connection_creator)
    : socket_file_(remove_socket_if_stale(socket_file)),
      runtime_(rt),
      connection_creator_(connection_creator),
      acceptor_(rt-&gt;service(), socket_file_) {
  start_accept();
}

PublishedSocketConnector::~PublishedSocketConnector() noexcept {}

void PublishedSocketConnector::start_accept() {
  auto socket = std::make_shared&lt;boost::asio::local::stream_protocol::socket&gt;(runtime_-&gt;service());

  acceptor_.async_accept(*socket,
                         [this, socket](boost::system::error_code const&amp; err) {
                           on_new_connection(socket, err);
                         });
}

void PublishedSocketConnector::on_new_connection(std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp; socket,
                                                 boost::system::error_code const&amp; err) {
  if (!err)
    connection_creator_-&gt;create_connection_for(socket);

  if (err.value() == boost::asio::error::operation_aborted)
    return;

  start_accept();
}
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::PublishedSocketConnector</code> 类对象构造完成之后，即会调用 <code>start_accept()</code> 启动对 Unix 域 Socket 的监听。</p>
<p>        <code>anbox::network::PublishedSocketConnector</code> 的 <code>start_accept()</code> 首先创建一个 <code>boost::asio::local::stream_protocol::socket</code> 对象用于保存下次接受的新 Socket 的相关信息，然后将这个对象，及作为处理新连接到来时的回调函数而创建的 lambda 表达式传递给 <code>boost::asio::local::stream_protocol::acceptor</code> 的 <code>async_accept()</code> 函数以启动对 Unix 域 Socket 的监听。</p>
<p>        接收到新到来的连接之后，传给 <code>boost::asio::local::stream_protocol::acceptor</code> 的 <code>async_accept()</code> 的 lambda 回调函数直接将 Socket 交给 <code>anbox::network::PublishedSocketConnector::on_new_connection()</code> 来处理，<code>anbox::network::PublishedSocketConnector::on_new_connection()</code> 又将新连接交给 <code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 来处理。</p>
<p>        由此不难理解，在 Anbox 的设计中，监听并接受连接与对新连接的处理，由两个完全不同的组件来处理，前者由 <code>anbox::network::Connector</code> 处理，后者由 <code>anbox::network::ConnectionCreator</code> 处理。<code>anbox::network::ConnectionCreator</code> 定义（位于 <code>anbox/src/anbox/network/connection_creator.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
template &lt;typename stream_protocol&gt;
class ConnectionCreator : public DoNotCopyOrMove {
 public:
  virtual void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;
          socket) = 0;
};
}  // namespace anbox
}  // namespace network
</code></pre>
<h3 id="343-监听-tcp-socket-接受连接"><a class="header" href="#343-监听-tcp-socket-接受连接">3.4.3 监听 TCP Socket 接受连接</a></h3>
<p>        Anbox 中监听 TCP Socket 并接受连接的逻辑与监听 Unix 域 Socket 并接受连接的逻辑非常类似，只是依赖的底层 boost.asio 的 acceptor 变为了 <code>boost::asio::ip::tcp::acceptor</code>。封装 <code>boost::asio::ip::tcp::acceptor</code> 组件等由 <code>anbox::network::TcpSocketConnector</code> 完成，这个类的定义（位于 <code>anbox/src/anbox/network/tcp_socket_connector.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class TcpSocketConnector : public DoNotCopyOrMove, public Connector {
 public:
  explicit TcpSocketConnector(
      const boost::asio::ip::address_v4 &amp;address, unsigned short port,
      const std::shared_ptr&lt;Runtime&gt; &amp;rt,
      const std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;
          &amp;connection_creator);
  ~TcpSocketConnector() noexcept;
  unsigned short port() const { return port_; }
 private:
  void start_accept();
  void on_new_connection(
      std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket,
      boost::system::error_code const &amp;err);
  boost::asio::ip::address_v4 address_;
  unsigned short port_;
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt; connection_creator_;
  boost::asio::ip::tcp::acceptor acceptor_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        监听的地址，不像 <code>anbox::network::PublishedSocketConnector</code> 那样用一个路径来描述就可以了，而是要通过 IP 地址和端口号来描述。</p>
<p><code>anbox::network::TcpSocketConnector</code> 类的实现（位于 <code>anbox/src/anbox/network/tcp_socket_connector.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
TcpSocketConnector::TcpSocketConnector(
    const boost::asio::ip::address_v4&amp; address, unsigned short port,
    const std::shared_ptr&lt;Runtime&gt;&amp; rt,
    const std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;&amp;
        connection_creator)
    : address_(address),
      port_(port),
      runtime_(rt),
      connection_creator_(connection_creator),
      acceptor_(rt-&gt;service(), boost::asio::ip::tcp::endpoint(address, port)) {
  start_accept();
}
TcpSocketConnector::~TcpSocketConnector() noexcept { acceptor_.cancel(); }
void TcpSocketConnector::start_accept() {
  auto socket =
      std::make_shared&lt;boost::asio::ip::tcp::socket&gt;(runtime_-&gt;service());
  acceptor_.async_accept(*socket,
                         [this, socket](boost::system::error_code const&amp; err) {
                           on_new_connection(socket, err);
                         });
}
void TcpSocketConnector::on_new_connection(
    std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const&amp; socket,
    boost::system::error_code const&amp; err) {
  switch (err.value()) {
    case boost::system::errc::success:
      connection_creator_-&gt;create_connection_for(socket);
      break;
    default:
      // Socket was closed so don't listen for any further incoming
      // connection attempts.
      return;
  }
  start_accept();
}
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        启动监听及新连接到来时的回调处理都与 <code>anbox::network::PublishedSocketConnector</code> 类似，只是调用 acceptor 的 <code>async_accept()</code> 之前创建的是 <code>boost::asio::ip::tcp::socket</code> 对象，新连接到来之后，则是交给 <code>ConnectionCreator&lt;boost::asio::ip::tcp&gt;</code> 来处理的。</p>
<p>        Anbox 中，监听 Socket 相关（包括对 Unix 域 Socket 的监听和对 TCP Socket 的监听）的类结构如下：</p>
<p><img src="images/anbox/1315506-6bc2288274987ea5.png" alt="1315506-6bc2288274987ea5" /></p>
<center>图3.15 Anbox中监听Socket相关类结构</center>
<h3 id="344-处理从监听的-unix-域-socket-接受的-unix-域-socket"><a class="header" href="#344-处理从监听的-unix-域-socket-接受的-unix-域-socket">3.4.4 处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket</a></h3>
<p>        在 Anbox 中，使用了 <code>anbox::network::PublishedSocketConnector</code> 来监听 Unix 域 Socket 的组件包括如下这些：</p>
<center>表3.2 Anbox中监听Unix域Socket组件表</center>
<div class="table-wrapper"><table><thead><tr><th><strong>组件</strong></th><th>所用 ConnectionCreator</th></tr></thead><tbody>
<tr><td>anbox::audio::Server</td><td>anbox::network::DelegateConnectionCreator</td></tr>
<tr><td>anbox::cmds::SessionManager</td><td>anbox::rpc::ConnectionCreator</td></tr>
<tr><td>anbox::container::Service</td><td>anbox::network::DelegateConnectionCreator</td></tr>
<tr><td>anbox::input::Device</td><td>anbox::network::DelegateConnectionCreator</td></tr>
</tbody></table>
</div>
<p>        在 Anbox 中监听 Unix 域 Socket 的组件有多个，对于新到来的连接的处理方式有着一定的差异，但这种处理又都依赖于相同的底层 Unix 域 Socket 处理框架。</p>
<p>        <code>anbox::rpc::ConnectionCreator</code> 清晰地为我们展示了，Anbox 中处理新接受的 Unix 域 Socket 的基本方式，来看这个类的实现。<code>anbox::rpc::ConnectionCreator</code> 的定义（位于 <code>anbox/src/anbox/rpc/connection_creator.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
class ConnectionCreator
    : public network::ConnectionCreator&lt;boost::asio::local::stream_protocol&gt; {
 public:
  typedef std::function&lt;std::shared_ptr&lt;network::MessageProcessor&gt;(
      const std::shared_ptr&lt;network::MessageSender&gt; &amp;)&gt;
      MessageProcessorFactory;
  ConnectionCreator(const std::shared_ptr&lt;Runtime&gt; &amp;rt,
                    const MessageProcessorFactory &amp;factory);
  ~ConnectionCreator() noexcept;
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;
          boost::asio::local::stream_protocol&gt;&gt; const &amp;socket) override;
 private:
  int next_id();
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::atomic&lt;int&gt; next_connection_id_;
  std::shared_ptr&lt;network::Connections&lt;network::SocketConnection&gt;&gt; const
      connections_;
  MessageProcessorFactory message_processor_factory_;
};
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        <code>anbox::rpc::ConnectionCreator</code> 实现用于处理新到来的连接的 <code>create_connection_for()</code> 函数。<code>anbox::rpc::ConnectionCreator</code> 的实现（位于 <code>anbox/src/anbox/rpc/connection_creator.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
ConnectionCreator::ConnectionCreator(const std::shared_ptr&lt;Runtime&gt;&amp; rt,
                                     const MessageProcessorFactory&amp; factory)
    : runtime_(rt),
      next_connection_id_(0),
      connections_(
          std::make_shared&lt;network::Connections&lt;network::SocketConnection&gt;&gt;()),
      message_processor_factory_(factory) {}
ConnectionCreator::~ConnectionCreator() noexcept {}
void ConnectionCreator::create_connection_for(
    std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp;
        socket) {
  if (connections_-&gt;size() &gt;= 1) {
    socket-&gt;close();
    WARNING(
        &quot;A second client tried to connect. Denied request as we already have &quot;
        &quot;one and only allow a single client&quot;);
    return;
  }
  auto const messenger =
      std::make_shared&lt;network::LocalSocketMessenger&gt;(socket);
  auto const processor = message_processor_factory_(messenger);
  auto const&amp; connection = std::make_shared&lt;network::SocketConnection&gt;(
      messenger, messenger, next_id(), connections_, processor);
  connection-&gt;set_name(&quot;rpc&quot;);
  connections_-&gt;add(connection);
  connection-&gt;read_next_message();
}
int ConnectionCreator::next_id() { return next_connection_id_.fetch_add(1); }
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        从 <code>anbox::rpc::ConnectionCreator::create_connection_for()</code> 的实现，可以看到 Anbox 处理新接受的 Unix 域 Socket 的基本流程：</p>
<ul>
<li>为新的 <code>boost::asio::local::stream_protocol::socket</code> 对象创建 <code>anbox::network::LocalSocketMessenger</code>，用于将 Socket 添加进底层的 I/O 多路复用器，Socket 的读写等操作。</li>
<li>创建消息处理回调函数。当检测到 Socket 上有消息到来时，消息会被读取，并传递给这个回调函数来处理。</li>
<li>根据前面创建的 <code>anbox::network::LocalSocketMessenger</code> 和消息处理回调创建 <code>anbox::network::SocketConnection</code>。<code>anbox::network::SocketConnection</code> 是底层 Socket（即 <code>anbox::network::LocalSocketMessenger</code>） 与其用户之间的桥梁， <code>anbox::network::SocketConnection</code> 用于直接将 Socket 提交给底层 I/O 多路复用器以异步读取数据，帮助发送数据，以及拷贝底层数据读取缓冲区的数据并调用用户的消息处理回调函数。</li>
<li>为 <code>anbox::network::SocketConnection</code> 设置名称。</li>
<li>将 <code>anbox::network::SocketConnection</code> 保存于一个容器，以便于做一些整体的控制。<code>anbox::network::SocketConnection</code> 持有指向该容器的智能指针，以便于在连接断开时，将自身从容器中移除。</li>
<li>调用 <code>anbox::network::SocketConnection</code> 的 <code>read_next_message()</code> 函数，将 Socket 提交给底层的 I/O 多路复用器，以启动接收数据。这个函数十分类似于前面看到的 <code>anbox::network::PublishedSocketConnector</code> 和 <code>anbox::network::TcpSocketConnector</code> 的 <code>start_accept()</code> 函数。</li>
</ul>
<p>        <code>anbox::network::SocketConnection</code> 类的定义（位于<code>anbox/src/anbox/network/socket_connection.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class SocketConnection {
 public:
  SocketConnection(
      std::shared_ptr&lt;MessageReceiver&gt; const&amp; message_receiver,
      std::shared_ptr&lt;MessageSender&gt; const&amp; message_sender, int id,
      std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const&amp; connections,
      std::shared_ptr&lt;MessageProcessor&gt; const&amp; processor);
  ~SocketConnection() noexcept;
  void set_name(const std::string&amp; name) { name_ = name; }
  int id() const { return id_; }
  void send(char const* data, size_t length);
  void read_next_message();
 private:
  void on_read_size(const boost::system::error_code&amp; ec,
                    std::size_t bytes_read);
  std::shared_ptr&lt;MessageReceiver&gt; const message_receiver_;
  std::shared_ptr&lt;MessageSender&gt; const message_sender_;
  int id_;
  std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const connections_;
  std::shared_ptr&lt;MessageProcessor&gt; processor_;
  std::array&lt;std::uint8_t, 8192&gt; buffer_;
  std::string name_;
};
}  // namespace anbox
}  // namespace network
</code></pre>
<p>        <code>anbox::network::SocketConnection</code> 类的实现（位于 <code>anbox/src/anbox/network/socket_connection.cpp</code>）如下：</p>
<pre><code>namespace ba = boost::asio;
namespace bs = boost::system;
namespace anbox {
namespace network {
SocketConnection::SocketConnection(
    std::shared_ptr&lt;MessageReceiver&gt; const&amp; message_receiver,
    std::shared_ptr&lt;MessageSender&gt; const&amp; message_sender, int id_,
    std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const&amp; connections,
    std::shared_ptr&lt;MessageProcessor&gt; const&amp; processor)
    : message_receiver_(message_receiver),
      message_sender_(message_sender),
      id_(id_),
      connections_(connections),
      processor_(processor) {}
SocketConnection::~SocketConnection() noexcept {}
void SocketConnection::send(char const* data, size_t length) {
  message_sender_-&gt;send(data, length);
}
void SocketConnection::read_next_message() {
  auto callback = std::bind(&amp;SocketConnection::on_read_size, this, std::placeholders::_1, std::placeholders::_2);
  message_receiver_-&gt;async_receive_msg(callback, ba::buffer(buffer_));
}
void SocketConnection::on_read_size(const boost::system::error_code&amp; error, std::size_t bytes_read) {
  if (error) {
    connections_-&gt;remove(id());
    return;
  }
  std::vector&lt;std::uint8_t&gt; data(bytes_read);
  std::copy(buffer_.data(), buffer_.data() + bytes_read, data.data());
  if (processor_-&gt;process_data(data))
    read_next_message();
  else
      connections_-&gt;remove(id());
}
}  // namespace anbox
}  // namespace network
</code></pre>
<p>        在 <code>anbox::network::SocketConnection::read_next_message()</code> 中，用于存放读取的数据的缓冲区由 <code>anbox::network::SocketConnection</code> 提供，这与 <code>anbox::network::PublishedSocketConnector</code> 和 <code>anbox::network::TcpSocketConnector</code> 的 <code>start_accept()</code> 函数中，事先创建好保存下次到来的新连接的状态的 Socket 非常类似。</p>
<p>        另外一个 <code>anbox::network::ConnectionCreator</code> 实现者是 <code>anbox::network::DelegateConnectionCreator</code>，它仅仅是将处理新连接的职责转出去给一个函数，因而通常实际的新连接处理者也是 <code>anbox::network::PublishedSocketConnector</code> 的创建者。<code>anbox::network::DelegateConnectionCreator</code> 的定义及实现如下：</p>
<pre><code>namespace anbox {
namespace network {
template &lt;typename stream_protocol&gt;
class DelegateConnectionCreator : public ConnectionCreator&lt;stream_protocol&gt; {
 public:
  DelegateConnectionCreator(
      std::function&lt;void(std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;
                             stream_protocol&gt;&gt; const&amp;)&gt;
          delegate)
      : delegate_(delegate) {}
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;
          socket) override {
    if (delegate_)
      delegate_(socket);
    else
      socket-&gt;close();
  }
 private:
  std::function&lt;void(std::shared_ptr&lt;
                     boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;)&gt;
      delegate_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        使用了 <code>anbox::network::DelegateConnectionCreator</code> 的情况下，各个组件自己处理新到来的连接的方式，与 <code>anbox::rpc::ConnectionCreator</code> 中处理新到来的连接的方式大同小异。</p>
<p>        在 <code>anbox::cmds::SessionManager</code> 中（位于 <code>anbox/src/anbox/cmds/session_manager.cpp</code>）还有一个 <code>anbox::network::ConnectionCreator</code> 的实现：</p>
<pre><code>class NullConnectionCreator : public anbox::network::ConnectionCreator&lt;
                                  boost::asio::local::stream_protocol&gt; {
 public:
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
          &amp;socket) override {
    WARNING(&quot;Not implemented&quot;);
    socket-&gt;close();
  }
};
</code></pre>
<p>        这个实现，与 <code>anbox::network::DelegateConnectionCreator</code> 在 <code>delegate</code> 为空时的行为一致，看上去这个类的定义似乎有些多余。</p>
<h3 id="345-处理从监听的-tcp-scoket-接受的-tcp-socket"><a class="header" href="#345-处理从监听的-tcp-scoket-接受的-tcp-socket">3.4.5 处理从监听的 TCP Scoket 接受的 TCP Socket</a></h3>
<p>        Anbox 中只有一处监听了 TCP Socket，即在 ADB 消息处理器 <code>anbox::qemu::AdbMessageProcessor</code> 中。<code>anbox::qemu::AdbMessageProcessor</code> 中处理与 ADB 守护进程的交互的函数主要包括如下这些：</p>
<pre><code>void AdbMessageProcessor::wait_for_host_connection() {
  if (state_ != waiting_for_guest_accept_command)
    return;
  if (!host_connector_) {
    host_connector_ = std::make_shared&lt;network::TcpSocketConnector&gt;(
        boost::asio::ip::address_v4::from_string(loopback_address),
        default_host_listen_port, runtime_,
        std::make_shared&lt;
            network::DelegateConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;(
            std::bind(&amp;AdbMessageProcessor::on_host_connection, this, _1)));
  }
  try {
    // Notify the adb host instance so that it knows on which port our
    // proxy is waiting for incoming connections.
    auto messenger = std::make_shared&lt;network::TcpSocketMessenger&gt;(
        boost::asio::ip::address_v4::from_string(loopback_address), default_adb_client_port, runtime_);
    auto message = utils::string_format(&quot;host:emulator:%d&quot;, default_host_listen_port);
    auto handshake = utils::string_format(&quot;%04x%s&quot;, message.size(), message.c_str());
    messenger-&gt;send(handshake.data(), handshake.size());
  } catch (...) {
    // Server not up. No problem, it will contact us when started.
  }
}
void AdbMessageProcessor::on_host_connection(std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp&gt;&gt; const &amp;socket) {
  host_messenger_ = std::make_shared&lt;network::TcpSocketMessenger&gt;(socket);
  // set_no_delay() reduces the latency of sending data, at the cost
  // of creating more TCP packets on the connection. It's useful when
  // doing lots of small send() calls, like the ADB protocol requires.
  // And since this is on localhost, the packet increase should not be
  // noticeable.
  host_messenger_-&gt;set_no_delay();
  // Let adb inside the container know that we have a connection to
  // the adb host instance
  messenger_-&gt;send(reinterpret_cast&lt;const char *&gt;(ok_command.data()), ok_command.size());
  state_ = waiting_for_guest_start_command;
  expected_command_ = start_command;
}
void AdbMessageProcessor::read_next_host_message() {
  auto callback = std::bind(&amp;AdbMessageProcessor::on_host_read_size, this, _1, _2);
  host_messenger_-&gt;async_receive_msg(callback, boost::asio::buffer(host_buffer_));
}
void AdbMessageProcessor::on_host_read_size(const boost::system::error_code &amp;error, std::size_t bytes_read) {
  if (error) {
    // When AdbMessageProcessor is destroyed on program termination, the sockets
    // are closed and the standing operations are canceled. But, the callback is
    // still called even in that case, and the object has already been
    // deleted. We detect that condition by looking at the error code and avoid
    // touching *this in that case.
    if (error == boost::system::errc::operation_canceled)
      return;
    // For other errors, we assume the connection with the host is dropped. We
    // close the connection to the container's adbd, which will trigger the
    // deletion of this AdbMessageProcessor instance and free resources (most
    // importantly, default_host_listen_port and the lock). The standing
    // connection that adbd opened can then proceed and wait for the host to be
    // up again.
    state_ = closed_by_host;
    messenger_-&gt;close();
    return;
  }
  messenger_-&gt;send(reinterpret_cast&lt;const char *&gt;(host_buffer_.data()), bytes_read);
  read_next_host_message();
}
</code></pre>
<p>        <code>anbox::qemu::AdbMessageProcessor</code> 是在容器中的 Android 内的 <code>adbd</code> 守护进程通过 Unix 域 Socket <code>/dev/qemu_pipe</code> 与 SessionManager 建立连接时创建的，它作为容器中的 Android 内的 <code>adbd</code> 守护进程与宿主机的 ADB 守护进程之间的桥梁而存在。在 <code>anbox::qemu::AdbMessageProcessor::wait_for_host_connection()</code> 函数中，会启动对一个 TCP 端口的监听。</p>
<p><code>anbox::qemu::AdbMessageProcessor</code> 为 <code>anbox::network::TcpSocketConnector</code> 传入的 <code>anbox::network::ConnectionCreator</code> 是 <code>anbox::network::DelegateConnectionCreator</code>，为 <code>anbox::network::DelegateConnectionCreator</code> 绑定的 delegate 函数是 <code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code>，这也就是说，对新接受的连接的处理是由 <code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 完成的。</p>
<p>        <code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 中会根据 <code>&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp&gt;</code> 创建一个 <code>anbox::network::TcpSocketMessenger</code> 用于将新 Socket 提交给底层的 I/O 多路复用器，读写数据等。<code>messenger_</code> 表示与容器中的 Android 内的 adbd 之间的连接，<code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 在接收到 ADB 守护进程发起的连接之后，还会向容器中的 Android 内的 adbd 发送一条 <code>ok</code> 命令。随后容器中的 Android 内的 adbd 会回复一条消息，以通过 <code>anbox::qemu::AdbMessageProcessor::read_next_host_message()</code> 启动对新连接上的数据的接收。</p>
<p>        <code>anbox::qemu::AdbMessageProcessor::read_next_host_message()</code> 启动对新连接上的数据的接收，类似于 <code>anbox::network::SocketConnection</code> 的 <code>read_next_message()</code>，连接上的数据接收到之后，由 <code>anbox::qemu::AdbMessageProcessor::on_host_read_size()</code> 处理，这个函数与在 <code>anbox::rpc::ConnectionCreator</code> 中看到的传递给 <code>anbox::network::SocketConnection</code> 的 <code>anbox::network::MessageProcessor</code> 一样。</p>
<p>        <code>anbox::qemu::AdbMessageProcessor::on_host_read_size()</code> 对收到的数据的处理方式就是，把收到的数据转发给容器中的 Android 内的 adbd 进程。</p>
<p>        Anbox 中与监听的 Socket 上新接受的连接的处理有关的组件如下图所示：</p>
<p><img src="images/anbox/1315506-ba86f2cfdc75d46a.png" alt="1315506-ba86f2cfdc75d46a" /></p>
<center>图3.16 Anbox中监听Socket相关组件</center>
<p>        <code>Connector</code> 接受新连接之后，将为新连接创建的 Socket 传给 <code>ConnectionCreator</code>。Anbox 中的几个 <code>ConnectionCreator</code> 实现对新连接的处理方式类似：为新连接创建 <code>SocketMessenger</code>，用于将新连接加入底层 I/O 多路复用器，从新连接读取数据，或者向连接中写入数据。使用者可以在启动对 Socket 上的读事件进行监听时，传入 <code>AnboxReadHandler</code> 回调，在数据到达时得到通知并对数据做一些处理。<code>SocketConnection</code> 为连接管理提供了一些方便，它封装
<code>SocketMessenger</code>，并可以在收到数据时，通过另外的一个回调 <code>MessageProcessor</code> 将接收到的数据通知出去。更上层通过实现 <code>AnboxReadHandler</code> 或 <code>MessageProcessor</code> 来拿到接收到的数据并做处理。</p>
<h3 id="346-发起一个到-unix-域-socket-服务的连接"><a class="header" href="#346-发起一个到-unix-域-socket-服务的连接">3.4.6 发起一个到 Unix 域 Socket 服务的连接</a></h3>
<p>        Anbox 的 SessionManager 会通过 <code>anbox::container::Client</code> 发起与 ContainerManager 的连接，这是一个 Unix 域 Socket 连接。在 <code>anbox::container::Client</code> 中可以看到 Anbox 中发起到 Unix 域 Socket 服务的连接的过程。</p>
<p>        <code>anbox::container::Client</code> 的定义（位于 <code>anbox/src/anbox/container/client.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
class PendingCallCache;
class Channel;
class MessageProcessor;
}  // namespace rpc
namespace network {
class LocalSocketMessenger;
}  // namespace network
namespace container {
class ManagementApiStub;
class Client {
 public:
  typedef std::function&lt;void()&gt; TerminateCallback;
  Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  ~Client();
  void start(const Configuration &amp;configuration);
  void stop();
  void register_terminate_handler(const TerminateCallback &amp;callback);
 private:
  void read_next_message();
  void on_read_size(const boost::system::error_code &amp;ec,
                    std::size_t bytes_read);
  std::shared_ptr&lt;network::LocalSocketMessenger&gt; messenger_;
  std::shared_ptr&lt;rpc::PendingCallCache&gt; pending_calls_;
  std::shared_ptr&lt;rpc::Channel&gt; rpc_channel_;
  std::shared_ptr&lt;ManagementApiStub&gt; management_api_;
  std::shared_ptr&lt;rpc::MessageProcessor&gt; processor_;
  std::array&lt;std::uint8_t, 8192&gt; buffer_;
  TerminateCallback terminate_callback_;
};
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        这个类的各成员变量中，<code>messenger_</code> 表示与目标服务的连接；<code>buffer_</code> 是数据接收所需的缓冲区；<code>pending_calls_</code>、<code>rpc_channel_</code>、<code>management_api_</code> 和 <code>processor_</code> 都用于处理与目标服务间的通信，它们与 SessionManager 自身的逻辑紧密相关；<code>terminate_callback_</code> 用于连接结束。</p>
<p>        <code>anbox::container::Client</code> 的实现（位于 <code>anbox/src/anbox/container/client.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace container {
Client::Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt)
    : messenger_(std::make_shared&lt;network::LocalSocketMessenger&gt;(
          SystemConfiguration::instance().container_socket_path(), rt)),
      pending_calls_(std::make_shared&lt;rpc::PendingCallCache&gt;()),
      rpc_channel_(std::make_shared&lt;rpc::Channel&gt;(pending_calls_, messenger_)),
      management_api_(std::make_shared&lt;ManagementApiStub&gt;(rpc_channel_)),
      processor_(
          std::make_shared&lt;rpc::MessageProcessor&gt;(messenger_, pending_calls_)) {
  read_next_message();
}
Client::~Client() {}
void Client::start(const Configuration &amp;configuration) {
  try {
    management_api_-&gt;start_container(configuration);
  } catch (const std::exception &amp;e) {
    ERROR(&quot;Failed to start container: %s&quot;, e.what());
    if (terminate_callback_)
      terminate_callback_();
  }
}
void Client::stop() {
  management_api_-&gt;stop_container();
}
void Client::register_terminate_handler(const TerminateCallback &amp;callback) {
  terminate_callback_ = callback;
}
void Client::read_next_message() {
  auto callback = std::bind(&amp;Client::on_read_size, this, std::placeholders::_1,
                            std::placeholders::_2);
  messenger_-&gt;async_receive_msg(callback, ba::buffer(buffer_));
}
void Client::on_read_size(const boost::system::error_code &amp;error,
                          std::size_t bytes_read) {
  if (error) {
    if (terminate_callback_)
      terminate_callback_();
    return;
  }
  std::vector&lt;std::uint8_t&gt; data(bytes_read);
  std::copy(buffer_.data(), buffer_.data() + bytes_read, data.data());
  if (processor_-&gt;process_data(data)) read_next_message();
}
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        在 <code>anbox::container::Client</code> 的构造函数中，通过传入目标域 Socket 的地址及 <code>std::shared_ptr&lt;Runtime&gt;</code> 来创建 <code>anbox::network::LocalSocketMessenger</code>。在 <code>anbox::network::LocalSocketMessenger</code> 的构造函数中会自动与目标服务建立连接。</p>
<p>        <code>anbox::network::LocalSocketMessenger</code> 的定义（位于 <code>anbox/src/anbox/network/local_socket_messenger.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class LocalSocketMessenger
    : public BaseSocketMessenger&lt;boost::asio::local::stream_protocol&gt; {
 public:
  LocalSocketMessenger(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
          &amp;socket);
  LocalSocketMessenger(const std::string &amp;path,
                       const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  ~LocalSocketMessenger();
 private:
  std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; socket_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::LocalSocketMessenger</code> 的实现（位于 <code>anbox/src/anbox/network/local_socket_messenger.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
LocalSocketMessenger::LocalSocketMessenger(
    std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const &amp;socket)
    : BaseSocketMessenger(socket) {}
LocalSocketMessenger::LocalSocketMessenger(const std::string &amp;path,
                                           const std::shared_ptr&lt;Runtime&gt; &amp;rt)
    : socket_(std::make_shared&lt;boost::asio::local::stream_protocol::socket&gt;(
          rt-&gt;service())) {
  boost::system::error_code err;
  socket_-&gt;connect(boost::asio::local::stream_protocol::endpoint(path), err);
  if (err) {
    const auto msg = utils::string_format(&quot;Failed to connect to socket %s: %s&quot;,
                                          path, err.message());
    BOOST_THROW_EXCEPTION(std::runtime_error(msg));
  }
  setup(socket_);
}
LocalSocketMessenger::~LocalSocketMessenger() {}
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::LocalSocketMessenger</code> 对象创建完成后，将 Socket 提交给底层的 I/O 多路复用器，数据的收发及 Socket 的管理等，都与前面看到的为接受的新连接而创建的 <code>anbox::network::LocalSocketMessenger</code> 类似。</p>
<h3 id="347-发起一个到-tcp-服务器的连接"><a class="header" href="#347-发起一个到-tcp-服务器的连接">3.4.7 发起一个到 TCP 服务器的连接</a></h3>
<p>        在 Anbox 中，仅有一个地方发起了到 TCP 服务器的连接，即在我们前面已经看到过的 <code>anbox::qemu::AdbMessageProcessor::wait_for_host_connection()</code> 函数中：</p>
<pre><code>try {
  // Notify the adb host instance so that it knows on which port our
  // proxy is waiting for incoming connections.
  auto messenger = std::make_shared&lt;network::TcpSocketMessenger&gt;(
      boost::asio::ip::address_v4::from_string(loopback_address), default_adb_client_port, runtime_);
  auto message = utils::string_format(&quot;host:emulator:%d&quot;, default_host_listen_port);
  auto handshake = utils::string_format(&quot;%04x%s&quot;, message.size(), message.c_str());
  messenger-&gt;send(handshake.data(), handshake.size());
} catch (...) {
  // Server not up. No problem, it will contact us when started.
}
</code></pre>
<p>        在 Anbox 中，发起到 TCP 服务器的连接即是以目标 IP 地址和端口创建 <code>anbox::network::TcpSocketMessenger</code> 对象。<code>anbox::network::TcpSocketMessenger</code> 在其构造函数中会完成与目标服务的连接建立。<code>anbox::network::TcpSocketMessenger</code> 定义（位于 <code>anbox/src/anbox/network/tcp_socket_messenger.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class TcpSocketMessenger : public BaseSocketMessenger&lt;boost::asio::ip::tcp&gt; {
 public:
  TcpSocketMessenger(const boost::asio::ip::address_v4 &amp;addr,
                     unsigned short port, const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  TcpSocketMessenger(
      std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket);
  ~TcpSocketMessenger();
  unsigned short local_port() const override;
 private:
  unsigned short local_port_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::TcpSocketMessenger</code> 实现（位于 <code>anbox/src/anbox/network/tcp_socket_messenger.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
TcpSocketMessenger::TcpSocketMessenger(const boost::asio::ip::address_v4 &amp;addr,
                                       unsigned short port,
                                       const std::shared_ptr&lt;Runtime&gt; &amp;rt) {
  boost::asio::ip::tcp::endpoint endpoint(addr, port);
  auto socket = std::make_shared&lt;boost::asio::ip::tcp::socket&gt;(rt-&gt;service());
  socket-&gt;connect(endpoint);
  setup(socket);
  local_port_ = socket-&gt;local_endpoint().port();
}
TcpSocketMessenger::TcpSocketMessenger(
    std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket)
    : BaseSocketMessenger(socket) {}
TcpSocketMessenger::~TcpSocketMessenger() {}
unsigned short TcpSocketMessenger::local_port() const { return local_port_; }
}  // namespace network
}  // namespace anbox
</code></pre>
<p>        <code>anbox::network::TcpSocketMessenger</code> 对象创建完成之后，将 Socket 提交给底层的 I/O 多路复用器，数据的收发及 Socket 的管理，都与前面看到的为接受的新连接而创建的 <code>anbox::network::TcpSocketMessenger</code> 类似。</p>
<p>        发起一个到 Unix 域 Socket 服务的连接，与发起一个到 TCP 服务器的连接的过程极为相似，都是通过提供一个具体的地址创建一个 <code>SocketMessenger</code> 对象，具体 <code>SocketMessenger</code> 类的构造函数会自动建立连接。新创建的 <code>SocketMessenger</code> 对象与从接受的 Socket 创建的 <code>SocketMessenger</code> 对象无异。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="35-anbox实现分析会话管理器与容器管理器的通信"><a class="header" href="#35-anbox实现分析会话管理器与容器管理器的通信">3.5 Anbox实现分析：会话管理器与容器管理器的通信</a></h2>
<p>为便于后来者学习，特此收纳本资料：http://hanpfei.github.io/2018/01/15/anbox_analysis003_sessionmanager_and_containermanager/</p>
<p>        Anbox 通过一个可执行文件，实现多个不同的应该用逻辑。在启动 Anbox 可执行文件时，通过为它提供不同的命令行参数来确定具体执行哪个命令。Anbox 中这些不同的命令实例之间，整体的通信架构如下图这样：</p>
<p><img src="images/anbox/1315506-beb1c58a9988124d.png" alt="1315506-beb1c58a9988124d" /></p>
<center>图3.17 Anbox通讯架构图</center>
<p>        这些不同的命令实例之间通信的过程大体如下：</p>
<ul>
<li>容器管理器实例首先运行起来，监听在特定位置的 Unix 域 Socket 上；</li>
<li>随后会话管理器启动，监听在另外的一些 Unix 域 Socket 上；</li>
<li>会话管理器同时连接容器管理器监听的 Unix 域 Socket 上的服务；</li>
<li>会话管理器与容器管理器通过 Unix 域 Socket 成功建立连接之后，会话管理器向容器管理器发送命令，请求容器管理器启动 Android 容器；</li>
<li>容器管理器收到会话管理器发来的命令后，先给会话管理器一个响应，然后通过 LXC 启动一个 Android 容器，并将会话管理器监听的 Unix 域 Socket 的文件路径映射进 Android 容器的 <code>/dev/</code> 目录下；</li>
<li>Android 容器启动之后，容器内的 Android 进程，通过映射进来的 Unix 域 Socket 与会话管理器建立连接；</li>
<li>Android 容器启动时，会话管理器与 ADB 守护进程建立连接；</li>
<li>Anbox 的 install 和 launch 命令主要用于对 Android 容器做一些控制，它们分别用于向 Android 容器中安装应用程序 APK 以及启动容器内的特定 Activity，它们通过 D-Bus 与会话管理器通信。</li>
</ul>
<p>        在 Anbox 中，会话管理器和容器管理器之间是比较重要的一条通信通道。会话管理器和容器管理器之间通过 Unix 域 Socket 进行通信，容器管理器监听在特定位置的 Unix 域 Socket 上，会话管理器发起与容器管理器之间的连接，连接建立之后，两者通过这条连接进行通信。</p>
<h3 id="351-容器管理器接受-rpc-调用"><a class="header" href="#351-容器管理器接受-rpc-调用">3.5.1 容器管理器接受 RPC 调用</a></h3>
<p>        代码层面，在容器管理器一端，通过 <code>anbox::container::Service</code> 启动对 Unix 域 Socket 的监听。<code>anbox::container::Service</code> 的定义（位于<code>anbox/src/anbox/container/service.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace container {
class Service : public std::enable_shared_from_this&lt;Service&gt; {
 public:
  static std::shared_ptr&lt;Service&gt; create(const std::shared_ptr&lt;Runtime&gt; &amp;rt, bool privileged);
  ~Service();
 private:
  Service(const std::shared_ptr&lt;Runtime&gt; &amp;rt, bool privileged);
  int next_id();
  void new_client(std::shared_ptr&lt;
                  boost::asio::local::stream_protocol::socket&gt; const &amp;socket);
  std::shared_ptr&lt;common::Dispatcher&gt; dispatcher_;
  std::shared_ptr&lt;network::PublishedSocketConnector&gt; connector_;
  std::atomic&lt;int&gt; next_connection_id_;
  std::shared_ptr&lt;network::Connections&lt;network::SocketConnection&gt;&gt; connections_;
  std::shared_ptr&lt;Container&gt; backend_;
  bool privileged_;
};
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        <strong><code>dispatcher_</code> 看起来没有实际的用处。</strong> <code>anbox::container::Service</code> 的实现（位于 <code>anbox/src/anbox/container/service.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace container {
std::shared_ptr&lt;Service&gt; Service::create(const std::shared_ptr&lt;Runtime&gt; &amp;rt, bool privileged) {
  auto sp = std::shared_ptr&lt;Service&gt;(new Service(rt, privileged));
  auto wp = std::weak_ptr&lt;Service&gt;(sp);
  auto delegate_connector = std::make_shared&lt;network::DelegateConnectionCreator&lt;boost::asio::local::stream_protocol&gt;&gt;(
      [wp](std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const &amp;socket) {
        if (auto service = wp.lock())
          service-&gt;new_client(socket);
  });
  const auto container_socket_path = SystemConfiguration::instance().container_socket_path();
  sp-&gt;connector_ = std::make_shared&lt;network::PublishedSocketConnector&gt;(container_socket_path, rt, delegate_connector);
  // Make sure others can connect to our socket
  ::chmod(container_socket_path.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
  DEBUG(&quot;Everything setup. Waiting for incoming connections.&quot;);
  return sp;
}
Service::Service(const std::shared_ptr&lt;Runtime&gt; &amp;rt, bool privileged)
    : dispatcher_(anbox::common::create_dispatcher_for_runtime(rt)),
      next_connection_id_(0),
      connections_(std::make_shared&lt;network::Connections&lt;network::SocketConnection&gt;&gt;()),
      privileged_(privileged) {
}
Service::~Service() {
  connections_-&gt;clear();
}
int Service::next_id() { return next_connection_id_++; }
void Service::new_client(std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
        &amp;socket) {
  if (connections_-&gt;size() &gt;= 1) {
    socket-&gt;close();
    return;
  }
  auto const messenger = std::make_shared&lt;network::LocalSocketMessenger&gt;(socket);
  DEBUG(&quot;Got connection from pid %d&quot;, messenger-&gt;creds().pid());
  auto pending_calls = std::make_shared&lt;rpc::PendingCallCache&gt;();
  auto rpc_channel = std::make_shared&lt;rpc::Channel&gt;(pending_calls, messenger);
  auto server = std::make_shared&lt;container::ManagementApiSkeleton&gt;(
      pending_calls, std::make_shared&lt;LxcContainer&gt;(privileged_, messenger-&gt;creds()));
  auto processor = std::make_shared&lt;container::ManagementApiMessageProcessor&gt;(
      messenger, pending_calls, server);
  auto const &amp;connection = std::make_shared&lt;network::SocketConnection&gt;(
      messenger, messenger, next_id(), connections_, processor);
  connection-&gt;set_name(&quot;container-service&quot;);
  connections_-&gt;add(connection);
  connection-&gt;read_next_message();
}
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        在 <code>anbox::container::Service</code> 的构造函数中，通过 <code>anbox::network::PublishedSocketConnector</code> 及 <code>anbox::network::DelegateConnectionCreator</code> 等组件，启动对 Unix 域 Socket 的监听。Anbox 中处理 Unix 域 Socket 监听的基本方法/模型，请参考 <a href="https://www.wolfcstech.com/2018/01/11/anbox_analysis002_io_model/">Anbox 实现分析 2：I/O 模型</a> 一文中的相关部分。</p>
<p>        <code>anbox::container::Service</code> 通过 <code>anbox::network::Connections</code> 和
<code>anbox::network::SocketConnection</code> 等管理新接受的连接，它限制只与一个会话管理器实例建立一条连接。<code>anbox::container::Service</code> 将处理收到的消息的组件 <code>anbox::container::ManagementApiMessageProcessor</code> 与底层的连接粘起来。</p>
<p>        Anbox 的容器管理器和会话管理器通过基于 Protobuf 设计的 RPC 进行通信。<code>anbox::container::Service</code> 中处理收到的消息及接受 RPC 调用的相关组件的设计框架如下：</p>
<p><img src="images/anbox/1315506-3e7dadf1f085f0a7.png" alt="1315506-3e7dadf1f085f0a7" /></p>
<center>图3.18 接受RPC调用的相关组件设计框架图</center>
<p>        *<strong>在 Anbox 的设计中，<code>anbox::rpc::Channel</code> 及 <code>anbox::rpc::PendingCallCache</code> 本来主要用于 RPC 调用发起端的消息收发，但在 <code>anbox::container::Service::new_client()</code> 中，同样为新连接创建了这两个类的对象，这显得有点多次一举。*</strong></p>
<p>        <code>anbox::container::Service</code> 通过 <code>anbox::network::SocketConnection</code> 收到消息之后，首先交给 <code>anbox::rpc::MessageProcessor</code> 的 <code>process_data()</code> 处理。</p>
<p>        <code>anbox::rpc::MessageProcessor</code> 的定义（位于 <code>anbox/src/anbox/rpc/message_processor.h</code>）如下：</p>
<pre><code>class MessageProcessor : public network::MessageProcessor {
 public:
  MessageProcessor(const std::shared_ptr&lt;network::MessageSender&gt;&amp; sender,
                   const std::shared_ptr&lt;PendingCallCache&gt;&amp; pending_calls);
  ~MessageProcessor();
  bool process_data(const std::vector&lt;std::uint8_t&gt;&amp; data) override;
  void send_response(::google::protobuf::uint32 id,
                     google::protobuf::MessageLite* response);
  virtual void dispatch(Invocation const&amp;) {}
  virtual void process_event_sequence(const std::string&amp;) {}
 private:
  std::shared_ptr&lt;network::MessageSender&gt; sender_;
  std::vector&lt;std::uint8_t&gt; buffer_;
  std::shared_ptr&lt;PendingCallCache&gt; pending_calls_;
};
</code></pre>
<p>        <code>anbox::rpc::MessageProcessor</code> 的实现（位于 <code>anbox/src/anbox/rpc/message_processor.cpp</code>）如下：</p>
<pre><code>MessageProcessor::MessageProcessor(
    const std::shared_ptr&lt;network::MessageSender&gt; &amp;sender,
    const std::shared_ptr&lt;PendingCallCache&gt; &amp;pending_calls)
    : sender_(sender), pending_calls_(pending_calls) {}
MessageProcessor::~MessageProcessor() {}
bool MessageProcessor::process_data(const std::vector&lt;std::uint8_t&gt; &amp;data) {
  for (const auto &amp;byte : data) buffer_.push_back(byte);
  while (buffer_.size() &gt; 0) {
    const auto high = buffer_[0];
    const auto low = buffer_[1];
    size_t const message_size = (high &lt;&lt; 8) + low;
    const auto message_type = buffer_[2];
    // If we don't have yet all bytes for a new message return and wait
    // until we have all.
    if (buffer_.size() - header_size &lt; message_size) break;
    if (message_type == MessageType::invocation) {
      anbox::protobuf::rpc::Invocation raw_invocation;
      raw_invocation.ParseFromArray(buffer_.data() + header_size, message_size);
      dispatch(Invocation(raw_invocation));
    } else if (message_type == MessageType::response) {
      auto result = make_protobuf_object&lt;protobuf::rpc::Result&gt;();
      result-&gt;ParseFromArray(buffer_.data() + header_size, message_size);
      if (result-&gt;has_id()) {
        pending_calls_-&gt;populate_message_for_result(*result,
                                                    [&amp;](google::protobuf::MessageLite *result_message) {
                                                      result_message-&gt;ParseFromString(result-&gt;response());
                                                    });
        pending_calls_-&gt;complete_response(*result);
      }
      for (int n = 0; n &lt; result-&gt;events_size(); n++)
        process_event_sequence(result-&gt;events(n));
    }
    buffer_.erase(buffer_.begin(),
                  buffer_.begin() + header_size + message_size);
  }
  return true;
}
void MessageProcessor::send_response(::google::protobuf::uint32 id,
                                     google::protobuf::MessageLite *response) {
  VariableLengthArray&lt;serialization_buffer_size&gt; send_response_buffer(
      static_cast&lt;size_t&gt;(response-&gt;ByteSize()));
  response-&gt;SerializeWithCachedSizesToArray(send_response_buffer.data());
  anbox::protobuf::rpc::Result send_response_result;
  send_response_result.set_id(id);
  send_response_result.set_response(send_response_buffer.data(),
                                    send_response_buffer.size());
  send_response_buffer.resize(send_response_result.ByteSize());
  send_response_result.SerializeWithCachedSizesToArray(
      send_response_buffer.data());
  const size_t size = send_response_buffer.size();
  const unsigned char header_bytes[header_size] = {
      static_cast&lt;unsigned char&gt;((size &gt;&gt; 8) &amp; 0xff),
      static_cast&lt;unsigned char&gt;((size &gt;&gt; 0) &amp; 0xff), MessageType::response,
  };
  std::vector&lt;std::uint8_t&gt; send_buffer(sizeof(header_bytes) + size);
  std::copy(header_bytes, header_bytes + sizeof(header_bytes),
            send_buffer.begin());
  std::copy(send_response_buffer.data(),
            send_response_buffer.data() + send_response_buffer.size(),
            send_buffer.begin() + sizeof(header_bytes));
  sender_-&gt;send(reinterpret_cast&lt;const char *&gt;(send_buffer.data()),
                send_buffer.size());
}
</code></pre>
<p>        在会话管理器与容器管理器之间的 RPC 通信中，<code>anbox::rpc::MessageProcessor</code> 是一个同时用于 RPC 调用发起端和接受端的组件。容器管理器作为 RPC 调用的接受端，接收发自于会话管理器的类型为 <code>MessageType::invocation</code> 的消息。</p>
<p>        会话管理器与容器管理器之间的 RPC 通信的消息格式为：<strong>[3 个字节的消息头]</strong> + <strong>[经由 Protobuf MessageLite 对象序列化得到的消息体]</strong>，其中消息头的前两个字节为 16 位的消息体长度的大尾端表示，第 3 个字节为消息的类型。RPC 消息的具体定义在 <code>anbox/src/anbox/protobuf/anbox_rpc.proto</code> 文件中：</p>
<pre><code>option optimize_for = LITE_RUNTIME;
package anbox.protobuf.rpc;
message Invocation {
    required uint32 id = 1;
    required string method_name = 2;
    required bytes parameters = 3;
    required uint32 protocol_version = 4;
}
message Result {
    optional uint32 id = 1;
    optional bytes response = 2;
    repeated bytes events = 3;
}
message StructuredError {
  optional uint32 domain = 1;
  optional uint32 code = 2;
}
message Void {
  optional string error = 127;
  optional StructuredError structured_error = 128;
}
</code></pre>
<p>        <code>Invocation</code> 消息用于发起 RPC 调用，<code>Result</code>、<code>Void</code> 和 <code>StructuredError</code> 用于返回响应或错误消息。</p>
<p>        对于容器管理器而言，<code>anbox::rpc::MessageProcessor</code> 在其 <code>process_data()</code> 中首先提取消息头，得到消息体的长度和类型，然后提取消息体并反序列化得到 Protobuf 消息 <code>anbox::protobuf::rpc::Invocation</code>，随后将该 Protobuf 消息封装为 <code>anbox::rpc::Invocation</code> 类的对象，并调用 <code>dispatch(Invocation const&amp;)</code> 将消息派发出去。</p>
<p>        <code>anbox::rpc::Invocation</code> 类的定义（位于 <code>anbox/src/anbox/rpc/message_processor.h</code> 中）如下：</p>
<pre><code>class Invocation {
 public:
  Invocation(anbox::protobuf::rpc::Invocation const&amp; invocation)
      : invocation_(invocation) {}
  const ::std::string&amp; method_name() const;
  const ::std::string&amp; parameters() const;
  google::protobuf::uint32 id() const;
 private:
  anbox::protobuf::rpc::Invocation const&amp; invocation_;
};
</code></pre>
<p>        <code>anbox::rpc::Invocation</code> 类的实现（位于 <code>anbox/src/anbox/rpc/message_processor.cpp</code> 中）如下：</p>
<pre><code>const ::std::string &amp;Invocation::method_name() const {
  return invocation_.method_name();
}
const ::std::string &amp;Invocation::parameters() const {
  return invocation_.parameters();
}
google::protobuf::uint32 Invocation::id() const { return invocation_.id(); }

</code></pre>
<p>        <code>anbox::rpc::Invocation</code> 类只是对 <code>anbox::protobuf::rpc::Invocation</code> 的简单包装。</p>
<p>        <code>anbox::rpc::MessageProcessor</code> 的 <code>dispatch(Invocation const&amp;)</code> 是一个虚函数，其实际的实现位于 <code>ManagementApiMessageProcessor</code> 中。<code>anbox::container::ManagementApiMessageProcessor</code> 的定义（位于 <code>anbox/src/anbox/container/management_api_message_processor.h</code> 中）如下：</p>
<pre><code>namespace anbox {
namespace container {
class ManagementApiSkeleton;
class ManagementApiMessageProcessor : public rpc::MessageProcessor {
 public:
  ManagementApiMessageProcessor(
      const std::shared_ptr&lt;network::MessageSender&gt; &amp;sender,
      const std::shared_ptr&lt;rpc::PendingCallCache&gt; &amp;pending_calls,
      const std::shared_ptr&lt;ManagementApiSkeleton&gt; &amp;server);
  ~ManagementApiMessageProcessor();
  void dispatch(rpc::Invocation const &amp;invocation) override;
  void process_event_sequence(const std::string &amp;event) override;
 private:
  std::shared_ptr&lt;ManagementApiSkeleton&gt; server_;
};
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        <code>anbox::container::ManagementApiMessageProcessor</code> 的实现（位于 <code>anbox/src/anbox/container/management_api_message_processor.cpp</code> 中）如下：</p>
<pre><code>namespace anbox {
namespace container {
ManagementApiMessageProcessor::ManagementApiMessageProcessor(
    const std::shared_ptr&lt;network::MessageSender&gt; &amp;sender,
    const std::shared_ptr&lt;rpc::PendingCallCache&gt; &amp;pending_calls,
    const std::shared_ptr&lt;ManagementApiSkeleton&gt; &amp;server)
    : rpc::MessageProcessor(sender, pending_calls), server_(server) {}
ManagementApiMessageProcessor::~ManagementApiMessageProcessor() {}
void ManagementApiMessageProcessor::dispatch(rpc::Invocation const &amp;invocation) {
  if (invocation.method_name() == &quot;start_container&quot;)
    invoke(this, server_.get(), &amp;ManagementApiSkeleton::start_container, invocation);
  else if (invocation.method_name() == &quot;stop_container&quot;)
    invoke(this, server_.get(), &amp;ManagementApiSkeleton::stop_container, invocation);
}
void ManagementApiMessageProcessor::process_event_sequence(
    const std::string &amp;) {}
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        <code>anbox::container::ManagementApiMessageProcessor</code> 的实现很简单，只支持两种 RPC 调用，分别为启动 Android 容器和停止 Android 容器，在它的 <code>dispatch()</code> 函数中，根据方法名，调用对应的函数。</p>
<p>        函数调用通过一个函数模板 <code>invoke()</code> 完成，该函数模板定义（位于 <code>anbox/src/anbox/rpc/template_message_processor.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
// Utility metafunction result_ptr_t&lt;&gt; allows invoke() to pick the right
// send_response() overload. The base template resolves to the prototype
// &quot;send_response(::google::protobuf::uint32 id, ::google::protobuf::Message*
// response)&quot;
// Client code may specialize result_ptr_t to resolve to another overload.
template &lt;typename ResultType&gt;
struct result_ptr_t {
  typedef ::google::protobuf::MessageLite* type;
};
// Boiler plate for unpacking a parameter message, invoking a server function,
// and
// sending the result message. Assumes the existence of Self::send_response().
template &lt;class Self, class Bridge, class BridgeX, class ParameterMessage,
          class ResultMessage&gt;
void invoke(Self* self, Bridge* rpc,
            void (BridgeX::*function)(ParameterMessage const* request,
                                      ResultMessage* response,
                                      ::google::protobuf::Closure* done),
            Invocation const&amp; invocation) {
  ParameterMessage parameter_message;
  if (!parameter_message.ParseFromString(invocation.parameters()))
    throw std::runtime_error(&quot;Failed to parse message parameters!&quot;);
  ResultMessage result_message;
  try {
    std::unique_ptr&lt;google::protobuf::Closure&gt; callback(
        google::protobuf::NewPermanentCallback&lt;
            Self, ::google::protobuf::uint32,
            typename result_ptr_t&lt;ResultMessage&gt;::type&gt;(
            self, &amp;Self::send_response, invocation.id(), &amp;result_message));
    (rpc-&gt;*function)(&amp;parameter_message, &amp;result_message, callback.get());
  } catch (std::exception const&amp; x) {
    result_message.set_error(std::string(&quot;Error processing request: &quot;) +
                             x.what());
    self-&gt;send_response(invocation.id(), &amp;result_message);
  }
}
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        直接启动和停止 Android 容器的职责，由 <code>anbox::container::ManagementApiSkeleton</code> 完成，这个类的定义（位于 <code>anbox/src/anbox/container/management_api_skeleton.h</code>）如下：</p>
<pre><code>class Container;
class ManagementApiSkeleton {
 public:
  ManagementApiSkeleton(
      const std::shared_ptr&lt;rpc::PendingCallCache&gt; &amp;pending_calls,
      const std::shared_ptr&lt;Container&gt; &amp;container);
  ~ManagementApiSkeleton();
  void start_container(
      anbox::protobuf::container::StartContainer const *request,
      anbox::protobuf::rpc::Void *response, google::protobuf::Closure *done);
  void stop_container(
      anbox::protobuf::container::StopContainer const *request,
      anbox::protobuf::rpc::Void *response, google::protobuf::Closure *done);
 private:
  std::shared_ptr&lt;rpc::PendingCallCache&gt; pending_calls_;
  std::shared_ptr&lt;Container&gt; container_;
};
</code></pre>
<p>        这个类的定义很简单，其实现（位于 <code>anbox/src/anbox/container/management_api_skeleton.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace container {
ManagementApiSkeleton::ManagementApiSkeleton(
    const std::shared_ptr&lt;rpc::PendingCallCache&gt; &amp;pending_calls,
    const std::shared_ptr&lt;Container&gt; &amp;container)
    : pending_calls_(pending_calls), container_(container) {}
ManagementApiSkeleton::~ManagementApiSkeleton() {}
void ManagementApiSkeleton::start_container(
    anbox::protobuf::container::StartContainer const *request,
    anbox::protobuf::rpc::Void *response, google::protobuf::Closure *done) {
  if (container_-&gt;state() == Container::State::running) {
    response-&gt;set_error(&quot;Container is already running&quot;);
    done-&gt;Run();
    return;
  }
  Configuration container_configuration;
  const auto configuration = request-&gt;configuration();
  for (int n = 0; n &lt; configuration.bind_mounts_size(); n++) {
    const auto bind_mount = configuration.bind_mounts(n);
    container_configuration.bind_mounts.insert(
        {bind_mount.source(), bind_mount.target()});
  }
  try {
    container_-&gt;start(container_configuration);
  } catch (std::exception &amp;err) {
    response-&gt;set_error(utils::string_format(&quot;Failed to start container: %s&quot;, err.what()));
  }
  done-&gt;Run();
}
void ManagementApiSkeleton::stop_container(
    anbox::protobuf::container::StopContainer const *request,
    anbox::protobuf::rpc::Void *response, google::protobuf::Closure *done) {
  (void)request;
  if (container_-&gt;state() != Container::State::running) {
    response-&gt;set_error(&quot;Container is not running&quot;);
    done-&gt;Run();
    return;
  }
  try {
    container_-&gt;stop();
  } catch (std::exception &amp;err) {
    response-&gt;set_error(utils::string_format(&quot;Failed to stop container: %s&quot;, err.what()));
  }
  done-&gt;Run();
}
}  // namespace container
}  // namespace anbox
</code></pre>
<p>        <code>anbox::container::ManagementApiSkeleton</code> 通过 <code>Container</code> 类启动或停止 Android 容器。配合函数模板 <code>invoke()</code> 的定义，及 Protobuf 的相关方法实现，不难理解， <code>start_container()</code> 和 <code>stop_container()</code> 函数的参数消息，在 <code>invoke()</code> 函数中由 <code>Invocation</code> 消息的参数字段的字节数组反序列化得到，这两个函数的执行过程，都是向 <code>response</code> 参数中填入返回给调用者的响应，并通过 <code>done-&gt;Run()</code> 将响应通过 <code>ManagementApiMessageProcessor::send_response()</code> 函数，即
<code>anbox::rpc::MessageProcessor::send_response()</code> 函数发送回调用端。</p>
<p>        在 <code>anbox::rpc::MessageProcessor::send_response()</code> 函数中，先将响应序列化，然后将序列化之后的响应放进 <code>anbox::protobuf::rpc::Result</code> Protobuf 消息中，最后再将 <code>anbox::protobuf::rpc::Result</code> 包装为 Anbox 的 RPC 消息发送回调用端。</p>
<p>        <code>anbox::container::ManagementApiSkeleton</code> 的 <code>pending_calls_</code> 似乎也没有实际的用处。</p>
<p>        至此整个 RPC 调用接受处理流程结束。整个流程如下图所示：</p>
<p><img src="images/anbox/1315506-38cf3ff3ad5de78e.png" alt="1315506-38cf3ff3ad5de78e" /></p>
<center>图3.19 RPC 调用接受处理流程图</center>
<h3 id="352-会话管理器发起-rpc-调用"><a class="header" href="#352-会话管理器发起-rpc-调用">3.5.2 会话管理器发起 RPC 调用</a></h3>
<p>        在 Anbox 的会话管理器中，通过 <code>anbox::container::Client</code> 发起与容器管理器之间的连接，并处理双方之间的 RPC 通信，这个类的定义（位于 <code>anbox/src/anbox/container/client.h</code>）如下：</p>
<pre><code>class Client {
 public:
  typedef std::function&lt;void()&gt; TerminateCallback;

  Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  ~Client();

  void start(const Configuration &amp;configuration);
  void stop();

  void register_terminate_handler(const TerminateCallback &amp;callback);

 private:
  void read_next_message();
  void on_read_size(const boost::system::error_code &amp;ec,
                    std::size_t bytes_read);

  std::shared_ptr&lt;network::LocalSocketMessenger&gt; messenger_;
  std::shared_ptr&lt;rpc::PendingCallCache&gt; pending_calls_;
  std::shared_ptr&lt;rpc::Channel&gt; rpc_channel_;
  std::shared_ptr&lt;ManagementApiStub&gt; management_api_;
  std::shared_ptr&lt;rpc::MessageProcessor&gt; processor_;
  std::array&lt;std::uint8_t, 8192&gt; buffer_;
  TerminateCallback terminate_callback_;
};
</code></pre>
<p>        <code>anbox::container::Client</code> 主要向外部暴露了两个接口，一是启动容器，二是停止容器，<code>SessionManager</code> 通过这两个接口来控制容器的启动与停止。<code>anbox::container::Client</code> 类的实现（位于 <code>anbox/src/anbox/container/client.cpp</code>）如下：</p>
<pre><code>Client::Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt)
    : messenger_(std::make_shared&lt;network::LocalSocketMessenger&gt;(
          SystemConfiguration::instance().container_socket_path(), rt)),
      pending_calls_(std::make_shared&lt;rpc::PendingCallCache&gt;()),
      rpc_channel_(std::make_shared&lt;rpc::Channel&gt;(pending_calls_, messenger_)),
      management_api_(std::make_shared&lt;ManagementApiStub&gt;(rpc_channel_)),
      processor_(
          std::make_shared&lt;rpc::MessageProcessor&gt;(messenger_, pending_calls_)) {
  read_next_message();
}
Client::~Client() {}
void Client::start(const Configuration &amp;configuration) {
  try {
    management_api_-&gt;start_container(configuration);
  } catch (const std::exception &amp;e) {
    ERROR(&quot;Failed to start container: %s&quot;, e.what());
    if (terminate_callback_)
      terminate_callback_();
  }
}
void Client::stop() {
  management_api_-&gt;stop_container();
}
void Client::register_terminate_handler(const TerminateCallback &amp;callback) {
  terminate_callback_ = callback;
}
void Client::read_next_message() {
  auto callback = std::bind(&amp;Client::on_read_size, this, std::placeholders::_1,
                            std::placeholders::_2);
  messenger_-&gt;async_receive_msg(callback, ba::buffer(buffer_));
}
void Client::on_read_size(const boost::system::error_code &amp;error,
                          std::size_t bytes_read) {
  if (error) {
    if (terminate_callback_)
      terminate_callback_();
    return;
  }
  std::vector&lt;std::uint8_t&gt; data(bytes_read);
  std::copy(buffer_.data(), buffer_.data() + bytes_read, data.data());
  if (processor_-&gt;process_data(data)) read_next_message();
}
</code></pre>
<p>        <code>anbox::container::Client</code> 类在其构造函数中，即通过 Unix 域 Socket 建立了与容器管理器的连接，它通过 <code>ManagementApiStub</code> 发起 RPC 调用。<code>ManagementApiStub</code> 是容器管理器与会话管理器间 RPC 进程间通信在 RPC 调用发起端的接口层，它提供了 *<strong>启动 Android 容器*</strong> 及 *<strong>关闭 Android 容器*</strong> 这样的抽象。在 <code>ManagementApiStub</code> 之下，是容器管理器与会话管理器间 RPC 进程间通信的 RPC 层，即 <code>anbox::rpc::Channel</code>，主要用于处理消息的发送。</p>
<p>        <code>anbox::container::Client</code> 类本身处理连接中原始数据的接收，这里直接用了裸 <code>SocketMessenger</code>，而没有再用 <code>SocketConnection</code> 封装。<code>anbox::container::Client</code> 收到数据之后，会将数据丢给 <code>anbox::rpc::MessageProcessor</code> 处理。类型为<code>anbox::rpc::PendingCallCache</code> 的 <code>pending_calls_</code> 主要用于处理 RPC 的异步调用。在 <code>anbox::rpc::Channel</code> 中，消息发送之后，并不会等待响应的接收，而是在 <code>pending_calls_</code> 中为 RPC 调用注册一个完成回调。在 <code>anbox::rpc::MessageProcessor</code> 中收到响应的消息之后，前面的完成回调被调用，RPC 调用的发起者得到通知。</p>
<p>        <code>anbox::container::Client</code> 中处理 RPC 调用的发起的相关组件的设计框架如下：</p>
<p><img src="images/anbox/1315506-d15316f4575c0a1b.png" alt="1315506-d15316f4575c0a1b" /></p>
<center>图3.20 处理RPC调用相关组件设计框架图</center>
<p>        <code>anbox::container::Client</code> 直接使用 <code>anbox::container::ManagementApiStub</code> 执行 RPC 调用，这个类的定义（位于 <code>anbox/src/anbox/container/management_api_stub.h</code>）如下：</p>
<pre><code>class ManagementApiStub : public DoNotCopyOrMove {
 public:
  ManagementApiStub(const std::shared_ptr&lt;rpc::Channel&gt; &amp;channel);
  ~ManagementApiStub();
  void start_container(const Configuration &amp;configuration);
  void stop_container();
 private:
  template &lt;typename Response&gt;
  struct Request {
    Request() : response(std::make_shared&lt;Response&gt;()), success(true) {}
    std::shared_ptr&lt;Response&gt; response;
    bool success;
    common::WaitHandle wh;
  };
  void container_started(Request&lt;protobuf::rpc::Void&gt; *request);
  void container_stopped(Request&lt;protobuf::rpc::Void&gt; *request);
  mutable std::mutex mutex_;
  std::shared_ptr&lt;rpc::Channel&gt; channel_;
};
</code></pre>
<p>        <code>anbox::container::ManagementApiStub</code> 定义了启动容器和停止容器的接口，并定义了容器启动完成和容器停止完成之后的回调，它还定义了 <code>Request</code> 类，用于封装请求的响应，及一个 <code>WaitHandle</code>。<code>WaitHandle</code> 由 RPC 调用的发起端用于等待请求的结束。</p>
<p>        <code>anbox::container::ManagementApiStub</code> 类的实现（位于 <code>anbox/src/anbox/container/management_api_stub.cpp</code>）如下：</p>
<pre><code>ManagementApiStub::ManagementApiStub(
    const std::shared_ptr&lt;rpc::Channel&gt; &amp;channel)
    : channel_(channel) {}
ManagementApiStub::~ManagementApiStub() {}
void ManagementApiStub::start_container(const Configuration &amp;configuration) {
  auto c = std::make_shared&lt;Request&lt;protobuf::rpc::Void&gt;&gt;();
  protobuf::container::StartContainer message;
  auto message_configuration = new protobuf::container::Configuration;
  for (const auto &amp;item : configuration.bind_mounts) {
    auto bind_mount_message = message_configuration-&gt;add_bind_mounts();
    bind_mount_message-&gt;set_source(item.first);
    bind_mount_message-&gt;set_target(item.second);
  }
  message.set_allocated_configuration(message_configuration);
  {
    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);
    c-&gt;wh.expect_result();
  }
  channel_-&gt;call_method(&quot;start_container&quot;, &amp;message, c-&gt;response.get(),
      google::protobuf::NewCallback(this, &amp;ManagementApiStub::container_started, c.get()));
  c-&gt;wh.wait_for_all();
  if (c-&gt;response-&gt;has_error()) throw std::runtime_error(c-&gt;response-&gt;error());
}
void ManagementApiStub::container_started(Request&lt;protobuf::rpc::Void&gt; *request) {
  request-&gt;wh.result_received();
}
void ManagementApiStub::stop_container() {
  auto c = std::make_shared&lt;Request&lt;protobuf::rpc::Void&gt;&gt;();
  protobuf::container::StopContainer message;
  message.set_force(false);
  {
    std::lock_guard&lt;decltype(mutex_)&gt; lock(mutex_);
    c-&gt;wh.expect_result();
  }
  channel_-&gt;call_method(&quot;stop_container&quot;, &amp;message, c-&gt;response.get(),
      google::protobuf::NewCallback(this, &amp;ManagementApiStub::container_stopped, c.get()));
  c-&gt;wh.wait_for_all();
  if (c-&gt;response-&gt;has_error()) throw std::runtime_error(c-&gt;response-&gt;error());
}
void ManagementApiStub::container_stopped(Request&lt;protobuf::rpc::Void&gt; *request) {
  request-&gt;wh.result_received();
}
</code></pre>
<p>        尽管实际的 RPC 调用是异步的，但 <code>anbox::container::ManagementApiStub</code> 类通过条件变量为其调用者提供了一种同步执行的假象。启动容器和停止容器的行为通过另外的 Protobuf 消息来描述，这些消息的定义（位于 <code>anbox/src/anbox/protobuf/anbox_container.proto</code>）如下：</p>
<pre><code>package anbox.protobuf.container;
message Configuration {
    message BindMount {
        required string source = 1;
        required string target = 2;
    }
    repeated BindMount bind_mounts = 1;
}
message StartContainer {
    required Configuration configuration = 1;
}
message StopContainer {
    optional bool force = 1;
}
</code></pre>
<p>        在 <code>ManagementApiStub::start_container()</code> 和 <code>ManagementApiStub::stop_container()</code> 函数中，将参数封装进对应的 Protobuf 消息中，然后更新 <code>Request</code> 的 <code>WaitHandle</code> 中用于表示期待接收到的响应的状态，随后通过 <code>anbox::rpc::Channel</code> 发起 RPC 调用并注册完成回调，最后等待在 <code>Request</code> 的 <code>WaitHandle</code> 上。</p>
<p>        启动容器和停止容器的 RPC 调用完成之后，对应的回调被调用，它们通过相应的请求的 <code>WaitHandle</code> 通知调用结束，<code>ManagementApiStub::start_container()</code> 和 <code>ManagementApiStub::stop_container()</code> 函数返回。</p>
<p>        <code>ManagementApiStub</code> 的设计实际上有几处问题。首先是定义的 <code>mutex_</code> 成员，看上去毫无意义；其次是等待的方法 <code>wait_for_all()</code>，这个函数会一直等待条件成立，如果容器管理器进程意外终止，或者由于其它什么原因，无法给会话管理器发回响应消息，则会话管理器会一直等在那里无法结束，正确的做法应该用有超时的等待，等待一段时间之后，就假设启动容器失败，并退出。</p>
<p>        可以看一下 <code>WaitHandle</code> 的设计与实现。这个类的定义（位于 <code>anbox/src/anbox/common/wait_handle.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace common {
struct WaitHandle {
 public:
  WaitHandle();
  ~WaitHandle();
  void expect_result();
  void result_received();
  void wait_for_all();
  void wait_for_one();
  void wait_for_pending(std::chrono::milliseconds limit);
  bool has_result();
  bool is_pending();
 private:
  std::mutex guard;
  std::condition_variable wait_condition;
  int expecting;
  int received;
};
}  // namespace common
}  // namespace anbox
</code></pre>
<p>        <code>WaitHandle</code> 封装标准库的 <code>std::mutex</code> 和 <code>std::condition_variable</code> 来构造等待设施。这个类的实现（位于 <code>anbox/src/anbox/common/wait_handle.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace common {
WaitHandle::WaitHandle()
    : guard(), wait_condition(), expecting(0), received(0) {}
WaitHandle::~WaitHandle() {}
void WaitHandle::expect_result() {
  std::lock_guard&lt;std::mutex&gt; lock(guard);
  expecting++;
}
void WaitHandle::result_received() {
  std::lock_guard&lt;std::mutex&gt; lock(guard);
  received++;
  wait_condition.notify_all();
}
void WaitHandle::wait_for_all()  // wait for all results you expect
{
  std::unique_lock&lt;std::mutex&gt; lock(guard);
  wait_condition.wait(lock, [&amp;] { return received == expecting; });
  received = 0;
  expecting = 0;
}
void WaitHandle::wait_for_pending(std::chrono::milliseconds limit) {
  std::unique_lock&lt;std::mutex&gt; lock(guard);
  wait_condition.wait_for(lock, limit, [&amp;] { return received == expecting; });
}
void WaitHandle::wait_for_one()  // wait for any single result
{
  std::unique_lock&lt;std::mutex&gt; lock(guard);
  wait_condition.wait(lock, [&amp;] { return received != 0; });
  --received;
  --expecting;
}
bool WaitHandle::has_result() {
  std::lock_guard&lt;std::mutex&gt; lock(guard);
  return received &gt; 0;
}
bool WaitHandle::is_pending() {
  std::unique_lock&lt;std::mutex&gt; lock(guard);
  return expecting &gt; 0 &amp;&amp; received != expecting;
}
}  // namespace common
}  // namespace anbox
</code></pre>
<p>        需要等待的一端，通过调用 <code>expect_result()</code> 来告诉 <code>WaitHandle</code>，需要等待多接收一个响应，并通过 <code>wait_for_all()</code>、<code>wait_for_pending()</code> 和 <code>wait_for_one()</code> 来等待结果的出现。处理收到的消息的线程，通过 <code>result_received()</code> 通知等待的线程。</p>
<p>        <code>anbox::rpc::PendingCallCache</code> 是一个容器，用于保存已经发送了请求消息，已经发起但还没有得到响应的 RPC 调用的描述及完成回调，这个类的定义（位于 <code>anbox/src/anbox/rpc/pending_call_cache.h</code>）如下：</p>
<pre><code>class PendingCallCache {
 public:
  PendingCallCache();
  void save_completion_details(
      anbox::protobuf::rpc::Invocation const &amp;invocation,
      google::protobuf::MessageLite *response,
      google::protobuf::Closure *complete);
  void populate_message_for_result(
      anbox::protobuf::rpc::Result &amp;result,
      std::function&lt;void(google::protobuf::MessageLite *)&gt; const &amp;populator);
  void complete_response(anbox::protobuf::rpc::Result &amp;result);
  void force_completion();
  bool empty() const;
 private:
  struct PendingCall {
    PendingCall(google::protobuf::MessageLite *response,
                google::protobuf::Closure *target)
        : response(response), complete(target) {}
    PendingCall() : response(0), complete() {}
    google::protobuf::MessageLite *response;
    google::protobuf::Closure *complete;
  };
  std::mutex mutable mutex_;
  std::map&lt;int, PendingCall&gt; pending_calls_;
};
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        <code>anbox::rpc::PendingCallCache</code> 类还定义一个 <code>PendingCall</code> 用于封装请求的响应对象及完成回调，它用一个 map 保存 <code>PendingCall</code>，由于需要在 <code>anbox::rpc::MessageProcessor::process_data()</code> 和 <code>anbox::rpc::Channel</code> 的线程中访问，为了线程安全计，每次访问都有锁进行保护。</p>
<p>        <code>anbox::rpc::PendingCallCache</code> 类的实现（位于 <code>anbox/src/anbox/rpc/pending_call_cache.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
PendingCallCache::PendingCallCache() {}
void PendingCallCache::save_completion_details(
    anbox::protobuf::rpc::Invocation const&amp; invocation,
    google::protobuf::MessageLite* response,
    google::protobuf::Closure* complete) {
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  pending_calls_[invocation.id()] = PendingCall(response, complete);
}
void PendingCallCache::populate_message_for_result(
    anbox::protobuf::rpc::Result&amp; result,
    std::function&lt;void(google::protobuf::MessageLite*)&gt; const&amp; populator) {
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  populator(pending_calls_.at(result.id()).response);
}
void PendingCallCache::complete_response(anbox::protobuf::rpc::Result&amp; result) {
  PendingCall completion;
  {
    std::unique_lock&lt;std::mutex&gt; lock(mutex_);
    auto call = pending_calls_.find(result.id());
    if (call != pending_calls_.end()) {
      completion = call-&gt;second;
      pending_calls_.erase(call);
    }
  }
  if (completion.complete) completion.complete-&gt;Run();
}
void PendingCallCache::force_completion() {
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  for (auto&amp; call : pending_calls_) {
    auto&amp; completion = call.second;
    completion.complete-&gt;Run();
  }
  pending_calls_.erase(pending_calls_.begin(), pending_calls_.end());
}
bool PendingCallCache::empty() const {
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  return pending_calls_.empty();
}
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        <code>save_completion_details()</code> 用于向 <code>anbox::rpc::PendingCallCache</code> 中放入调用，<code>populate_message_for_result()</code> 用于把返回的响应消息塞给调用，<code>complete_response()</code> 则用于通知结果的返回，调用对应的完成回调。</p>
<p>        <code>anbox::rpc::Channel</code> 用于序列化消息，并发送出去，其定义（位于 <code>anbox/src/anbox/rpc/channel.h</code>）如下：</p>
<pre><code>class Channel {
 public:
  Channel(const std::shared_ptr&lt;PendingCallCache&gt; &amp;pending_calls,
          const std::shared_ptr&lt;network::MessageSender&gt; &amp;sender);
  ~Channel();
  void call_method(std::string const &amp;method_name,
                   google::protobuf::MessageLite const *parameters,
                   google::protobuf::MessageLite *response,
                   google::protobuf::Closure *complete);
  void send_event(google::protobuf::MessageLite const &amp;event);
 private:
  protobuf::rpc::Invocation invocation_for(
      std::string const &amp;method_name,
      google::protobuf::MessageLite const *request);
  void send_message(const std::uint8_t &amp;type,
                    google::protobuf::MessageLite const &amp;message);
  std::uint32_t next_id();
  void notify_disconnected();
  std::shared_ptr&lt;PendingCallCache&gt; pending_calls_;
  std::shared_ptr&lt;network::MessageSender&gt; sender_;
  std::mutex write_mutex_;
};
</code></pre>
<p>        <code>anbox::rpc::Channel</code> 负责为每个调用消息分配 ID。<code>anbox::rpc::Channel</code> 实现（位于 <code>anbox/src/anbox/rpc/channel.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
Channel::Channel(const std::shared_ptr&lt;PendingCallCache&gt; &amp;pending_calls,
                 const std::shared_ptr&lt;network::MessageSender&gt; &amp;sender)
    : pending_calls_(pending_calls), sender_(sender) {}
Channel::~Channel() {}
void Channel::call_method(std::string const &amp;method_name,
                          google::protobuf::MessageLite const *parameters,
                          google::protobuf::MessageLite *response,
                          google::protobuf::Closure *complete) {
  auto const &amp;invocation = invocation_for(method_name, parameters);
  pending_calls_-&gt;save_completion_details(invocation, response, complete);
  send_message(MessageType::invocation, invocation);
}
void Channel::send_event(google::protobuf::MessageLite const &amp;event) {
  VariableLengthArray&lt;2048&gt; buffer{static_cast&lt;size_t&gt;(event.ByteSize())};
  event.SerializeWithCachedSizesToArray(buffer.data());
  anbox::protobuf::rpc::Result response;
  response.add_events(buffer.data(), buffer.size());
  send_message(MessageType::response, response);
}
protobuf::rpc::Invocation Channel::invocation_for(
    std::string const &amp;method_name,
    google::protobuf::MessageLite const *request) {
  anbox::VariableLengthArray&lt;2048&gt; buffer{
      static_cast&lt;size_t&gt;(request-&gt;ByteSize())};
  request-&gt;SerializeWithCachedSizesToArray(buffer.data());
  anbox::protobuf::rpc::Invocation invoke;
  invoke.set_id(next_id());
  invoke.set_method_name(method_name);
  invoke.set_parameters(buffer.data(), buffer.size());
  invoke.set_protocol_version(1);
  return invoke;
}
void Channel::send_message(const std::uint8_t &amp;type,
                           google::protobuf::MessageLite const &amp;message) {
  const size_t size = message.ByteSize();
  const unsigned char header_bytes[header_size] = {
      static_cast&lt;unsigned char&gt;((size &gt;&gt; 8) &amp; 0xff),
      static_cast&lt;unsigned char&gt;((size &gt;&gt; 0) &amp; 0xff), type,
  };
  std::vector&lt;std::uint8_t&gt; send_buffer(sizeof(header_bytes) + size);
  std::copy(header_bytes, header_bytes + sizeof(header_bytes),
            send_buffer.begin());
  message.SerializeToArray(send_buffer.data() + sizeof(header_bytes), size);
  try {
    std::lock_guard&lt;std::mutex&gt; lock(write_mutex_);
    sender_-&gt;send(reinterpret_cast&lt;const char *&gt;(send_buffer.data()),
                  send_buffer.size());
  } catch (std::runtime_error const &amp;) {
    notify_disconnected();
    throw;
  }
}
void Channel::notify_disconnected() { pending_calls_-&gt;force_completion(); }
std::uint32_t Channel::next_id() {
  static std::uint32_t next_message_id = 0;
  return next_message_id++;
}
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>        <code>call_method()</code> 用于发起 RPC 调用，这个函数将 RPC 调用描述及完成回调保存进 <code>pending_calls_</code> 中，随后发送消息。<code>anbox::rpc::Channel</code> 主要在操作 Protobuf 消息的序列化，此处不再赘述。</p>
<p>        可以再看一下 RPC 调用发起端收到响应消息时的处理，主要是 <code>anbox::rpc::MessageProcessor</code> 的下面这一段（位于 <code>anbox/src/anbox/rpc/message_processor.cpp</code>）：</p>
<pre><code> } else if (message_type == MessageType::response) {
    auto result = make_protobuf_object&lt;protobuf::rpc::Result&gt;();
    result-&gt;ParseFromArray(buffer_.data() + header_size, message_size);
    if (result-&gt;has_id()) {
      pending_calls_-&gt;populate_message_for_result(*result,
                                                  [&amp;](google::protobuf::MessageLite *result_message) {
                                                    result_message-&gt;ParseFromString(result-&gt;response());
                                                  });
      pending_calls_-&gt;complete_response(*result);
    }
    for (int n = 0; n &lt; result-&gt;events_size(); n++)
      process_event_sequence(result-&gt;events(n));
  }
  buffer_.erase(buffer_.begin(),
                buffer_.begin() + header_size + message_size);
}
</code></pre>
<p>        这段代码将响应消息塞给 <code>pending_calls_</code> 中保存的对应的 <code>Invocation</code>，并调用完成回调。</p>
<p>        Anbox 中会话管理器与容器管理器通过两个 RPC 调用进行通信，在调用发起端的整个处理过程如下图：</p>
<p><img src="images/anbox/1315506-3963e61469988d3b.png" alt="1315506-3963e61469988d3b" /></p>
<p><img src="images/anbox/1315506-c7ecc094bd317088.png" alt="1315506-c7ecc094bd317088" /></p>
<center>图3.21 调用发起端处理流程图</center><div style="break-before: page; page-break-before: always;"></div><h1 id="4-bitcomet实验测试"><a class="header" href="#4-bitcomet实验测试">4. Bitcomet实验测试</a></h1>
<p>        由于Bitcomet是一款基于Anbox方案进行移植，实现Android 11系统在Linux平台上运行的产品，其相关资料缺乏，因此市面上并没有针对此类产品进行测试的工具，我们利用了市场上主流的Android基准测试应用，选取安兔兔AI以及Geekbench4.0两款评估APP对Bitcomet进行性能评估测试，这样能简洁有效地衡量bitcomet运行安卓的效率。同时为了对比Bitcomet的性能优势，同时选用市场占有率较高的Genymotion模拟器进行同步测试。Genymotion是一款优秀专业高性能的安卓Android模拟器，它同时支持 Windows、Mac以及Linux平台，其模拟运行速度优秀，画面流畅、且支持模拟器多开、全屏等特性，充分经过了市场的认证，在模拟器领域占有一席之地。因此本次实验将Genymotion作为Bitcomet的性能参照及对比对象。</p>
<p>        本次测试的基本思路为：首先，测试Bitcomet的系统运行功能，确保其能够实现Android系统的正常开启及进入系统界面。其次，测试系统各项主要功能是否正常，主要分为三个内容：其一，测试基础信息是否正常显示；其二，测试基础功能是否正常运行；其三，测试基础应用是否能够正常运行，以及是否支持第三方应用安装与运行。再者，测试Bitcomet内运行Android的CPU工作效率，对比模拟器是否有CPU利用效率上的差距。最后，测试Bitcomet对于内存开销的情况，对比模拟器是否有内存占用较低的优势。</p>
<h2 id="41-实验准备"><a class="header" href="#41-实验准备">4.1 实验准备</a></h2>
<h3 id="411-环境准备"><a class="header" href="#411-环境准备">4.1.1 环境准备</a></h3>
<p>         本次测试环境硬件参数表4.1所示。</p>
<center>表4.1 环境硬件参数</center>
<center><img src=images/3.实验测试/测试环境参数配置.png></center>
<h3 id="412-实验策略"><a class="header" href="#412-实验策略">4.1.2 实验策略</a></h3>
<p>        Genymotion与Bitcomet两者的实现架构有所不同，前者采用市面上目前大多数模拟器产品都在使用的虚拟化实现方案，而后者则创新性地使用了Dokcer以提供安卓运行的环境的方案。</p>
<p>        为了测试Bitcomet功能完整性以及展现其性能优异的特点，同时为了保证测试的公平性以及方便后续的调试与开发，本次测试统一环境，采用物理机搭配Ubuntu20.04系统方案作为测试环境。</p>
<p>        根据前文所讲述的测试思路，本次测试制定如下测试策略。</p>
<h4 id="1-系统运行测试"><a class="header" href="#1-系统运行测试">(1) 系统运行测试</a></h4>
<p>        系统运行测试主要是测试系统从镜像下载到环境搭建以及最终运行的一系列步骤，测试其最终是否能正常启动。总结系统运行测试的基本步骤为：<br />
        ① 下载测试镜像。<br />
        ② 安装Docker环境，并加载内核模块和挂载binder文件系统。<br />
        ③ 启动Bitcomet并进入Android shell模式。<br />
        ④ 执行logcat查看启动日志。<br />
        ⑤ 利用QtScrcpy投屏软件连接Bitcomet显示Android界面。</p>
<h4 id="2-系统功能测试"><a class="header" href="#2-系统功能测试">(2) 系统功能测试</a></h4>
<p>        系统功能测试是验证Bitcomet在Linux下容器启动方案的重要部分。主要是验证Bitcomet基本功能使用和应用程序的运行情况。系统功能测试主要分为三个测试内容：<br />
        ① 基础信息测试，测试其是否能够显示设定的设备名称与型号。<br />
        ② 基础功能测试，测试其是否能修改系统默认语言。<br />
        ③ 基础应用测试，测试其通信录，闹钟，浏览器等系统自带应用以及第三方应用是否能够正常使用。</p>
<h4 id="3-cpu性能测试"><a class="header" href="#3-cpu性能测试">(3) CPU性能测试</a></h4>
<p>        本次测试采用统一环境，该项测试结果可认为是两种方案运行Android系统其CPU利用效率的对比。本次测试利用安兔兔AI评测App以及GeekBench App进行CPU性能评估。其中安兔兔AI评测主要是针对CPU中的AI运算能力进行针对性分析，其使用目前主流的Inception v3和MobileNet-SSD两种神经网络模型，进行Image Classification和Object Detection两项关键测试，基于准确率和速度等指标，对设备的AI运算能力进行综合评估。而Geekbench是一个跨平台基准测试工具，可以同时应用于多种平台之上例如windows、Android以及IOS，其重点考察CPU的运算能力。遂CPU测试主要分为三个测试内容：<br />
        ① 利用安兔兔AI App对Bitcomet以及Genymotion进行Image Classification测试。<br />
        ② 利用安兔兔AI App对Bitcomet以及Genymotion进行Object Detection测试。<br />
        ③ 利用Geekbench App对Bitcomet以及Genymotion进行CPU运算能力测试。</p>
<h4 id="4-内存开销测试"><a class="header" href="#4-内存开销测试">(4) 内存开销测试</a></h4>
<p>        本次测试还对Bitcomet与Genymotion运行时内存开销情况进行对比，分别测试仅运行Genymotion模拟器启动Android系统和仅运行Bitcomet启动Android系统情况下的内存开销情况。总结内存开销测试步骤为：<br />
        ① 仅运行Genymotion， 启动Android系统。<br />
        ② 记录内存开销情况。<br />
        ③ 仅运行Bitcomet，启动Android系统。<br />
        ④ 记录内存开销情况。</p>
<h2 id="42-实验结果及分析"><a class="header" href="#42-实验结果及分析">4.2 实验结果及分析</a></h2>
<h3 id="421-系统运行测试结果及分析"><a class="header" href="#421-系统运行测试结果及分析">4.2.1 系统运行测试结果及分析</a></h3>
<p>        根据测试步骤，下载测试镜像，安装环境并加载启动Bitcomet所需模块后，Bitcomet可成功启动，通过相关命令可以进入Android shell模式，QtScrcpy投屏软件可以连接Bitcomet并显示Android界面。系统成功启动，运行正常。</p>
<h3 id="422-系统功能测试结果及分析"><a class="header" href="#422-系统功能测试结果及分析">4.2.2 系统功能测试结果及分析</a></h3>
<p>        根据测试内容，本次测试为系统功能测试设计如下测试用例：</p>
<center>表4.2 基础信息测试用例</center>
<center><img src=images/3.实验测试/基础信息测试.png></center>
<p>        在基础信息测试中，各测试用例所得结果均与预期结果一致，设备名称与型号可根据用户设定显示，基础信息测试全部正常。</p>
<center>表4.3 基础功能测试用例</center>
<center><img src="images/3.实验测试/基础功能测试.png" alt="基础功能测试"  /></center>
<p>        在基础功能测试中，系统语言可根据用户定义显示，蓝牙，WIFI功能无法正常使用，基础功能测试部分正常。</p>
<center>表4.4 基础应用测试用例</center>
<center><img src=images/3.实验测试/基础应用测试.png></center>
<p>        在基础应用测试中，各测试用例所得结果均与预期结果一致，通讯录、闹铃、浏览器等系统App以及第三方App均可正常使用，基础应用测试全部正常。</p>
<h3 id="423-cpu性能测试结果及分析"><a class="header" href="#423-cpu性能测试结果及分析">4.2.3 CPU性能测试结果及分析</a></h3>
<p>        为了方便观察，同时两个app主要展示CPU性能效率的不同，所以本节实验将Bitcomet与Genymotion利用安兔兔AI App进行Image Classification和Object Detection两项关键测试与Geekbench App对CPU进行单核与多核测试结果进行集中对比分析，其结果如图4.1、4.2所示。</p>
<center><img src=images/3.实验测试/安兔兔AI评测得分情况.png></center>
<center>图4.1 安兔兔AI测试得分对比图</center>
<center><img src=images/3.实验测试/Geekbench测试得分情况.png></center>
<center>图4.2 Geekbench测试得分对比图</center>
<p>        在本次测试中，因Genymotion与Bitcomet所依赖硬件环境相同，故两者最终分数即为对CPU利用效率的评分。</p>
<p>        从图4.1中可以看出Bitcomet最终得分相较于Genymotion有显著提升。相比Genymotion模拟器，Bitcomet的总分高出约22%，主要体现在Image Classification-Speed和Object Detection-Speed上。说明在AI算力上面Bitcomet对比Genymotion表现不俗。</p>
<p>        在Geekbench测试中，Bitcomet多核得分高出Genymotion得分约14%。比较CPU时，在Android移动端设备上，14%的性能提升相当于当今移动端旗舰级芯片高通骁龙865和高通骁龙888的性能差距(数据来自：移动芯片性能排行榜，链接:www.socpk.com)，也就是芯片厂商用一年时间更迭优化出的性能。</p>
<p>        两个测试都证明了Bitcomet在CPU的利用效率上对比模拟器具有显著优势。CPU是每一台计算机的运算和控制核心，无论是Android手机还是平板甚至是家里的智能微波炉，都可以算是一台计算机。CPU在Android应用上面尤为重要，因为在用户除了游戏之外的方方面面都扮演了重要的角色。无论是打开一个视频进行观看，需要CPU的解码器进行视频解码，还是点开网页进行浏览，都需要CPU的身影。特别是日常办公场景下，CPU的作用和需求无疑是比GPU大。所以Bitcomet在CPU的利用效率上的显著优势在办公场景就会更加明显突出。</p>
<p>        Bitcomet在CPU利用效率方面相比较Genymotion有如此大的提升，其主要原因是在于Genymotion采用的是虚拟化技术，而虚拟化是在硬件层之上进行了封装，相比于Bitcomet采用的基于容器技术，虚拟化技术必然会损失一部分硬件性能。</p>
<h3 id="424-内存开销测试结果及分析"><a class="header" href="#424-内存开销测试结果及分析">4.2.4 内存开销测试结果及分析</a></h3>
<p>        本次还对两者运行时内存开销情况进行对比分析，分别测试仅打开Genymotion启动Android系统和仅打开Bitcomet启动Android系统，不运行任何其他应用程序，记录其内存的开销情况，具体情况如图4.3所示。</p>
<center><img src=images/3.实验测试/内存占用情况.png></center>
<center>图4.3 内存开销情况对比图</center>
<p>        从图3.3中可以看出，在同等情况下，Bitcomet在内存占用方面远低于Genymotion。Bitcomet在内存开销上的优势使得在相同硬件条件下，Bitcomet可实现比Genymotion更加多的后台App留存率，这对用 户的体验至关重要。我们使用Android系统时，经常在看视频的时候会回微信消息，这就要求我们在开启 视频应用在前台运行的同时，后台程序微信必须有足够的内存空间让其在后台保持运行，如果内存不足的话用户就可能在看视频，玩游戏的时候错过重要的消息通知。内存占用率的优势可以显著提高用户体验。</p>
<p>        Bitcomet采用基于容器技术，不同于普通的模拟器需要执行完整的硬件资源虚拟化，更有着更少的抽象层，所以在内存占用的优势上面会比虚拟机大。</p>
<h2 id="43-测试总结"><a class="header" href="#43-测试总结">4.3 测试总结</a></h2>
<p>        在系统运行测试，系统功能测试部分，Bitcomet已成功在Ubuntu20.04下运行。除部分功能未完善外，通讯录，闹铃，浏览器等基础应用及系统基础信息均可正常使用与显示，也可根据需求安装第三方软件。</p>
<p>        通过Bitcomet与Genymotion在CPU性能测试与内存开销测试的情况对比可知，Bitcomet无论是在CPU利用效率还是内存开销上都优于Genymotion，这说明即便是在硬件性能较低的机器上，Bitcomet性能表现也可超越市场上同类型模拟器。当然不仅仅是应用于性能较低的机器上。更多的在虚拟化的场景下，规模越大，15%性能提升带来的经济性就会越明显。以十作为单位的这个数量等级上，可能我们15%的性能提升可以少买两台机子达到同样的性能，但是虚拟化更多的时以百，以千做单位。在虚拟化领域每一度电都要“斤斤计较”现状下，15%的提升显然是不可忽视的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-运行方法与参考借鉴"><a class="header" href="#5-运行方法与参考借鉴">5 运行方法与参考借鉴</a></h1>
<h3 id="编译android镜像"><a class="header" href="#编译android镜像">编译Android镜像</a></h3>
<h3 id="51-下载安装repo"><a class="header" href="#51-下载安装repo">5.1 下载安装repo</a></h3>
<pre><code class="language-shell"># 下载repo，参考了清华源的https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/的帮助
mkdir ~/bin
curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo
chmod a+x ~/bin/repo
# 临时配置repo使用国内清华源镜像，也可以加入~/.bashrc永久配置
export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo'
# 在android目录下初始化repo使用当前manifests仓库来下载代码
</code></pre>
<h3 id="52-拉取源码"><a class="header" href="#52-拉取源码">5.2 拉取源码</a></h3>
<h4 id="521-bitcomet-demo1版本代码"><a class="header" href="#521-bitcomet-demo1版本代码">5.2.1 Bitcomet Demo1版本代码</a></h4>
<pre><code class="language-shell">mkdir android &amp;&amp; cd android
repo init -u https://gitlab.eduxiji.net/Willzen/project788067-124647.git -b bitcomet-demo1
# repo开始同步拉取
repo sync
</code></pre>
<h4 id="522-anbox-android10的测试代码调试图形输出用"><a class="header" href="#522-anbox-android10的测试代码调试图形输出用">5.2.2 Anbox Android10的测试代码（调试图形输出用）</a></h4>
<pre><code class="language-shell">mkdir android &amp;&amp; cd android
repo init -u https://gitlab.eduxiji.net/Willzen/project788067-124647.git -b anbox10
# repo开始同步拉取
repo sync
</code></pre>
<h4 id="523-bitcomet决赛最终代码"><a class="header" href="#523-bitcomet决赛最终代码">5.2.3 Bitcomet决赛最终代码</a></h4>
<pre><code class="language-shell">mkdir android &amp;&amp; cd android
repo init -u https://gitlab.eduxiji.net/Willzen/project788067-124647.git
# repo开始同步拉取
repo sync
</code></pre>
<h3 id="53-编译安卓镜像"><a class="header" href="#53-编译安卓镜像">5.3 编译安卓镜像</a></h3>
<pre><code class="language-shell"># 切换进android目录，引入环境变量
cd android
source build/envsetup.sh
# 选择编译工程
lunch anbox_x86_64-userdebug
# 开始编译(-j32表示最大用32线程去编译，请根据现有自己CPU核心数选择)
make -j32
# 编译成功后打包镜像
pack
</code></pre>
<h3 id="54-编译anbox第一版demo不需要"><a class="header" href="#54-编译anbox第一版demo不需要">5.4 编译Anbox（第一版Demo不需要）</a></h3>
<pre><code class="language-shell"># 下载本项目的Anbox源码
git clone https://gitlab.eduxiji.net/Willzen/proj156_vendor_anbox.git
# 进入源码目录
cd proj156_vendor_anbox
# 编译
mkdir build
cd build
cmake ..
make -j8
# 编译成功的二进制文件在build/src/anbox
</code></pre>
<h3 id="55-测试运行"><a class="header" href="#55-测试运行">5.5 测试运行</a></h3>
<p>注意以下步骤需要<strong>root权限</strong></p>
<h4 id="551-第一版demo测试方法"><a class="header" href="#551-第一版demo测试方法">5.5.1 第一版Demo测试方法</a></h4>
<pre><code class="language-shell"># 挂载打包后工程当前目录下出现的android.img镜像
mkdir tmp
mount android.img tmp
# 导入镜像到Dokcer
cd tmp
tar --xattrs -c . | sudo  docker import - bitcomet:latest
# 检查Ubuntu 20.04内核的BinderFS能否正常挂载
mkdir /dev/binderfs
mount -t binder binder /dev/binderfs
# 运行Docker的Android容器
docker run -itd --rm --memory-swappiness=0 --privileged -p 5555:5555 --name bitcomet bitcomet:latest /init androidboot.hardware=bitcomet
</code></pre>
<h4 id="552-bitcomet决赛最终方案测试方法"><a class="header" href="#552-bitcomet决赛最终方案测试方法">5.5.2 Bitcomet决赛最终方案测试方法</a></h4>
<pre><code class="language-shell"># 挂载打包后工程当前目录下出现的android.img镜像
mkdir tmp
mount android.img tmp
# 导入镜像到Dokcer
cd tmp
tar --xattrs -c . | sudo  docker import - bitcomet:latest
# 检查Ubuntu 20.04内核的BinderFS能否正常挂载
mkdir /dev/binderfs
mount -t binder binder /dev/binderfs
# 运行Anbox的Session Manager
./anbox session-manager --standalone --experimental
# 运行Docker的Android容器
ddocker run -itd --rm --memory-swappiness=0 --privileged -p 5555:5555 --name anbox -v /run/user/1000/anbox/sockets/qemu_pipe:/dev/qemu_pipe -v /run/user/1000/anbox/sockets/anbox_audio:/dev/anbox_audio:rw -v /run/user/1000/anbox/sockets/anbox_bridge:/dev/anbox_bridge:rw -v /run/user/1000/anbox/input/event0:/dev/input/event0:rw -v /run/user/1000/anbox/input/event1:/dev/input/event1:rw -v /run/user/1000/anbox/input/event2:/dev/input/event2:rw anbox:test22 /init androidboot.hardware=goldfish
# 使用Anbox launch打开Launher启动器APP
./anbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="61-遇到的主要问题和解决方法"><a class="header" href="#61-遇到的主要问题和解决方法">6.1 遇到的主要问题和解决方法</a></h2>
<p>        因构建Android需要一定的磁盘空间以及CPU资源，本次比赛项目构建编译主要在服务器上进行。</p>
<ol>
<li>
<p>问题：在运行Android过程中发现服务器网络环境崩溃，无法连接，在联系机房管理员重启网络后，确认本次网络崩溃由本项目引起。在对本项目可能导致网络崩溃部分进行逐个排查时，发现编译后的Android网络组件在运行时会导致此情况发生，确定该故障为网络组件出现错误所引发。<br />
        解决方法：经过网上搜索资料以及多次尝试后，发现取消Docker的特权模式，调整Docker为非特权模式下运行Android11容器则不会出现此问题，或将所编译后的镜像打包下载到本地系统，采用虚拟化方式运行也可正常运行。</p>
</li>
<li>
<p>问题：QtScrcpy投屏软件未能搜索到Android设备，排除Andorid系统自身问题后，确认问题在宿主机系统环境上。<br />
        解决方法：经过查找资料，发现本虚拟机的网络组件配置有问题，如果宿主机需要用到端口进行操作，需要将虚拟化软件设置开启端口映射，映射adb默认端口5555才能解决，后面重置虚拟机网络组件彻底解决了该问题。</p>
</li>
<li>
<p>问题：在Android 11中，移植好Anbox的图形实现部分的各个HAL层，实际测试发现无法启动SystemUI Service。<br />
        排查过程：经过Anbox通信层连通性测试，Anbox的通信层RPC调用测试，发现均连通并实现RPC调用获得返回值。排除通信层的问题，遂排查相关日志和流程，发现是Android 11中没有调用Anbox的HWC实现，而走了Gralloc的发送到Framebuffer的实现。计划从模块和安卓工程进行调试并排查问题进行解决。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="62-比赛收获"><a class="header" href="#62-比赛收获">6.2 比赛收获</a></h2>
<h3 id="621-比赛收获"><a class="header" href="#621-比赛收获">6.2.1 比赛收获</a></h3>
<p>        这次是我们小组第一次参加全国大学生计算机系统能力大赛操作系统设计赛，可谓收获满满。以前在课堂上学到的主要都是一些操作系统的经典理论，如进程管理中的同步互斥、PV操作、进程调度算法、银行家算法、死锁等；在存储管理中的内存分配机制和虚存管理中的各种页面置换算法等。通过这次参赛，不断参加主办方组织的技术培训会，我们学到了很多在课堂上接触不到的知识，开阔了视野，增加了对操作系统最新行业发展方向的动态了解。在比赛的过程中，我们也查阅了大量跟操作系统相关的资料，攻克一道又一道的难关，对个人能力也是也一个很好的提升，具体收获如下：</p>
<p>        (1). <strong>接触到先进的项目管理方式</strong>：我们的实践能力得到了很大的提升和锻炼，接触了很多开发环境才会用到的东西比如说利用git实现项目的同步，更加科学有效的管理自己的项目，比之前我们出错了还要一步步试出，打快照来备份是一个非常大的改善，修改问题只需要返回之前的提交节点即可，这些都是之前单纯在课堂上学习接触不来的。<br />
        (2). <strong>团队协作能力的提升</strong>：这次比赛也同时使我也更加的能够融入整个小组。现在的我对于团队协作有了很大的提升和理解，在团队当中每个人会有不同的分工，要把自己的那一部分给处理好才是重中之重，不能因为某一环节而掉了链子。这跟之前的作业有很大的区别。<br />
        (3). <strong>目标导向的做事方式</strong>：这次大赛的目标非常清晰明确，也给予了相当的参考，方便了我们规划项目，我们规划能力也得到了锻炼。我们学会了朝着自己的目标一步步设置里程碑，去一步步靠近真正的目标，而不是像之前无头苍蝇一样做到哪里就算到哪里，目标明确之后带来的效率的提升也是实打实的。<br />
        (4). <strong>实践能力的提升</strong>：在理论知识用于实践的能力上也得到了很大的提高，我们理论知识可以用于对我们搭建出来的初步项目的排错，这些成功的排错又可以反过来复习巩固我们的理论知识，是双赢的操作。<br />
        (5). <strong>编码能力的提升</strong>：在这次项目当中我们审计了非常多的代码，比在课堂上的磨炼要多得多，对于Android各个模块的理解也有了长足的提升，这些能力的提升只靠单纯的课堂是远远不够的，还是需要这种实践机会。<br />
        (6). <strong>开阔视野</strong>：大赛带给我的远不止于此，它更是开阔了我的眼界，跟这么多所高校志同道合的人同台竞技更是带来了很强的新鲜感和成就感。</p>
<p>        所以非常感谢这次的大赛，本次的参赛经验将作为我们人生中的一次宝贵经历让我们铭记于心，也希望这次大赛我们小组能够取得奖项，为团队，为学校，为未来能在操作系统有一席之地打下坚实的基础。</p>
<h3 id="622-与导师的沟通情况与导师等是否建立了微信群或交流通道"><a class="header" href="#622-与导师的沟通情况与导师等是否建立了微信群或交流通道">6.2.2 与导师的沟通情况，与导师等是否建立了微信群或交流通道</a></h3>
<p>        加入导师交流微信群，定期听取专题会议并参与讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-bitcomet未来展望与参考文献"><a class="header" href="#7-bitcomet未来展望与参考文献">7. Bitcomet未来展望与参考文献</a></h1>
<h2 id="71-未来更加值得选择并研究的方案"><a class="header" href="#71-未来更加值得选择并研究的方案">7.1 未来更加值得选择并研究的方案</a></h2>
<p>        这里讲述一种未来更有潜力的方案，该方案仍然是使用容器来提供Android运行的环境，这样继承了容器方案的优势，但是在3D渲染和图形输出的部分和输入输出的部分选择了截然不同的方式，把Mesa3D驱动直接移植到Android内，同时在HWC和Gralloc模块上进行处理，直接对接外部Linux实现控制和图形输入输出。此种方法有目前众多新的项目使用，甚至是其Anbox的衍生项目Waydroid以及Redroid、KMRE等方案也是使用了该种方法。直接使用Mesa3D驱动GPU硬件，图形渲染和输入输出能够直接对接GPU硬件，显然可见这种实现方法<strong>性能损失是最低的</strong>。</p>
<p>        但是该种方案仍然有<strong>缺点</strong>：Mesa3D驱动即使支持了众多x86和ARM平台下的GPU，包括Intel、AMD、NVIDIA、Qualcomm、ARM等，但仍然有不支持的GPU；Mesa3D是Linux下的库，需要经过许多移植工作才能在Android下工作；针对不同GPU的平台，如果需要实现Mesa3D的方案，但GPU又未被Mesa3D支持，则相关驱动也需要移植；Mesa3D在Android中部分仅仅只是图形库，在外部Linux内核也需要相应GPU驱动，从而使外部Linux也需要使用Mesa3D库来调用GPU。</p>
<center><img src=images/design/Docker_run_Android_with_Mesa3d.png alt="Docker运行Android+Mesa3D架构图"></center>
<center>图7.1 Docker运行Android+Mesa3D架构图</center>
<p>        本项目Bitcomet是这类移植方式中其中一种兼容性较好的方案，技术仍然在不断发展，目前已有各类新型的，性能损耗更低的技术出现。例如Anbox的衍生项目Waydroid以及KMRE，直接利用GPU库调用底层GPU硬件的方法，实现真机的调用方法，损耗极低。未来本项目发展必然是朝着这些新技术进行研究，并实现对这些新技术的掌握及发展。例如Waydroid方案的支持有局限性，只对接了Wayland实现窗口创建管理及图形输出。而KMRE等是属于商业项目，但从其论文来看，与Waydroid都是同一种实现技术与方案，唯一不同是实现了在Xorg下的输出显示。因此本项目未来需要追赶新技术，实现Wayland、KMRE这类新技术，并且在其之上完善更多图形环境下的适配以及其他各类优化。</p>
<p>        同时在这种移植技术的发展上，本项目希望探索与总结这类跨系统平台适配的各类技术的实现与优点，能总结出这种成熟的技术并制定方案，建立成熟的技术体系，提供给更多同类型项目进行参考，助力信息产业国产化，建设更好的国产生态。</p>
<h2 id="72-参考文献"><a class="header" href="#72-参考文献">7.2 参考文献</a></h2>
<ol>
<li>面向桌面Linux的Android运行环境构建. 张超，国防科技大学，[2012年10月]. CNKI:CDMD:2.1014.048616</li>
<li>Android 架构，Android Open Source Project (google.cn) 链接：https://source.android.google.cn/devices/architecture?hl=zh-cn</li>
<li>KMRE: An Efficient and Compatible Runtime to Execute Android Application on Linux System, [Date of Conference: 10-13 December 2021]. 10.1109/ICCC54389.2021.9674681</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
