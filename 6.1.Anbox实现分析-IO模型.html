<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anbox实现分析：IO 模型</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.illustrate.html"><strong aria-hidden="true">1.</strong> 项目概要</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1.Design.html"><strong aria-hidden="true">1.1.</strong> 方案设计</a></li><li class="chapter-item expanded "><a href="1.2.Plan.html"><strong aria-hidden="true">1.2.</strong> 开发计划与进展</a></li><li class="chapter-item expanded "><a href="1.3.explain.html"><strong aria-hidden="true">1.3.</strong> 项目总结与目录说明</a></li><li class="chapter-item expanded "><a href="1.4.run.html"><strong aria-hidden="true">1.4.</strong> 运行方法与参考借鉴</a></li></ol></li><li class="chapter-item expanded "><a href="2.Bitcomet_Design.html"><strong aria-hidden="true">2.</strong> Bitcomet设计文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1.Bitcomet方案概述.html"><strong aria-hidden="true">2.1.</strong> Bitcomet方案分析</a></li><li class="chapter-item expanded "><a href="2.2.Bitcomet方案设计与主要工作.html"><strong aria-hidden="true">2.2.</strong> Bitcomet方案设计与主要工作</a></li><li class="chapter-item expanded "><a href="2.3.Bitcomet未来展望与参考文献.html"><strong aria-hidden="true">2.3.</strong> Bitcomet未来展望与参考文献</a></li></ol></li><li class="chapter-item expanded "><a href="3.Bitcomet实验测试.html"><strong aria-hidden="true">3.</strong> Bitcomet实验测试</a></li><li class="chapter-item expanded "><a href="4.安卓图形架构中的HAL模块.html"><strong aria-hidden="true">4.</strong> Bitcomet图形架构HAL模块实现</a></li><li class="chapter-item expanded "><a href="5.关于Anbox中图形渲染分析与总结.html"><strong aria-hidden="true">5.</strong> Bitcomet图形渲染实现</a></li><li class="chapter-item expanded "><a href="6.Anbox容器管理服务.html"><strong aria-hidden="true">6.</strong> Anbox实现分析：Anbox容器管理服务</a></li><li class="chapter-item expanded "><a href="6.1.Anbox实现分析-IO模型.html" class="active"><strong aria-hidden="true">7.</strong> Anbox实现分析：IO 模型</a></li><li class="chapter-item expanded "><a href="6.2.Anbox实现分析-会话管理器与容器管理器的通信.html"><strong aria-hidden="true">8.</strong> Anbox实现分析：会话管理器与容器管理器的通信</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="anbox-实现分析io-模型"><a class="header" href="#anbox-实现分析io-模型">Anbox 实现分析：I/O 模型</a></h1>
<p>Anbox 运行时主要由两个分开的实例构成，即容器管理器 ContainerManager 和会话管理器 SessionManager，但无论是 ContainerManager 还是 SessionManager，所做的最重要的事情就是处理网络 I/O 事件了。I/O 模型指一个应用处理 I/O 事件的整体框架设计，对于 Anbox 而言主要是处理各种网络 I/O 事务的整体框架设计。ContainerManager 和 SessionManager 基于一个相同的 I/O 模型运行，为了获得对 Anbox 整体行为设计的理解，有必要对其 I/O 模型有个整体的认识。</p>
<h2 id="io-模型"><a class="header" href="#io-模型">I/O 模型</a></h2>
<p>Anbox 的 I/O 模型基于 boost.asio 构建。Anbox 中所有的 I/O 事件，在一个线程池中，通过一个 <code>boost::asio::io_service</code> 对象来派发并处理。Anbox 用 <code>anbox::Runtime</code> 类封装一个 <code>boost::asio::io_service</code> 对象，并管理执行任务的线程池。</p>
<p><code>anbox::Runtime</code> 类的定义（位于 <code>anbox/src/anbox/runtime.h</code>）如下：</p>
<pre><code>namespace anbox {
// We bundle our &quot;global&quot; runtime dependencies here, specifically
// a dispatcher to decouple multiple in-process providers from one
// another , forcing execution to a well known set of threads.
class Runtime : public DoNotCopyOrMove,
                public std::enable_shared_from_this&lt;Runtime&gt; {
 public:
  // Our default concurrency setup.
  static constexpr const std::uint32_t worker_threads = 8;
  // create returns a Runtime instance with pool_size worker threads
  // executing the underlying service.
  static std::shared_ptr&lt;Runtime&gt; create(
      std::uint32_t pool_size = worker_threads);
  // Tears down the runtime, stopping all worker threads.
  ~Runtime() noexcept(true);
  // start executes the underlying io_service on a thread pool with
  // the size configured at creation time.
  void start();
  // stop cleanly shuts down a Runtime instance.
  void stop();
  // to_dispatcher_functional returns a function for integration
  // with components that expect a dispatcher for operation.
  std::function&lt;void(std::function&lt;void()&gt;)&gt; to_dispatcher_functional();
  // service returns the underlying boost::asio::io_service that is executed
  // by the Runtime.
  boost::asio::io_service&amp; service();
 private:
  // Runtime constructs a new instance, firing up pool_size
  // worker threads.
  Runtime(std::uint32_t pool_size);
  std::uint32_t pool_size_;
  boost::asio::io_service service_;
  boost::asio::io_service::strand strand_;
  boost::asio::io_service::work keep_alive_;
  std::vector&lt;std::thread&gt; workers_;
};
}  // namespace anbox
</code></pre>
<p><code>anbox::Runtime</code> 类封装了一个 <code>boost::asio::io_service</code> 对象及多个工作线程 <code>std::thread</code>，它还继承 <code>std::enable_shared_from_this&lt;Runtime&gt;</code> 以获得从 <code>this</code> 指针创建智能指针 <code>std::shared_ptr</code> 的能力，同时继承了 <code>DoNotCopyOrMove</code>，以禁掉类的拷贝和移动操作。</p>
<p><code>anbox::Runtime</code> 类的实现（位于 <code>anbox/src/anbox/runtime.cpp</code>）如下：</p>
<pre><code>namespace {
void exception_safe_run(boost::asio::io_service&amp; service) {
  while (true) {
    try {
      service.run();
      // a clean return from run only happens in case of
      // stop() being called (we are keeping the service alive with
      // a service::work instance).
      break;
    } catch (const std::exception&amp; e) {
      ERROR(&quot;%s&quot;, e.what());
    } catch (...) {
      ERROR(&quot;Unknown exception caught while executing boost::asio::io_service&quot;);
    }
  }
}
}
namespace anbox {
std::shared_ptr&lt;Runtime&gt; Runtime::create(std::uint32_t pool_size) {
  return std::shared_ptr&lt;Runtime&gt;(new Runtime(pool_size));
}
Runtime::Runtime(std::uint32_t pool_size)
    : pool_size_{pool_size},
      service_{pool_size_},
      strand_{service_},
      keep_alive_{service_} {}
Runtime::~Runtime() noexcept(true) {
  try {
    stop();
  } catch (...) {
    // Dropping all exceptions to satisfy the nothrow guarantee.
  }
}
void Runtime::start() {
  for (unsigned int i = 0; i &lt; pool_size_; i++)
    workers_.push_back(std::thread{exception_safe_run, std::ref(service_)});
}
void Runtime::stop() {
  service_.stop();
  for (auto&amp; worker : workers_)
    if (worker.joinable())
      worker.join();
  workers_.clear();
}
std::function&lt;void(std::function&lt;void()&gt;)&gt; Runtime::to_dispatcher_functional() {
  // We have to make sure that we stay alive for as long as
  // calling code requires the dispatcher to work.
  auto sp = shared_from_this();
  return [sp](std::function&lt;void()&gt; task) { sp-&gt;strand_.post(task); };
}
boost::asio::io_service&amp; Runtime::service() { return service_; }
}  // namespace anbox
</code></pre>
<p><code>anbox::Runtime</code> 类有两大职责，一是 <code>boost::asio::io_service</code> 对象的生命周期管理；二是向 <code>boost::asio::io_service</code> 中提交任务。</p>
<p>在 <code>anbox::Runtime::start()</code> 函数中创建并启动多个线程，执行一个执行 <code>boost::asio::io_service::run()</code> 函数的函数 <code>exception_safe_run()</code>。在 <code>anbox::Runtime::stop()</code> 函数中停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的析够函数中，还会调用 <code>stop()</code> 函数停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的类型为 <code>boost::asio::io_service::work</code> 的成员变量 <code>keep_alive_</code> 也是用于管理 <code>boost::asio::io_service</code> 对象的生命周期的，该对象在析够时也会停掉 <code>boost::asio::io_service</code> 的执行。</p>
<p>对于不熟悉 boost 库的朋友来说，<code>boost::asio::io_service</code> 可以理解为一个 I/O 多路复用器，就像许多网络库通过 select/poll/epoll/kqueue 实现的那样，或者可以理解为以 Reactor 模式实现的网络库中的一个事件循环，可以向其中提交 I/O 任务、定时器及其它任务等。<code>boost::asio::io_service::strand</code> 可以理解为 <code>boost::asio::io_service</code> 中的一个特殊的子任务队列，该类保证向其提交的所有任务都不会并发执行，以此消除这些任务之间的同步问题。</p>
<p><code>anbox::Runtime::to_dispatcher_functional()</code> 函数返回一个接收一个函数为参数的函数，返回的这个函数可以将它接收的函数作为一个 task，通过 <code>boost::asio::io_service::strand</code> 提交给 <code>boost::asio::io_service</code> 执行。<code>anbox::Runtime::service()</code> 返回 <code>boost::asio::io_service</code> 用于方便一些 boost I/O 组件，直接向该 <code>io_service</code> 中提交任务。</p>
<p>继承自 <code>std::enable_shared_from_this&lt;Runtime&gt;</code> 的 <code>shared_from_this()</code> 可以从 <code>this</code> 指针创建一个指向当前对象的 <code>std::shared_ptr</code> 智能指针。通过对标准库源码的分析，可以知道 <code>std::enable_shared_from_this</code> 的实现原理大体如下：<code>std::enable_shared_from_this&lt;Runtime&gt;</code> 有一个类型为 <code>std::weak_ptr&lt;Runtime&gt;</code> 的成员，该成员在首次创建指向对象的 <code>std::shared_ptr</code> 智能指针的时候会被初始化。<code>shared_from_this()</code> 函数被调用时，会从类型为 <code>std::weak_ptr&lt;Runtime&gt;</code> 的成员变量创建指向当前对象的 <code>std::shared_ptr</code> 智能指针。</p>
<p>Anbox 的 I/O 模型可以理解为，底层有 *<strong>一个*</strong> 多路复用器或事件循环 <code>boost::asio::io_service</code>，有一个包含了 8 个线程的线程池基于此 <code>boost::asio::io_service</code> 运行，处理 I/O 事件及其它各种类型的任务。</p>
<p>有了用于执行 I/O 事件处理程序的 <code>boost::asio::io_service</code>，接下来来看一下，Anbox 都会向其中提交哪些任务。</p>
<p>Anbox 需要处理如下这样一些网络 I/O 过程：</p>
<ul>
<li>监听 Unix 域 Socket 接受连接。Anbox 的 SessionManager 通过 Unix 域 Socket 与 ContainerManager 进行通信，同时也通过 Unix 域 Socket 与 ContainerManager 启动的 Android 容器内的应用程序通信。首先 ContainerManager 监听在特定位置的 Unix 域 Socket 上。随后 SessionManager 监听几个位置上的 Unix 域 Socket，然后请求 ContainerManager 启动 Android 容器，并将这几个 Unix 域 Socket 映射到容器内的 <code>/dev/</code> 目录下。Android 容器启动后，一些进程，如 surfaceflinger、cameraservice 等连接这些 Unix 域 Socket，并通过这些 Unix 域 Socket 与 SessionManager 通信，进而操作宿主机的硬件设备。</li>
<li>监听 TCP Socket 接受连接。Anbox 的 SessionManager 作为容器中运行的 Android 与 ADB 进行通信的桥梁，它在与容器中运行的 Android 通过 Unix 域 Socket 通信的同时，也需要与宿主机上的 ADB 通信。SessionManager 通过 TCP 与宿主机上的 ADB 守护进程通信。如同模拟器等 Android 设备一样，SessionManager 遵从 ADB 的通信协议，在发起与 ADB 之间的 TCP 连接的同时，也需要监听一个 TCP 端口，等待 ADB 守护进程发起的连接，以完成整个 ADB 协议。</li>
<li>处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket。监听的 Unix 域 Socket 接受新连接之后，需要将新创建的 Unix 域 Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>处理从监听的 TCP Scoket 接受的 TCP Socket。监听的 TCP Socket 接受新连接之后，需要将新创建的 TCP Socket 提交给底层的 I/O 多路复用器，并为该 Socket 提供读写等 I/O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>发起一个到 TCP 服务器的连接。如前面提到的，Anbox 的 SessionManager 通过 TCP 连接与 ADB 守护进程通信，它会先发起一个到 ADB 守护进程的 TCP 连接。</li>
<li>发起一个到 Unix 域 Socket 服务的连接。Anbox 的 SessionManager 与 ContainerManager 之间通过 Unix 域 Socket 通信，SessionManager 会发起到 ContainerManager 监听的 Unix 域 Socket 服务的连接。</li>
</ul>
<h2 id="监听-unix-域-socket-接受连接"><a class="header" href="#监听-unix-域-socket-接受连接">监听 Unix 域 Socket 接受连接</a></h2>
<p>在 boost.asio 中，监听 Socket 并接受新连接，通过 acceptor 完成，对于具体的 Unix 域 Socket 而言，是通过 <code>boost::asio::local::stream_protocol::acceptor</code>。<code>boost::asio::local::stream_protocol::acceptor</code> 类对象在创建时，需要为构造函数传入 <code>boost::asio::io_service</code> 及 Unix 域 Socket 的路径，通过 acceptor 的 <code>async_accept()</code> 函数，可以将 Unix 域 Socket 及处理新连接到来时的回调函数提交给底层的 I/O 多路复用器，异步地启动对 Unix 域 Socket 的监听。</p>
<p>在 Anbox 中，通过 <code>anbox::network::PublishedSocketConnector</code> 封装 <code>boost::asio::local::stream_protocol::acceptor</code>，并为它定义处理新连接到来时的回调函数。<code>anbox::network::PublishedSocketConnector</code> 类的定义（位于 <code>anbox/src/anbox/network/published_socket_connector.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class PublishedSocketConnector : public DoNotCopyOrMove, public Connector {
 public:
  explicit PublishedSocketConnector(
      const std::string&amp; socket_file, const std::shared_ptr&lt;Runtime&gt;&amp; rt,
      const std::shared_ptr&lt;ConnectionCreator&lt;
          boost::asio::local::stream_protocol&gt;&gt;&amp; connection_creator);
  ~PublishedSocketConnector() noexcept;
  std::string socket_file() const { return socket_file_; }
 private:
  void start_accept();
  void on_new_connection(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp; socket,
      boost::system::error_code const&amp; err);
  const std::string socket_file_;
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;&gt;
      connection_creator_;
  boost::asio::local::stream_protocol::acceptor acceptor_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::PublishedSocketConnector</code> 保存了 Unix 域 Socket 文件的路径，指向 <code>anbox::Runtime</code> 对象的智能指针，一个指向 <code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 对象的智能指针，及 一个 <code>boost::asio::local::stream_protocol::acceptor</code>。指向 <code>anbox::Runtime</code> 对象的智能指针主要用于从 <code>anbox::Runtime</code> 对象获得其管理的 <code>boost::asio::io_service</code> 的引用。<code>boost::asio::local::stream_protocol::acceptor</code> 的作用如前所述，<code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 的作用后面再来讨论。</p>
<p><code>anbox::network::PublishedSocketConnector</code> 类的实现（位于 <code>anbox/src/anbox/network/published_socket_connector.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
PublishedSocketConnector::PublishedSocketConnector(
    const std::string&amp; socket_file, const std::shared_ptr&lt;Runtime&gt;&amp; rt,
    const std::shared_ptr&lt;ConnectionCreator&lt;
        boost::asio::local::stream_protocol&gt;&gt;&amp; connection_creator)
    : socket_file_(remove_socket_if_stale(socket_file)),
      runtime_(rt),
      connection_creator_(connection_creator),
      acceptor_(rt-&gt;service(), socket_file_) {
  start_accept();
}

PublishedSocketConnector::~PublishedSocketConnector() noexcept {}

void PublishedSocketConnector::start_accept() {
  auto socket = std::make_shared&lt;boost::asio::local::stream_protocol::socket&gt;(runtime_-&gt;service());

  acceptor_.async_accept(*socket,
                         [this, socket](boost::system::error_code const&amp; err) {
                           on_new_connection(socket, err);
                         });
}

void PublishedSocketConnector::on_new_connection(std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp; socket,
                                                 boost::system::error_code const&amp; err) {
  if (!err)
    connection_creator_-&gt;create_connection_for(socket);

  if (err.value() == boost::asio::error::operation_aborted)
    return;

  start_accept();
}
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::PublishedSocketConnector</code> 类对象构造完成之后，即会调用 <code>start_accept()</code> 启动对 Unix 域 Socket 的监听。</p>
<p><code>anbox::network::PublishedSocketConnector</code> 的 <code>start_accept()</code> 首先创建一个 <code>boost::asio::local::stream_protocol::socket</code> 对象用于保存下次接受的新 Socket 的相关信息，然后将这个对象，及作为处理新连接到来时的回调函数而创建的 lambda 表达式传递给 <code>boost::asio::local::stream_protocol::acceptor</code> 的 <code>async_accept()</code> 函数以启动对 Unix 域 Socket 的监听。</p>
<p>接收到新到来的连接之后，传给 <code>boost::asio::local::stream_protocol::acceptor</code> 的 <code>async_accept()</code> 的 lambda 回调函数直接将 Socket 交给 <code>anbox::network::PublishedSocketConnector::on_new_connection()</code> 来处理，<code>anbox::network::PublishedSocketConnector::on_new_connection()</code> 又将新连接交给 <code>ConnectionCreator&lt;boost::asio::local::stream_protocol&gt;</code> 来处理。</p>
<p>由此不难理解，在 Anbox 的设计中，监听并接受连接与对新连接的处理，由两个完全不同的组件来处理，前者由 <code>anbox::network::Connector</code> 处理，后者由 <code>anbox::network::ConnectionCreator</code> 处理。<code>anbox::network::ConnectionCreator</code> 定义（位于 <code>anbox/src/anbox/network/connection_creator.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
template &lt;typename stream_protocol&gt;
class ConnectionCreator : public DoNotCopyOrMove {
 public:
  virtual void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;
          socket) = 0;
};
}  // namespace anbox
}  // namespace network
</code></pre>
<h2 id="监听-tcp-socket-接受连接"><a class="header" href="#监听-tcp-socket-接受连接">监听 TCP Socket 接受连接</a></h2>
<p>Anbox 中监听 TCP Socket 并接受连接的逻辑与监听 Unix 域 Socket 并接受连接的逻辑非常类似，只是依赖的底层 boost.asio 的 acceptor 变为了 <code>boost::asio::ip::tcp::acceptor</code>。封装 <code>boost::asio::ip::tcp::acceptor</code> 组件等由 <code>anbox::network::TcpSocketConnector</code> 完成，这个类的定义（位于 <code>anbox/src/anbox/network/tcp_socket_connector.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class TcpSocketConnector : public DoNotCopyOrMove, public Connector {
 public:
  explicit TcpSocketConnector(
      const boost::asio::ip::address_v4 &amp;address, unsigned short port,
      const std::shared_ptr&lt;Runtime&gt; &amp;rt,
      const std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;
          &amp;connection_creator);
  ~TcpSocketConnector() noexcept;
  unsigned short port() const { return port_; }
 private:
  void start_accept();
  void on_new_connection(
      std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket,
      boost::system::error_code const &amp;err);
  boost::asio::ip::address_v4 address_;
  unsigned short port_;
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt; connection_creator_;
  boost::asio::ip::tcp::acceptor acceptor_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>监听的地址，不像 <code>anbox::network::PublishedSocketConnector</code> 那样用一个路径来描述就可以了，而是要通过 IP 地址和端口号来描述。</p>
<p><code>anbox::network::TcpSocketConnector</code> 类的实现（位于 <code>anbox/src/anbox/network/tcp_socket_connector.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
TcpSocketConnector::TcpSocketConnector(
    const boost::asio::ip::address_v4&amp; address, unsigned short port,
    const std::shared_ptr&lt;Runtime&gt;&amp; rt,
    const std::shared_ptr&lt;ConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;&amp;
        connection_creator)
    : address_(address),
      port_(port),
      runtime_(rt),
      connection_creator_(connection_creator),
      acceptor_(rt-&gt;service(), boost::asio::ip::tcp::endpoint(address, port)) {
  start_accept();
}
TcpSocketConnector::~TcpSocketConnector() noexcept { acceptor_.cancel(); }
void TcpSocketConnector::start_accept() {
  auto socket =
      std::make_shared&lt;boost::asio::ip::tcp::socket&gt;(runtime_-&gt;service());
  acceptor_.async_accept(*socket,
                         [this, socket](boost::system::error_code const&amp; err) {
                           on_new_connection(socket, err);
                         });
}
void TcpSocketConnector::on_new_connection(
    std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const&amp; socket,
    boost::system::error_code const&amp; err) {
  switch (err.value()) {
    case boost::system::errc::success:
      connection_creator_-&gt;create_connection_for(socket);
      break;
    default:
      // Socket was closed so don't listen for any further incoming
      // connection attempts.
      return;
  }
  start_accept();
}
}  // namespace network
}  // namespace anbox
</code></pre>
<p>启动监听及新连接到来时的回调处理都与 <code>anbox::network::PublishedSocketConnector</code> 类似，只是调用 acceptor 的 <code>async_accept()</code> 之前创建的是 <code>boost::asio::ip::tcp::socket</code> 对象，新连接到来之后，则是交给 <code>ConnectionCreator&lt;boost::asio::ip::tcp&gt;</code> 来处理的。</p>
<p>Anbox 中，监听 Socket 相关（包括对 Unix 域 Socket 的监听和对 TCP Socket 的监听）的类结构如下：</p>
<p><img src="images/anbox/1315506-6bc2288274987ea5.png" alt="1315506-6bc2288274987ea5" /></p>
<h2 id="处理从监听的-unix-域-socket-接受的-unix-域-socket"><a class="header" href="#处理从监听的-unix-域-socket-接受的-unix-域-socket">处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket</a></h2>
<p>在 Anbox 中，使用了 <code>anbox::network::PublishedSocketConnector</code> 来监听 Unix 域 Socket 的组件包括如下这些：</p>
<div class="table-wrapper"><table><thead><tr><th><strong>组件</strong></th><th>所用 ConnectionCreator</th></tr></thead><tbody>
<tr><td>anbox::audio::Server</td><td>anbox::network::DelegateConnectionCreator</td></tr>
<tr><td>anbox::cmds::SessionManager</td><td>anbox::rpc::ConnectionCreator</td></tr>
<tr><td>anbox::container::Service</td><td>anbox::network::DelegateConnectionCreator</td></tr>
<tr><td>anbox::input::Device</td><td>anbox::network::DelegateConnectionCreator</td></tr>
</tbody></table>
</div>
<p>在 Anbox 中监听 Unix 域 Socket 的组件有多个，对于新到来的连接的处理方式有着一定的差异，但这种处理又都依赖于相同的底层 Unix 域 Socket 处理框架。</p>
<p><code>anbox::rpc::ConnectionCreator</code> 清晰地为我们展示了，Anbox 中处理新接受的 Unix 域 Socket 的基本方式，来看这个类的实现。<code>anbox::rpc::ConnectionCreator</code> 的定义（位于 <code>anbox/src/anbox/rpc/connection_creator.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
class ConnectionCreator
    : public network::ConnectionCreator&lt;boost::asio::local::stream_protocol&gt; {
 public:
  typedef std::function&lt;std::shared_ptr&lt;network::MessageProcessor&gt;(
      const std::shared_ptr&lt;network::MessageSender&gt; &amp;)&gt;
      MessageProcessorFactory;
  ConnectionCreator(const std::shared_ptr&lt;Runtime&gt; &amp;rt,
                    const MessageProcessorFactory &amp;factory);
  ~ConnectionCreator() noexcept;
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;
          boost::asio::local::stream_protocol&gt;&gt; const &amp;socket) override;
 private:
  int next_id();
  std::shared_ptr&lt;Runtime&gt; runtime_;
  std::atomic&lt;int&gt; next_connection_id_;
  std::shared_ptr&lt;network::Connections&lt;network::SocketConnection&gt;&gt; const
      connections_;
  MessageProcessorFactory message_processor_factory_;
};
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p><code>anbox::rpc::ConnectionCreator</code> 实现用于处理新到来的连接的 <code>create_connection_for()</code> 函数。<code>anbox::rpc::ConnectionCreator</code> 的实现（位于 <code>anbox/src/anbox/rpc/connection_creator.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
ConnectionCreator::ConnectionCreator(const std::shared_ptr&lt;Runtime&gt;&amp; rt,
                                     const MessageProcessorFactory&amp; factory)
    : runtime_(rt),
      next_connection_id_(0),
      connections_(
          std::make_shared&lt;network::Connections&lt;network::SocketConnection&gt;&gt;()),
      message_processor_factory_(factory) {}
ConnectionCreator::~ConnectionCreator() noexcept {}
void ConnectionCreator::create_connection_for(
    std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const&amp;
        socket) {
  if (connections_-&gt;size() &gt;= 1) {
    socket-&gt;close();
    WARNING(
        &quot;A second client tried to connect. Denied request as we already have &quot;
        &quot;one and only allow a single client&quot;);
    return;
  }
  auto const messenger =
      std::make_shared&lt;network::LocalSocketMessenger&gt;(socket);
  auto const processor = message_processor_factory_(messenger);
  auto const&amp; connection = std::make_shared&lt;network::SocketConnection&gt;(
      messenger, messenger, next_id(), connections_, processor);
  connection-&gt;set_name(&quot;rpc&quot;);
  connections_-&gt;add(connection);
  connection-&gt;read_next_message();
}
int ConnectionCreator::next_id() { return next_connection_id_.fetch_add(1); }
}  // namespace rpc
}  // namespace anbox
</code></pre>
<p>从 <code>anbox::rpc::ConnectionCreator::create_connection_for()</code> 的实现，可以看到 Anbox 处理新接受的 Unix 域 Socket 的基本流程：</p>
<ul>
<li>为新的 <code>boost::asio::local::stream_protocol::socket</code> 对象创建 <code>anbox::network::LocalSocketMessenger</code>，用于将 Socket 添加进底层的 I/O 多路复用器，Socket 的读写等操作。</li>
<li>创建消息处理回调函数。当检测到 Socket 上有消息到来时，消息会被读取，并传递给这个回调函数来处理。</li>
<li>根据前面创建的 <code>anbox::network::LocalSocketMessenger</code> 和消息处理回调创建 <code>anbox::network::SocketConnection</code>。<code>anbox::network::SocketConnection</code> 是底层 Socket（即 <code>anbox::network::LocalSocketMessenger</code>） 与其用户之间的桥梁， <code>anbox::network::SocketConnection</code> 用于直接将 Socket 提交给底层 I/O 多路复用器以异步读取数据，帮助发送数据，以及拷贝底层数据读取缓冲区的数据并调用用户的消息处理回调函数。</li>
<li>为 <code>anbox::network::SocketConnection</code> 设置名称。</li>
<li>将 <code>anbox::network::SocketConnection</code> 保存于一个容器，以便于做一些整体的控制。<code>anbox::network::SocketConnection</code> 持有指向该容器的智能指针，以便于在连接断开时，将自身从容器中移除。</li>
<li>调用 <code>anbox::network::SocketConnection</code> 的 <code>read_next_message()</code> 函数，将 Socket 提交给底层的 I/O 多路复用器，以启动接收数据。这个函数十分类似于前面看到的 <code>anbox::network::PublishedSocketConnector</code> 和 <code>anbox::network::TcpSocketConnector</code> 的 <code>start_accept()</code> 函数。</li>
</ul>
<p><code>anbox::network::SocketConnection</code> 类的定义（位于<code>anbox/src/anbox/network/socket_connection.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class SocketConnection {
 public:
  SocketConnection(
      std::shared_ptr&lt;MessageReceiver&gt; const&amp; message_receiver,
      std::shared_ptr&lt;MessageSender&gt; const&amp; message_sender, int id,
      std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const&amp; connections,
      std::shared_ptr&lt;MessageProcessor&gt; const&amp; processor);
  ~SocketConnection() noexcept;
  void set_name(const std::string&amp; name) { name_ = name; }
  int id() const { return id_; }
  void send(char const* data, size_t length);
  void read_next_message();
 private:
  void on_read_size(const boost::system::error_code&amp; ec,
                    std::size_t bytes_read);
  std::shared_ptr&lt;MessageReceiver&gt; const message_receiver_;
  std::shared_ptr&lt;MessageSender&gt; const message_sender_;
  int id_;
  std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const connections_;
  std::shared_ptr&lt;MessageProcessor&gt; processor_;
  std::array&lt;std::uint8_t, 8192&gt; buffer_;
  std::string name_;
};
}  // namespace anbox
}  // namespace network
</code></pre>
<p><code>anbox::network::SocketConnection</code> 类的实现（位于 <code>anbox/src/anbox/network/socket_connection.cpp</code>）如下：</p>
<pre><code>namespace ba = boost::asio;
namespace bs = boost::system;
namespace anbox {
namespace network {
SocketConnection::SocketConnection(
    std::shared_ptr&lt;MessageReceiver&gt; const&amp; message_receiver,
    std::shared_ptr&lt;MessageSender&gt; const&amp; message_sender, int id_,
    std::shared_ptr&lt;Connections&lt;SocketConnection&gt;&gt; const&amp; connections,
    std::shared_ptr&lt;MessageProcessor&gt; const&amp; processor)
    : message_receiver_(message_receiver),
      message_sender_(message_sender),
      id_(id_),
      connections_(connections),
      processor_(processor) {}
SocketConnection::~SocketConnection() noexcept {}
void SocketConnection::send(char const* data, size_t length) {
  message_sender_-&gt;send(data, length);
}
void SocketConnection::read_next_message() {
  auto callback = std::bind(&amp;SocketConnection::on_read_size, this, std::placeholders::_1, std::placeholders::_2);
  message_receiver_-&gt;async_receive_msg(callback, ba::buffer(buffer_));
}
void SocketConnection::on_read_size(const boost::system::error_code&amp; error, std::size_t bytes_read) {
  if (error) {
    connections_-&gt;remove(id());
    return;
  }
  std::vector&lt;std::uint8_t&gt; data(bytes_read);
  std::copy(buffer_.data(), buffer_.data() + bytes_read, data.data());
  if (processor_-&gt;process_data(data))
    read_next_message();
  else
      connections_-&gt;remove(id());
}
}  // namespace anbox
}  // namespace network
</code></pre>
<p>在 <code>anbox::network::SocketConnection::read_next_message()</code> 中，用于存放读取的数据的缓冲区由 <code>anbox::network::SocketConnection</code> 提供，这与 <code>anbox::network::PublishedSocketConnector</code> 和 <code>anbox::network::TcpSocketConnector</code> 的 <code>start_accept()</code> 函数中，事先创建好保存下次到来的新连接的状态的 Socket 非常类似。</p>
<p>另外一个 <code>anbox::network::ConnectionCreator</code> 实现者是 <code>anbox::network::DelegateConnectionCreator</code>，它仅仅是将处理新连接的职责转出去给一个函数，因而通常实际的新连接处理者也是 <code>anbox::network::PublishedSocketConnector</code> 的创建者。<code>anbox::network::DelegateConnectionCreator</code> 的定义及实现如下：</p>
<pre><code>namespace anbox {
namespace network {
template &lt;typename stream_protocol&gt;
class DelegateConnectionCreator : public ConnectionCreator&lt;stream_protocol&gt; {
 public:
  DelegateConnectionCreator(
      std::function&lt;void(std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;
                             stream_protocol&gt;&gt; const&amp;)&gt;
          delegate)
      : delegate_(delegate) {}
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;
          socket) override {
    if (delegate_)
      delegate_(socket);
    else
      socket-&gt;close();
  }
 private:
  std::function&lt;void(std::shared_ptr&lt;
                     boost::asio::basic_stream_socket&lt;stream_protocol&gt;&gt; const&amp;)&gt;
      delegate_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p>使用了 <code>anbox::network::DelegateConnectionCreator</code> 的情况下，各个组件自己处理新到来的连接的方式，与 <code>anbox::rpc::ConnectionCreator</code> 中处理新到来的连接的方式大同小异。</p>
<p>在 <code>anbox::cmds::SessionManager</code> 中（位于 <code>anbox/src/anbox/cmds/session_manager.cpp</code>）还有一个 <code>anbox::network::ConnectionCreator</code> 的实现：</p>
<pre><code>class NullConnectionCreator : public anbox::network::ConnectionCreator&lt;
                                  boost::asio::local::stream_protocol&gt; {
 public:
  void create_connection_for(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
          &amp;socket) override {
    WARNING(&quot;Not implemented&quot;);
    socket-&gt;close();
  }
};
</code></pre>
<p>这个实现，与 <code>anbox::network::DelegateConnectionCreator</code> 在 <code>delegate</code> 为空时的行为一致，看上去这个类的定义似乎有些多余。</p>
<h2 id="处理从监听的-tcp-scoket-接受的-tcp-socket"><a class="header" href="#处理从监听的-tcp-scoket-接受的-tcp-socket">处理从监听的 TCP Scoket 接受的 TCP Socket</a></h2>
<p>Anbox 中只有一处监听了 TCP Socket，即在 ADB 消息处理器 <code>anbox::qemu::AdbMessageProcessor</code> 中。<code>anbox::qemu::AdbMessageProcessor</code> 中处理与 ADB 守护进程的交互的函数主要包括如下这些：</p>
<pre><code>void AdbMessageProcessor::wait_for_host_connection() {
  if (state_ != waiting_for_guest_accept_command)
    return;
  if (!host_connector_) {
    host_connector_ = std::make_shared&lt;network::TcpSocketConnector&gt;(
        boost::asio::ip::address_v4::from_string(loopback_address),
        default_host_listen_port, runtime_,
        std::make_shared&lt;
            network::DelegateConnectionCreator&lt;boost::asio::ip::tcp&gt;&gt;(
            std::bind(&amp;AdbMessageProcessor::on_host_connection, this, _1)));
  }
  try {
    // Notify the adb host instance so that it knows on which port our
    // proxy is waiting for incoming connections.
    auto messenger = std::make_shared&lt;network::TcpSocketMessenger&gt;(
        boost::asio::ip::address_v4::from_string(loopback_address), default_adb_client_port, runtime_);
    auto message = utils::string_format(&quot;host:emulator:%d&quot;, default_host_listen_port);
    auto handshake = utils::string_format(&quot;%04x%s&quot;, message.size(), message.c_str());
    messenger-&gt;send(handshake.data(), handshake.size());
  } catch (...) {
    // Server not up. No problem, it will contact us when started.
  }
}
void AdbMessageProcessor::on_host_connection(std::shared_ptr&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp&gt;&gt; const &amp;socket) {
  host_messenger_ = std::make_shared&lt;network::TcpSocketMessenger&gt;(socket);
  // set_no_delay() reduces the latency of sending data, at the cost
  // of creating more TCP packets on the connection. It's useful when
  // doing lots of small send() calls, like the ADB protocol requires.
  // And since this is on localhost, the packet increase should not be
  // noticeable.
  host_messenger_-&gt;set_no_delay();
  // Let adb inside the container know that we have a connection to
  // the adb host instance
  messenger_-&gt;send(reinterpret_cast&lt;const char *&gt;(ok_command.data()), ok_command.size());
  state_ = waiting_for_guest_start_command;
  expected_command_ = start_command;
}
void AdbMessageProcessor::read_next_host_message() {
  auto callback = std::bind(&amp;AdbMessageProcessor::on_host_read_size, this, _1, _2);
  host_messenger_-&gt;async_receive_msg(callback, boost::asio::buffer(host_buffer_));
}
void AdbMessageProcessor::on_host_read_size(const boost::system::error_code &amp;error, std::size_t bytes_read) {
  if (error) {
    // When AdbMessageProcessor is destroyed on program termination, the sockets
    // are closed and the standing operations are canceled. But, the callback is
    // still called even in that case, and the object has already been
    // deleted. We detect that condition by looking at the error code and avoid
    // touching *this in that case.
    if (error == boost::system::errc::operation_canceled)
      return;
    // For other errors, we assume the connection with the host is dropped. We
    // close the connection to the container's adbd, which will trigger the
    // deletion of this AdbMessageProcessor instance and free resources (most
    // importantly, default_host_listen_port and the lock). The standing
    // connection that adbd opened can then proceed and wait for the host to be
    // up again.
    state_ = closed_by_host;
    messenger_-&gt;close();
    return;
  }
  messenger_-&gt;send(reinterpret_cast&lt;const char *&gt;(host_buffer_.data()), bytes_read);
  read_next_host_message();
}
</code></pre>
<p><code>anbox::qemu::AdbMessageProcessor</code> 是在容器中的 Android 内的 <code>adbd</code> 守护进程通过 Unix 域 Socket <code>/dev/qemu_pipe</code> 与 SessionManager 建立连接时创建的，它作为容器中的 Android 内的 <code>adbd</code> 守护进程与宿主机的 ADB 守护进程之间的桥梁而存在。在 <code>anbox::qemu::AdbMessageProcessor::wait_for_host_connection()</code> 函数中，会启动对一个 TCP 端口的监听。</p>
<p><code>anbox::qemu::AdbMessageProcessor</code> 为 <code>anbox::network::TcpSocketConnector</code> 传入的 <code>anbox::network::ConnectionCreator</code> 是 <code>anbox::network::DelegateConnectionCreator</code>，为 <code>anbox::network::DelegateConnectionCreator</code> 绑定的 delegate 函数是 <code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code>，这也就是说，对新接受的连接的处理是由 <code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 完成的。</p>
<p><code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 中会根据 <code>&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp&gt;</code> 创建一个 <code>anbox::network::TcpSocketMessenger</code> 用于将新 Socket 提交给底层的 I/O 多路复用器，读写数据等。<code>messenger_</code> 表示与容器中的 Android 内的 adbd 之间的连接，<code>anbox::qemu::AdbMessageProcessor::on_host_connection()</code> 在接收到 ADB 守护进程发起的连接之后，还会向容器中的 Android 内的 adbd 发送一条 <code>ok</code> 命令。随后容器中的 Android 内的 adbd 会回复一条消息，以通过 <code>anbox::qemu::AdbMessageProcessor::read_next_host_message()</code> 启动对新连接上的数据的接收。</p>
<p><code>anbox::qemu::AdbMessageProcessor::read_next_host_message()</code> 启动对新连接上的数据的接收，类似于 <code>anbox::network::SocketConnection</code> 的 <code>read_next_message()</code>，连接上的数据接收到之后，由 <code>anbox::qemu::AdbMessageProcessor::on_host_read_size()</code> 处理，这个函数与在 <code>anbox::rpc::ConnectionCreator</code> 中看到的传递给 <code>anbox::network::SocketConnection</code> 的 <code>anbox::network::MessageProcessor</code> 一样。</p>
<p><code>anbox::qemu::AdbMessageProcessor::on_host_read_size()</code> 对收到的数据的处理方式就是，把收到的数据转发给容器中的 Android 内的 adbd 进程。</p>
<p>Anbox 中与监听的 Socket 上新接受的连接的处理有关的组件如下图所示：</p>
<p><img src="images/anbox/1315506-ba86f2cfdc75d46a.png" alt="1315506-ba86f2cfdc75d46a" /></p>
<p><code>Connector</code> 接受新连接之后，将为新连接创建的 Socket 传给 <code>ConnectionCreator</code>。Anbox 中的几个 <code>ConnectionCreator</code> 实现对新连接的处理方式类似：为新连接创建 <code>SocketMessenger</code>，用于将新连接加入底层 I/O 多路复用器，从新连接读取数据，或者向连接中写入数据。使用者可以在启动对 Socket 上的读事件进行监听时，传入 <code>AnboxReadHandler</code> 回调，在数据到达时得到通知并对数据做一些处理。<code>SocketConnection</code> 为连接管理提供了一些方便，它封装
<code>SocketMessenger</code>，并可以在收到数据时，通过另外的一个回调 <code>MessageProcessor</code> 将接收到的数据通知出去。更上层通过实现 <code>AnboxReadHandler</code> 或 <code>MessageProcessor</code> 来拿到接收到的数据并做处理。</p>
<h2 id="发起一个到-unix-域-socket-服务的连接"><a class="header" href="#发起一个到-unix-域-socket-服务的连接">发起一个到 Unix 域 Socket 服务的连接</a></h2>
<p>Anbox 的 SessionManager 会通过 <code>anbox::container::Client</code> 发起与 ContainerManager 的连接，这是一个 Unix 域 Socket 连接。在 <code>anbox::container::Client</code> 中可以看到 Anbox 中发起到 Unix 域 Socket 服务的连接的过程。</p>
<p><code>anbox::container::Client</code> 的定义（位于 <code>anbox/src/anbox/container/client.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace rpc {
class PendingCallCache;
class Channel;
class MessageProcessor;
}  // namespace rpc
namespace network {
class LocalSocketMessenger;
}  // namespace network
namespace container {
class ManagementApiStub;
class Client {
 public:
  typedef std::function&lt;void()&gt; TerminateCallback;
  Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  ~Client();
  void start(const Configuration &amp;configuration);
  void stop();
  void register_terminate_handler(const TerminateCallback &amp;callback);
 private:
  void read_next_message();
  void on_read_size(const boost::system::error_code &amp;ec,
                    std::size_t bytes_read);
  std::shared_ptr&lt;network::LocalSocketMessenger&gt; messenger_;
  std::shared_ptr&lt;rpc::PendingCallCache&gt; pending_calls_;
  std::shared_ptr&lt;rpc::Channel&gt; rpc_channel_;
  std::shared_ptr&lt;ManagementApiStub&gt; management_api_;
  std::shared_ptr&lt;rpc::MessageProcessor&gt; processor_;
  std::array&lt;std::uint8_t, 8192&gt; buffer_;
  TerminateCallback terminate_callback_;
};
}  // namespace container
}  // namespace anbox
</code></pre>
<p>这个类的各成员变量中，<code>messenger_</code> 表示与目标服务的连接；<code>buffer_</code> 是数据接收所需的缓冲区；<code>pending_calls_</code>、<code>rpc_channel_</code>、<code>management_api_</code> 和 <code>processor_</code> 都用于处理与目标服务间的通信，它们与 SessionManager 自身的逻辑紧密相关；<code>terminate_callback_</code> 用于连接结束。</p>
<p><code>anbox::container::Client</code> 的实现（位于 <code>anbox/src/anbox/container/client.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace container {
Client::Client(const std::shared_ptr&lt;Runtime&gt; &amp;rt)
    : messenger_(std::make_shared&lt;network::LocalSocketMessenger&gt;(
          SystemConfiguration::instance().container_socket_path(), rt)),
      pending_calls_(std::make_shared&lt;rpc::PendingCallCache&gt;()),
      rpc_channel_(std::make_shared&lt;rpc::Channel&gt;(pending_calls_, messenger_)),
      management_api_(std::make_shared&lt;ManagementApiStub&gt;(rpc_channel_)),
      processor_(
          std::make_shared&lt;rpc::MessageProcessor&gt;(messenger_, pending_calls_)) {
  read_next_message();
}
Client::~Client() {}
void Client::start(const Configuration &amp;configuration) {
  try {
    management_api_-&gt;start_container(configuration);
  } catch (const std::exception &amp;e) {
    ERROR(&quot;Failed to start container: %s&quot;, e.what());
    if (terminate_callback_)
      terminate_callback_();
  }
}
void Client::stop() {
  management_api_-&gt;stop_container();
}
void Client::register_terminate_handler(const TerminateCallback &amp;callback) {
  terminate_callback_ = callback;
}
void Client::read_next_message() {
  auto callback = std::bind(&amp;Client::on_read_size, this, std::placeholders::_1,
                            std::placeholders::_2);
  messenger_-&gt;async_receive_msg(callback, ba::buffer(buffer_));
}
void Client::on_read_size(const boost::system::error_code &amp;error,
                          std::size_t bytes_read) {
  if (error) {
    if (terminate_callback_)
      terminate_callback_();
    return;
  }
  std::vector&lt;std::uint8_t&gt; data(bytes_read);
  std::copy(buffer_.data(), buffer_.data() + bytes_read, data.data());
  if (processor_-&gt;process_data(data)) read_next_message();
}
}  // namespace container
}  // namespace anbox
</code></pre>
<p>在 <code>anbox::container::Client</code> 的构造函数中，通过传入目标域 Socket 的地址及 <code>std::shared_ptr&lt;Runtime&gt;</code> 来创建 <code>anbox::network::LocalSocketMessenger</code>。在 <code>anbox::network::LocalSocketMessenger</code> 的构造函数中会自动与目标服务建立连接。</p>
<p><code>anbox::network::LocalSocketMessenger</code> 的定义（位于 <code>anbox/src/anbox/network/local_socket_messenger.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class LocalSocketMessenger
    : public BaseSocketMessenger&lt;boost::asio::local::stream_protocol&gt; {
 public:
  LocalSocketMessenger(
      std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const
          &amp;socket);
  LocalSocketMessenger(const std::string &amp;path,
                       const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  ~LocalSocketMessenger();
 private:
  std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; socket_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::LocalSocketMessenger</code> 的实现（位于 <code>anbox/src/anbox/network/local_socket_messenger.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
LocalSocketMessenger::LocalSocketMessenger(
    std::shared_ptr&lt;boost::asio::local::stream_protocol::socket&gt; const &amp;socket)
    : BaseSocketMessenger(socket) {}
LocalSocketMessenger::LocalSocketMessenger(const std::string &amp;path,
                                           const std::shared_ptr&lt;Runtime&gt; &amp;rt)
    : socket_(std::make_shared&lt;boost::asio::local::stream_protocol::socket&gt;(
          rt-&gt;service())) {
  boost::system::error_code err;
  socket_-&gt;connect(boost::asio::local::stream_protocol::endpoint(path), err);
  if (err) {
    const auto msg = utils::string_format(&quot;Failed to connect to socket %s: %s&quot;,
                                          path, err.message());
    BOOST_THROW_EXCEPTION(std::runtime_error(msg));
  }
  setup(socket_);
}
LocalSocketMessenger::~LocalSocketMessenger() {}
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::LocalSocketMessenger</code> 对象创建完成后，将 Socket 提交给底层的 I/O 多路复用器，数据的收发及 Socket 的管理等，都与前面看到的为接受的新连接而创建的 <code>anbox::network::LocalSocketMessenger</code> 类似。</p>
<h2 id="发起一个到-tcp-服务器的连接"><a class="header" href="#发起一个到-tcp-服务器的连接">发起一个到 TCP 服务器的连接</a></h2>
<p>在 Anbox 中，仅有一个地方发起了到 TCP 服务器的连接，即在我们前面已经看到过的 <code>anbox::qemu::AdbMessageProcessor::wait_for_host_connection()</code> 函数中：</p>
<pre><code>try {
  // Notify the adb host instance so that it knows on which port our
  // proxy is waiting for incoming connections.
  auto messenger = std::make_shared&lt;network::TcpSocketMessenger&gt;(
      boost::asio::ip::address_v4::from_string(loopback_address), default_adb_client_port, runtime_);
  auto message = utils::string_format(&quot;host:emulator:%d&quot;, default_host_listen_port);
  auto handshake = utils::string_format(&quot;%04x%s&quot;, message.size(), message.c_str());
  messenger-&gt;send(handshake.data(), handshake.size());
} catch (...) {
  // Server not up. No problem, it will contact us when started.
}
</code></pre>
<p>在 Anbox 中，发起到 TCP 服务器的连接即是以目标 IP 地址和端口创建 <code>anbox::network::TcpSocketMessenger</code> 对象。<code>anbox::network::TcpSocketMessenger</code> 在其构造函数中会完成与目标服务的连接建立。<code>anbox::network::TcpSocketMessenger</code> 定义（位于 <code>anbox/src/anbox/network/tcp_socket_messenger.h</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
class TcpSocketMessenger : public BaseSocketMessenger&lt;boost::asio::ip::tcp&gt; {
 public:
  TcpSocketMessenger(const boost::asio::ip::address_v4 &amp;addr,
                     unsigned short port, const std::shared_ptr&lt;Runtime&gt; &amp;rt);
  TcpSocketMessenger(
      std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket);
  ~TcpSocketMessenger();
  unsigned short local_port() const override;
 private:
  unsigned short local_port_;
};
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::TcpSocketMessenger</code> 实现（位于 <code>anbox/src/anbox/network/tcp_socket_messenger.cpp</code>）如下：</p>
<pre><code>namespace anbox {
namespace network {
TcpSocketMessenger::TcpSocketMessenger(const boost::asio::ip::address_v4 &amp;addr,
                                       unsigned short port,
                                       const std::shared_ptr&lt;Runtime&gt; &amp;rt) {
  boost::asio::ip::tcp::endpoint endpoint(addr, port);
  auto socket = std::make_shared&lt;boost::asio::ip::tcp::socket&gt;(rt-&gt;service());
  socket-&gt;connect(endpoint);
  setup(socket);
  local_port_ = socket-&gt;local_endpoint().port();
}
TcpSocketMessenger::TcpSocketMessenger(
    std::shared_ptr&lt;boost::asio::ip::tcp::socket&gt; const &amp;socket)
    : BaseSocketMessenger(socket) {}
TcpSocketMessenger::~TcpSocketMessenger() {}
unsigned short TcpSocketMessenger::local_port() const { return local_port_; }
}  // namespace network
}  // namespace anbox
</code></pre>
<p><code>anbox::network::TcpSocketMessenger</code> 对象创建完成之后，将 Socket 提交给底层的 I/O 多路复用器，数据的收发及 Socket 的管理，都与前面看到的为接受的新连接而创建的 <code>anbox::network::TcpSocketMessenger</code> 类似。</p>
<p>发起一个到 Unix 域 Socket 服务的连接，与发起一个到 TCP 服务器的连接的过程极为相似，都是通过提供一个具体的地址创建一个 <code>SocketMessenger</code> 对象，具体 <code>SocketMessenger</code> 类的构造函数会自动建立连接。新创建的 <code>SocketMessenger</code> 对象与从接受的 Socket 创建的 <code>SocketMessenger</code> 对象无异。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="6.Anbox容器管理服务.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="6.2.Anbox实现分析-会话管理器与容器管理器的通信.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="6.Anbox容器管理服务.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="6.2.Anbox实现分析-会话管理器与容器管理器的通信.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
